<!doctype html>
<html lang="it" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <title>Analisi Evolutiva Scoliosi ‚Äì Medical UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b1220" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- TensorFlow.js + Depth Estimation (solo per metrica bacino) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/depth-estimation"></script>

  <style>
    :root{
      --bg:#f6f8fb;--bg2:#eef2f7;--panel:#ffffff;--panel2:#ffffff;
      --text:#0f172a;--muted:#64748b;--border:rgba(15,23,42,.10);
      --shadow:0 18px 55px rgba(15,23,42,.10);--shadow2:0 10px 30px rgba(15,23,42,.08);
      --accent:#0ea5e9;--accent2:#0284c7;--accentSoft:rgba(14,165,233,.12);
      --ok:#10b981;--warn:#f59e0b;--danger:#ef4444;
      --r-xl:22px;--r-lg:16px;--r-md:12px;--r-sm:10px;
      --font:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",Roboto,Arial,"Apple Color Emoji","Segoe UI Emoji";
    }
    html[data-theme="dark"]{
      --bg:#0b1220;--bg2:#070d18;--panel:#0f172a;--panel2:#0b1325;
      --text:#e5e7eb;--muted:#9aa4b2;--border:rgba(148,163,184,.18);
      --shadow:0 22px 65px rgba(0,0,0,.45);--shadow2:0 10px 30px rgba(0,0,0,.35);
      --accent:#38bdf8;--accent2:#0ea5e9;--accentSoft:rgba(56,189,248,.12);
    }

    *{box-sizing:border-box}
    body{
      margin:0;font-family:var(--font);color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(14,165,233,.20), transparent 60%),
        radial-gradient(900px 450px at 90% 0%, rgba(16,185,129,.10), transparent 50%),
        linear-gradient(180deg,var(--bg),var(--bg2));
      min-height:100vh;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    a{color:inherit}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}

    .topbar{
      position:sticky;top:0;z-index:50;
      backdrop-filter:blur(10px);
      background:color-mix(in oklab,var(--bg) 82%,transparent);
      border-bottom:1px solid var(--border);
    }
    .topbar-inner{
      max-width:1400px;margin:0 auto;padding:14px 16px;
      display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;
    }
    .brand{display:flex;align-items:center;gap:10px;min-width:240px}
    .brand-badge{
      width:38px;height:38px;border-radius:12px;
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      box-shadow:0 10px 26px rgba(14,165,233,.25);
      display:flex;align-items:center;justify-content:center;
      color:#04131f;font-weight:900;letter-spacing:.02em;
      flex:0 0 auto;
    }
    html[data-theme="dark"] .brand-badge{color:#06111f}
    .brand h1{margin:0;font-size:1.02rem;letter-spacing:.02em;line-height:1.1}
    .brand p{margin:0;font-size:.82rem;color:var(--muted);line-height:1.25}

    .top-actions{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end}

    button{
      border:1px solid transparent;border-radius:999px;
      padding:.58rem 1rem;font-size:.88rem;font-weight:700;
      cursor:pointer;touch-action:manipulation;
      background:linear-gradient(180deg,var(--accent),var(--accent2));
      color:#04131f;box-shadow:0 10px 26px rgba(14,165,233,.22);
      transition:transform .08s ease,box-shadow .12s ease,opacity .12s ease;
    }
    button:hover:not(:disabled){transform:translateY(-1px);box-shadow:0 14px 34px rgba(14,165,233,.26)}
    button:disabled{opacity:.55;cursor:default;box-shadow:none}
    .btn-secondary{
      background:color-mix(in oklab,var(--panel) 80%,transparent);
      color:var(--text);
      border-color:var(--border);
      box-shadow:var(--shadow2);
    }
    .btn-ghost{
      background:transparent;color:var(--text);
      border-color:var(--border);box-shadow:none;
    }
    .btn-danger{
      background:linear-gradient(180deg,#fb7185,#ef4444);
      color:#1a0206;box-shadow:0 10px 26px rgba(239,68,68,.18);
    }
    .icon-btn{padding:.55rem .75rem;display:inline-flex;align-items:center;gap:.45rem}

    input,select,textarea{
      font-family:var(--font);color:var(--text);
      background:color-mix(in oklab,var(--panel) 90%,transparent);
      border:1px solid var(--border);border-radius:12px;
      padding:.56rem .7rem;outline:none;
      transition:box-shadow .12s ease,border-color .12s ease;
    }
    input:focus,select:focus,textarea:focus{
      border-color:color-mix(in oklab,var(--accent) 60%,var(--border));
      box-shadow:0 0 0 4px var(--accentSoft);
    }
    label{font-size:.78rem;color:var(--muted);font-weight:700}
    input[type="file"]{width:100%}

    .app-shell{max-width:1400px;margin:16px auto;padding:16px}
    .grid{
      display:grid;
      grid-template-columns:minmax(0, 340px) minmax(0, 1.35fr) minmax(0, 430px);
      gap:14px;
      align-items:start;
    }
    @media (max-width: 1120px){
      .grid{grid-template-columns:1fr}
      .brand{min-width:unset}
    }

    .panel{
      background:color-mix(in oklab,var(--panel) 92%,transparent);
      border:1px solid var(--border);
      border-radius:var(--r-xl);
      box-shadow:var(--shadow2);
      padding:14px;
      overflow:hidden;
    }
    .panel-header{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
    .panel h2{margin:0;font-size:.98rem;letter-spacing:.01em}
    .chip{
      font-size:.72rem;color:var(--muted);
      border:1px solid var(--border);
      background:color-mix(in oklab,var(--panel) 85%,transparent);
      padding:.18rem .5rem;border-radius:999px;
      white-space:nowrap;
    }
    .hint{margin-top:10px;font-size:.82rem;color:var(--muted);line-height:1.45}

    .patient-form{
      display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px;
    }
    .patient-form .full{grid-column:1/-1}
    .field{display:flex;flex-direction:column;gap:6px}

    .dropzone{
      border:1.5px dashed color-mix(in oklab,var(--border) 70%,var(--muted));
      background:linear-gradient(180deg,color-mix(in oklab,var(--panel) 86%,transparent),color-mix(in oklab,var(--panel) 94%,transparent));
      border-radius:var(--r-lg);
      padding:12px;
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      margin-top:6px;
    }
    .dropzone.dragover{
      border-color:var(--accent);
      box-shadow:0 0 0 5px var(--accentSoft);
    }
    .dz-title{font-weight:900;font-size:.9rem}
    .dz-hint{color:var(--muted);font-size:.82rem;line-height:1.25}

    .status{margin-top:10px;font-size:.85rem;color:var(--muted);min-height:1.2rem}
    .status.error{color:var(--danger);font-weight:800}

    .file-list{
      margin-top:12px;
      display:flex;flex-direction:column;gap:8px;
      max-height:360px;overflow:auto;padding-right:4px;
    }
    .file-item{
      display:grid;
      grid-template-columns:56px 1fr auto;
      gap:10px;align-items:center;
      padding:10px;border-radius:16px;
      border:1px solid transparent;
      background:color-mix(in oklab,var(--panel2) 92%,transparent);
      cursor:pointer;
      transition:border-color .12s ease,transform .06s ease,background .12s ease;
    }
    .file-item:hover{border-color:color-mix(in oklab,var(--accent) 35%,var(--border));transform:translateY(-1px)}
    .file-item.active{border-color:var(--accent);box-shadow:0 0 0 4px var(--accentSoft)}
    .thumb{
      width:56px;height:56px;border-radius:14px;border:1px solid var(--border);
      background-size:cover;background-position:center;
      background-color:color-mix(in oklab,var(--bg2) 70%,var(--panel));
    }
    .file-main{display:flex;flex-direction:column;gap:6px;min-width:0}
    .file-name{font-weight:900;font-size:.86rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .file-meta{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .file-controls{display:flex;flex-direction:column;gap:6px;align-items:flex-end}
    .mini-row{display:flex;gap:6px;align-items:center}
    .mini-btn{
      padding:.2rem .5rem;border-radius:999px;border:1px solid var(--border);
      background:transparent;color:var(--muted);font-weight:900;box-shadow:none;
    }
    .mini-btn:hover{border-color:var(--accent);color:var(--text)}
    .mini-danger{border-color:color-mix(in oklab,var(--danger) 60%,var(--border));color:color-mix(in oklab,var(--danger) 70%,var(--text))}
    .mini-danger:hover{border-color:var(--danger);color:var(--danger)}

    #mainCanvas{
      width:100%;max-height:70vh;border-radius:var(--r-xl);
      border:1px solid var(--border);
      background:
        radial-gradient(700px 350px at 10% 0%, var(--accentSoft), transparent 55%),
        linear-gradient(180deg,color-mix(in oklab,var(--panel) 75%,transparent),color-mix(in oklab,var(--panel) 92%,transparent));
      box-shadow:var(--shadow2);
      touch-action:none;
    }

    .viewer-toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-top:10px}
    .viewer-nav{display:flex;gap:8px;align-items:center;flex:1 1 280px}
    .viewer-nav input[type="range"]{width:100%;accent-color:var(--accent)}
    .viewer-toggles{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end}
    .toggle{display:inline-flex;gap:8px;align-items:center;color:var(--muted);font-size:.84rem;font-weight:800}
    .toggle input{accent-color:var(--accent)}

    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
    .tab-btn{
      border-radius:999px;padding:.45rem .8rem;
      border:1px solid var(--border);
      background:transparent;color:var(--muted);font-weight:900;box-shadow:none;
    }
    .tab-btn.active{
      background:var(--accentSoft);
      border-color:color-mix(in oklab,var(--accent) 55%,var(--border));
      color:var(--text);
    }
    .tab-panel{display:none}
    .tab-panel.active{display:block}

    .chart-container{
      margin-top:10px;background:color-mix(in oklab,var(--panel2) 95%,transparent);
      border:1px solid var(--border);border-radius:var(--r-lg);
      padding:10px;
    }
    .chart-container h3{margin:0 0 8px 0;font-size:.88rem;color:var(--muted)}

    .manual-row{
      margin-top:12px;border:1px solid var(--border);
      background:color-mix(in oklab,var(--panel2) 94%,transparent);
      border-radius:var(--r-lg);padding:10px;
    }
    .manual-row strong{display:block;margin-bottom:6px;font-size:.86rem}
    .manual-controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .active-manual{border-color:color-mix(in oklab,var(--accent) 70%,var(--border))!important;box-shadow:0 0 0 4px var(--accentSoft)}

    .metric-row{
      margin-top:12px;font-size:.85rem;color:var(--muted);
      display:grid;grid-template-columns:repeat(2,minmax(0,1fr));
      gap:6px 12px;
    }
    @media (max-width: 520px){ .metric-row{grid-template-columns:1fr} }
    .metric-row strong{color:var(--text);font-weight:900}

    /* Busy overlay */
    .loading-overlay{
      position:fixed;inset:0;
      background:rgba(2,6,23,0.62);
      display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;
      z-index:9999;backdrop-filter:blur(10px);
    }
    html[data-theme="dark"] .loading-overlay{background:rgba(2,6,23,0.78)}
    .loading-overlay.hidden{display:none}
    .spinner{
      width:44px;height:44px;border-radius:999px;
      border:3px solid rgba(148,163,184,0.35);
      border-top-color:var(--accent);
      animation:spin .8s linear infinite;
    }
    .busy-text{color:#e2e8f0;font-weight:900;text-align:center;padding:0 16px}
    .progress-outer{
      width:260px;max-width:82vw;height:9px;border-radius:999px;
      background:rgba(15,23,42,0.55);
      border:1px solid rgba(148,163,184,0.35);overflow:hidden;
    }
    .progress-inner{width:0%;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));transition:width .18s ease}
    @keyframes spin{from{transform:rotate(0)}to{transform:rotate(360deg)}}

    /* Intro overlay (ridotto, mobile friendly) */
    .intro-overlay{
      position:fixed;inset:0;
      background:rgba(2,6,23,.70);
      display:flex;align-items:center;justify-content:center;
      z-index:10000;padding:16px;backdrop-filter:blur(10px);
    }
    .intro-overlay.hidden{display:none}
    .intro-card{
      width:min(520px,100%);
      background:color-mix(in oklab,var(--panel) 94%,transparent);
      border:1px solid var(--border);
      border-radius:22px;
      box-shadow:var(--shadow);
      padding:14px;
    }
    .intro-title{margin:0;font-size:1.05rem;font-weight:900}
    .intro-subtitle{margin:8px 0 0;color:var(--muted);font-size:.86rem;line-height:1.35;font-weight:700}
    .intro-steps{margin:10px 0 0;padding-left:18px;color:var(--muted);font-size:.84rem;line-height:1.35}
    .intro-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px;justify-content:flex-end}

    /* Toast */
    .toast-host{
      position:fixed;right:14px;bottom:14px;
      display:flex;flex-direction:column;gap:10px;
      z-index:12000;
      max-width:min(420px,calc(100vw - 28px));
    }
    .toast{
      border-radius:16px;border:1px solid var(--border);
      background:color-mix(in oklab,var(--panel) 92%,transparent);
      box-shadow:var(--shadow);
      padding:10px 12px;
      display:flex;gap:10px;align-items:flex-start;
    }
    .toast .dot{width:10px;height:10px;border-radius:999px;margin-top:5px;background:var(--accent);box-shadow:0 0 0 4px var(--accentSoft);flex:0 0 auto}
    .toast.warn .dot{background:var(--warn);box-shadow:0 0 0 4px rgba(245,158,11,.16)}
    .toast.error .dot{background:var(--danger);box-shadow:0 0 0 4px rgba(239,68,68,.16)}
    .toast .msg{font-size:.88rem;color:var(--text);line-height:1.25;font-weight:900}
    .toast .sub{font-size:.82rem;color:var(--muted);margin-top:2px;font-weight:700}

    /* Confirm modal */
    .confirm-overlay{
      position:fixed;inset:0;background:rgba(2,6,23,.55);
      display:flex;align-items:center;justify-content:center;
      z-index:13000;padding:16px;backdrop-filter:blur(10px);
    }
    .confirm-overlay.hidden{display:none}
    .confirm-card{
      width:min(520px,100%);
      border-radius:22px;border:1px solid var(--border);
      background:color-mix(in oklab,var(--panel) 94%,transparent);
      box-shadow:var(--shadow);
      padding:14px;
    }
    .confirm-card h3{margin:0 0 6px;font-size:1.02rem}
    .confirm-card p{margin:0;color:var(--muted);line-height:1.35;font-weight:700}
    .confirm-actions{margin-top:12px;display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap}

    /* Mobile ergonomics */
    @media (max-width: 520px){
      .topbar-inner{padding:12px 12px}
      .app-shell{padding:12px}
      .panel{padding:12px}
      button{width:100%}
      .top-actions button{width:auto}
      .dropzone{flex-direction:column;align-items:flex-start}
      .viewer-toolbar{gap:10px}
      .viewer-nav button{width:auto}
    }

    /* Print */
    @media print{
      .topbar,.toast-host,.confirm-overlay,#busyOverlay,.hint,.tabs,.manual-row,.viewer-toolbar{display:none!important}
      body{background:#fff!important}
      .panel{box-shadow:none!important;border:1px solid #ddd!important}
      .grid{grid-template-columns:1fr!important}
      #mainCanvas{max-height:none!important}
    }
  </style>
</head>

<body>
  <!-- INTRO -->
  <div id="introOverlay" class="intro-overlay">
    <div class="intro-card">
      <h2 class="intro-title">Analisi evolutiva scoliosi</h2>
      <p class="intro-subtitle">
        Carica pi√π foto dello stesso paziente (tempi diversi). L‚Äôapp stima posa, curve e metriche, genera grafici e report.
      </p>
      <ul class="intro-steps">
        <li>Carica le foto (anche drag&drop) e ordinale.</li>
        <li>Premi <strong>Analizza</strong> per estrarre pose/curve e aggiornare grafici.</li>
        <li>Se serve, forza la vista (Auto/Frontale/Posteriore/Laterale).</li>
        <li>Modalit√† manuale: trascina i punti per rifinire la curva e salva esempi per il training.</li>
      </ul>
      <div class="intro-actions">
        <button id="introStartBtn" type="button">Inizia</button>
        <button id="introSkipBtn" class="btn-secondary" type="button">Non mostrare pi√π</button>
      </div>
    </div>
  </div>

  <!-- TOPBAR -->
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="brand-badge">SC</div>
        <div>
          <h1>Analisi evolutiva scoliosi</h1>
          <p>Medical UI ‚Ä¢ mobile first ‚Ä¢ report stampabile</p>
        </div>
      </div>

      <div class="top-actions">
        <button id="helpBtn" class="btn-ghost icon-btn" type="button">‚ùî Guida</button>
        <button id="exportPrintBtn" class="btn-secondary icon-btn" type="button">üñ®Ô∏è Esporta PDF</button>
        <button id="themeToggleBtn" class="btn-secondary icon-btn" type="button">üåì Tema</button>
      </div>
    </div>
  </div>

  <div class="app-shell">
    <div class="grid">
      <!-- LEFT -->
      <section class="panel">
        <div class="panel-header">
          <h2>1) Paziente & immagini</h2>
          <span class="chip" id="sessionCounterChip">0 immagini</span>
        </div>

        <div class="patient-form" aria-label="Dati paziente">
          <div class="field">
            <label for="patientId">ID paziente</label>
            <input id="patientId" placeholder="es. 2025-001" autocomplete="off" />
          </div>
          <div class="field">
            <label for="patientName">Nome</label>
            <input id="patientName" placeholder="Nome Cognome" autocomplete="name" />
          </div>
          <div class="field">
            <label for="patientDob">Data di nascita</label>
            <input id="patientDob" type="date" />
          </div>
          <div class="field">
            <label for="patientSex">Sesso (opz.)</label>
            <select id="patientSex">
              <option value="">‚Äî</option>
              <option value="F">F</option>
              <option value="M">M</option>
              <option value="Altro">Altro</option>
            </select>
          </div>
          <div class="field full">
            <label for="patientNote">Nota clinica (opz.)</label>
            <input id="patientNote" placeholder="es. brace, trattamento, ecc." />
          </div>
          <div class="field full" style="display:flex;gap:8px;flex-wrap:wrap;">
            <button id="savePatientBtn" class="btn-secondary" type="button">Salva paziente</button>
            <button id="clearPatientBtn" class="btn-ghost" type="button">Svuota dati</button>
          </div>
        </div>

        <div id="dropzone" class="dropzone" role="button" tabindex="0" aria-label="Carica immagini tramite drag and drop o selezione file">
          <div style="display:flex;flex-direction:column;gap:4px;">
            <div class="dz-title">Carica foto (drag&drop)</div>
            <div class="dz-hint">Suggerimento: usa nomi con data (es. 2025-12-01_front.jpg) per timeline automatica.</div>
          </div>
          <button id="pickFilesBtn" class="btn-secondary" type="button">Seleziona</button>
        </div>

        <label class="sr-only" for="fileInput">Seleziona immagini</label>
        <input id="fileInput" type="file" accept="image/*" multiple />

        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;">
          <button id="analyzeBtn" disabled type="button">Analizza tutte le foto</button>
          <button id="clearBtn" class="btn-secondary" type="button">Svuota</button>
        </div>

        <div id="status" class="status"></div>
        <div class="file-list" id="fileList" aria-label="Elenco immagini"></div>

        <p class="hint">
          Tocca una foto per visualizzarla. Puoi cambiare la vista (Auto/Frontale/Posteriore/Laterale) e aggiungere data/nota.
          I metadati restano salvati nel browser (localStorage).
        </p>
      </section>

      <!-- CENTER -->
      <section class="panel">
        <div class="panel-header">
          <h2>2) Visualizzazione</h2>
          <span class="chip" id="viewChip">Vista: ‚Äî</span>
        </div>

        <canvas id="mainCanvas" width="600" height="800"></canvas>

        <div class="viewer-toolbar">
          <div class="viewer-nav">
            <button id="prevBtn" class="btn-secondary" type="button">‚Üê</button>
            <input id="scrubSlider" type="range" min="0" max="0" value="0" step="1" />
            <button id="nextBtn" class="btn-secondary" type="button">‚Üí</button>
          </div>
          <div class="viewer-toggles">
            <label class="toggle"><input type="checkbox" id="toggleSkeleton" checked /> Scheletro</label>
            <label class="toggle"><input type="checkbox" id="toggleSpine" checked /> Curva</label>
            <label class="toggle"><input type="checkbox" id="toggleVectors" checked /> Vettori</label>
          </div>
        </div>

        <div class="hint" style="margin-top:10px;font-weight:900;">
          Enfatizzazione curva (Œª): <span id="lambdaValue">2.5</span>x
        </div>
        <input type="range" id="lambdaSlider" min="1" max="6" step="0.1" value="2.5"
               style="width:100%;accent-color:var(--accent);margin-top:6px;" />

        <div class="manual-row">
          <strong>Controlli manuali colonna & training adattivo</strong>
          <div class="manual-controls">
            <button id="toggleManualBtn" class="btn-secondary" type="button">Punti manuali: OFF</button>
            <button id="undoPointBtn" class="btn-secondary" type="button">Annulla ultimo</button>
            <button id="clearManualBtn" class="btn-secondary" type="button">Raddrizza</button>
          </div>
          <div class="manual-controls" style="margin-top:8px;">
            <button id="saveExampleBtn" type="button">Salva esempio</button>
            <label class="toggle" style="margin-left:4px;">
              <input type="checkbox" id="enableLearning" checked />
              Applica modello appreso
            </label>
          </div>
          <p class="hint">
            In modalit√† manuale: Œª fissato a 1, trascina solo in orizzontale i 10 punti tra bacino e testa.
            Salva esempi per guidare il modello su curve simili.
          </p>
        </div>

        <div class="metric-row" id="metricRow"></div>

        <p class="hint">
          Nota: il Cobb √® una stima fotogrammetrica (non radiografica). Usare come supporto al follow-up, non come sostituto diagnostico.
        </p>
      </section>

      <!-- RIGHT -->
      <section class="panel">
        <div class="panel-header">
          <h2>3) Analitica & report</h2>
          <span class="chip" id="modelChip">Modello: 0 esempi</span>
        </div>

        <div class="tabs" role="tablist" aria-label="Sezioni analitica">
          <button class="tab-btn active" data-tab="tabCharts" type="button" role="tab">Grafici</button>
          <button class="tab-btn" data-tab="tabReport" type="button" role="tab">Report</button>
          <button class="tab-btn" data-tab="tabModel" type="button" role="tab">Modello</button>
        </div>

        <div id="tabCharts" class="tab-panel active" role="tabpanel">
          <div class="chart-container">
            <h3>Angoli spalle, bacino, testa, Cobb</h3>
            <canvas id="chartAngles" height="140"></canvas>
          </div>
          <div class="chart-container">
            <h3>Centratura testa / bacino / ‚Äústerno‚Äù</h3>
            <canvas id="chartOffsets" height="140"></canvas>
          </div>
          <div class="chart-container">
            <h3>Apprendimento modello (errore medio curva)</h3>
            <canvas id="chartModel" height="120"></canvas>
          </div>
        </div>

        <div id="tabReport" class="tab-panel" role="tabpanel">
          <div class="chart-container">
            <h3>Report tecnico</h3>
            <div class="hint" style="margin-top:0;">
              Usa ‚ÄúEsporta PDF‚Äù per stampare o archiviare in cartella clinica.
            </div>
          </div>

          <div class="manual-row" style="margin-top:10px;">
            <div id="reportPanel">
              <h3 style="margin:0 0 6px;">Report tecnico automatico</h3>
              <p style="margin:0;color:var(--muted);font-weight:700;">Analizza le immagini per generare il report.</p>
            </div>
          </div>
        </div>

        <div id="tabModel" class="tab-panel" role="tabpanel">
          <div class="manual-row" id="modelManagementRow">
            <strong>Modello appreso ‚Äì export/import</strong>
            <div class="manual-controls">
              <button id="downloadModelBtn" class="btn-secondary" type="button">Scarica modello (txt)</button>
              <label for="modelFileInput" class="btn-secondary" style="cursor:pointer;">
                Carica modello (txt/json)
              </label>
              <input id="modelFileInput" type="file" accept=".txt,.json" style="display:none;" />
            </div>
            <p class="hint">Il modello (esempi manuali) √® salvato nel browser. Puoi esportarlo e riutilizzarlo.</p>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- Busy overlay -->
  <div id="busyOverlay" class="loading-overlay hidden">
    <div class="spinner"></div>
    <div id="busyText" class="busy-text">Elaborazione in corso...</div>
    <div class="progress-outer">
      <div id="busyProgress" class="progress-inner"></div>
    </div>
  </div>

  <!-- Toast -->
  <div id="toastHost" class="toast-host" aria-live="polite" aria-relevant="additions"></div>

  <!-- Confirm -->
  <div id="confirmOverlay" class="confirm-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
    <div class="confirm-card">
      <h3 id="confirmTitle">Conferma</h3>
      <p id="confirmText">Sei sicuro?</p>
      <div class="confirm-actions">
        <button id="confirmCancelBtn" class="btn-secondary" type="button">Annulla</button>
        <button id="confirmOkBtn" class="btn-danger" type="button">Conferma</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { FilesetResolver, PoseLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js";

    // ---------------- UX helpers (toast, confirm, theme, patient, tabs, nav) ----------------
    const toastHost = document.getElementById("toastHost");
    function toast(msg, type="info", sub=""){
      if(!toastHost) return;
      const el=document.createElement("div");
      el.className=`toast ${type==="error"?"error":type==="warn"?"warn":""}`;
      el.innerHTML=`<div class="dot"></div><div><div class="msg">${msg}</div>${sub?`<div class="sub">${sub}</div>`:""}</div>`;
      toastHost.appendChild(el);
      setTimeout(()=>{ el.style.opacity="0"; el.style.transform="translateY(6px)"; setTimeout(()=>el.remove(),220); },3200);
    }

    const confirmOverlay = document.getElementById("confirmOverlay");
    const confirmText = document.getElementById("confirmText");
    const confirmOkBtn = document.getElementById("confirmOkBtn");
    const confirmCancelBtn = document.getElementById("confirmCancelBtn");
    function confirmAsync(message="Confermi?"){
      return new Promise((resolve)=>{
        if(!confirmOverlay||!confirmText||!confirmOkBtn||!confirmCancelBtn){ resolve(window.confirm(message)); return; }
        confirmText.textContent=message;
        confirmOverlay.classList.remove("hidden");
        const cleanup=()=>{
          confirmOverlay.classList.add("hidden");
          confirmOkBtn.onclick=null;
          confirmCancelBtn.onclick=null;
        };
        confirmOkBtn.onclick=()=>{ cleanup(); resolve(true); };
        confirmCancelBtn.onclick=()=>{ cleanup(); resolve(false); };
        confirmOverlay.addEventListener("click",(e)=>{ if(e.target===confirmOverlay){ cleanup(); resolve(false); } },{once:true});
      });
    }

    const themeBtn = document.getElementById("themeToggleBtn");
    function applyTheme(next){
      document.documentElement.setAttribute("data-theme", next);
      try{ localStorage.setItem("scoliosisTheme_v2", next); }catch{}
      // (charts theme refresh happens lazily on next update)
    }
    (function initTheme(){
      let t=null; try{ t=localStorage.getItem("scoliosisTheme_v2"); }catch{}
      if(!t){
        t = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      }
      applyTheme(t);
    })();
    themeBtn?.addEventListener("click",()=>{
      const cur=document.documentElement.getAttribute("data-theme")||"dark";
      applyTheme(cur==="dark"?"light":"dark");
      // force chart redraw:
      if(anglesChart) anglesChart.update();
      if(offsetsChart) offsetsChart.update();
      if(modelChart) modelChart.update();
    });

    // Tabs
    document.querySelectorAll(".tab-btn").forEach((btn)=>{
      btn.addEventListener("click",()=>{
        document.querySelectorAll(".tab-btn").forEach(b=>b.classList.remove("active"));
        document.querySelectorAll(".tab-panel").forEach(p=>p.classList.remove("active"));
        btn.classList.add("active");
        const id=btn.getAttribute("data-tab");
        document.getElementById(id)?.classList.add("active");
      });
    });

    // Intro overlay
    const introOverlay = document.getElementById("introOverlay");
    const introStartBtn = document.getElementById("introStartBtn");
    const introSkipBtn = document.getElementById("introSkipBtn");
    function hideIntroOverlay(permanent=false){
      introOverlay.classList.add("hidden");
      if(permanent){ try{ localStorage.setItem("scoliosisIntroSeen_v2","1"); }catch{} }
    }
    (function initIntro(){
      let seen=null; try{ seen=localStorage.getItem("scoliosisIntroSeen_v2"); }catch{}
      if(seen==="1") introOverlay.classList.add("hidden");
    })();
    introStartBtn?.addEventListener("click",()=>hideIntroOverlay(false));
    introSkipBtn?.addEventListener("click",()=>hideIntroOverlay(true));
    document.getElementById("helpBtn")?.addEventListener("click",()=>introOverlay.classList.remove("hidden"));

    // Print
    document.getElementById("exportPrintBtn")?.addEventListener("click",()=>{
      document.querySelector('.tab-btn[data-tab="tabReport"]')?.click();
      window.print();
    });

    // Patient
    const patientIdEl = document.getElementById("patientId");
    const patientNameEl = document.getElementById("patientName");
    const patientDobEl = document.getElementById("patientDob");
    const patientSexEl = document.getElementById("patientSex");
    const patientNoteEl = document.getElementById("patientNote");
    function readPatient(){
      return {
        id: patientIdEl?.value?.trim()||"",
        name: patientNameEl?.value?.trim()||"",
        dob: patientDobEl?.value||"",
        sex: patientSexEl?.value||"",
        note: patientNoteEl?.value?.trim()||""
      };
    }
    function loadPatient(){
      try{
        const raw=localStorage.getItem("scoliosisPatient_v2");
        if(!raw) return;
        const p=JSON.parse(raw);
        if(patientIdEl) patientIdEl.value=p.id||"";
        if(patientNameEl) patientNameEl.value=p.name||"";
        if(patientDobEl) patientDobEl.value=p.dob||"";
        if(patientSexEl) patientSexEl.value=p.sex||"";
        if(patientNoteEl) patientNoteEl.value=p.note||"";
      }catch{}
    }
    function savePatient(){
      try{ localStorage.setItem("scoliosisPatient_v2", JSON.stringify(readPatient())); }catch{}
      toast("Dati paziente salvati","info");
      buildTechnicalReport();
    }
    function clearPatient(){
      if(patientIdEl) patientIdEl.value="";
      if(patientNameEl) patientNameEl.value="";
      if(patientDobEl) patientDobEl.value="";
      if(patientSexEl) patientSexEl.value="";
      if(patientNoteEl) patientNoteEl.value="";
      try{ localStorage.removeItem("scoliosisPatient_v2"); }catch{}
      toast("Dati paziente svuotati","warn");
      buildTechnicalReport();
    }
    document.getElementById("savePatientBtn")?.addEventListener("click",savePatient);
    document.getElementById("clearPatientBtn")?.addEventListener("click",clearPatient);
    loadPatient();

    function inferDateFromFilename(name){
      if(!name) return "";
      const s=name.toLowerCase();
      let m=s.match(/(20\\d{2})[-_\\.](0\\d|1[0-2])[-_\\.]([0-2]\\d|3[01])/);
      if(m) return `${m[1]}-${m[2]}-${m[3]}`;
      m=s.match(/(20\\d{2})(0\\d|1[0-2])([0-2]\\d|3[01])/);
      if(m) return `${m[1]}-${m[2]}-${m[3]}`;
      m=s.match(/([0-2]\\d|3[01])[-_\\.](0\\d|1[0-2])[-_\\.](20\\d{2})/);
      if(m) return `${m[3]}-${m[2]}-${m[1]}`;
      return "";
    }

    // Dropzone
    const dropzone = document.getElementById("dropzone");
    const pickFilesBtn = document.getElementById("pickFilesBtn");
    const fileInput = document.getElementById("fileInput");
    pickFilesBtn?.addEventListener("click",()=>fileInput.click());
    dropzone?.addEventListener("click",()=>fileInput.click());
    dropzone?.addEventListener("keydown",(e)=>{ if(e.key==="Enter"||e.key===" ") fileInput.click(); });
    ["dragenter","dragover"].forEach(evt=>{
      dropzone?.addEventListener(evt,(e)=>{ e.preventDefault(); dropzone.classList.add("dragover"); });
    });
    ["dragleave","drop"].forEach(evt=>{
      dropzone?.addEventListener(evt,(e)=>{ e.preventDefault(); dropzone.classList.remove("dragover"); });
    });
    dropzone?.addEventListener("drop",(e)=>{
      const dt=e.dataTransfer;
      if(!dt?.files?.length) return;
      fileInput.files = dt.files;
      fileInput.dispatchEvent(new Event("change"));
    });

    // ---------------- Original logic (con minime migliorie UI) ----------------

    const PoseIdx = {
      NOSE: 0, LEFT_EYE: 2, RIGHT_EYE: 5, MOUTH_LEFT: 9, MOUTH_RIGHT: 10,
      LEFT_SHOULDER: 11, RIGHT_SHOULDER: 12,
      LEFT_HIP: 23, RIGHT_HIP: 24,
      LEFT_EAR: 7, RIGHT_EAR: 8
    };

    const SPINE_SAMPLES = 21;
    const CONTROL_POINTS = 10;

    // soglie clinico-fotogrammetriche
    const CURVE_NOISE_DEV_NORM = 0.02;
    const CURVE_SUSPECT_DEV_NORM = 0.035;
    const COBB_NOISE_FLOOR_DEG = 5;
    const COBB_SUSPECT_DEG = 10;

    let poseLandmarker = null;
    let modelReady = false;
    let depthEstimator = null;
    let depthReady = false;
    let imagesReady = false;

    let sessions = [];
    let currentIndex = 0;
    let curveLambda = 2.5;
    let lambdaBackup = curveLambda;

    let anglesChart = null;
    let offsetsChart = null;
    let modelChart = null;
    let modelErrorHistory = [];

    // manual & training
    let manualMode = false;
    let trainingExamples = []; // {features:[], offsets:[]}
    let isDraggingControl = false;
    let draggingControlIndex = -1;
    let lastDraggedIndex = -1;

    // UI refs
    const analyzeBtn = document.getElementById("analyzeBtn");
    const clearBtn = document.getElementById("clearBtn");
    const statusEl = document.getElementById("status");
    const fileListEl = document.getElementById("fileList");
    const mainCanvas = document.getElementById("mainCanvas");
    const mainCtx = mainCanvas.getContext("2d");
    const metricRow = document.getElementById("metricRow");
    const reportPanel = document.getElementById("reportPanel");

    const toggleSkeleton = document.getElementById("toggleSkeleton");
    const toggleSpine = document.getElementById("toggleSpine");
    const toggleVectors = document.getElementById("toggleVectors");

    const lambdaSlider = document.getElementById("lambdaSlider");
    const lambdaValue = document.getElementById("lambdaValue");

    const toggleManualBtn = document.getElementById("toggleManualBtn");
    const undoPointBtn = document.getElementById("undoPointBtn");
    const clearManualBtn = document.getElementById("clearManualBtn");
    const saveExampleBtn = document.getElementById("saveExampleBtn");
    const enableLearning = document.getElementById("enableLearning");

    const downloadModelBtn = document.getElementById("downloadModelBtn");
    const modelFileInput = document.getElementById("modelFileInput");

    const busyOverlay = document.getElementById("busyOverlay");
    const busyText = document.getElementById("busyText");
    const busyProgress = document.getElementById("busyProgress");

    // Viewer nav
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const scrubSlider = document.getElementById("scrubSlider");
    const viewChip = document.getElementById("viewChip");
    const modelChip = document.getElementById("modelChip");
    const sessionCounterChip = document.getElementById("sessionCounterChip");

    function setStatus(text, isError=false){
      statusEl.classList.toggle("error", !!isError);
      statusEl.textContent = text || "";
      if(text) toast(text, isError ? "error" : "info");
    }

    function getEffectiveViewType(session) {
      if (!session) return "non determinata";
      if (session.viewTypeOverride && session.viewTypeOverride !== "auto") return session.viewTypeOverride;
      return session.viewTypeAuto || session.viewType || "non determinata";
    }

    function showBusy(text = "Elaborazione in corso...", fraction = 0) {
      busyOverlay.classList.remove("hidden");
      busyText.textContent = text;
      busyProgress.style.width = `${Math.round(fraction * 100)}%`;
    }
    function updateBusy(text, fraction) {
      if (text) busyText.textContent = text;
      if (typeof fraction === "number") busyProgress.style.width = `${Math.round(fraction * 100)}%`;
    }
    function hideBusy() {
      busyOverlay.classList.add("hidden");
      busyProgress.style.width = "0%";
    }

    function updateNavUI(){
      const n=sessions.length;
      if(sessionCounterChip) sessionCounterChip.textContent = `${n} immagini`;
      scrubSlider.max = String(Math.max(0,n-1));
      scrubSlider.value = String(Math.min(currentIndex, Math.max(0,n-1)));
      if(prevBtn) prevBtn.disabled = n===0 || currentIndex<=0;
      if(nextBtn) nextBtn.disabled = n===0 || currentIndex>=n-1;

      const s=sessions[currentIndex];
      if(viewChip) viewChip.textContent = `Vista: ${s ? getEffectiveViewType(s) : "‚Äî"}`;
      if(modelChip) modelChip.textContent = `Modello: ${trainingExamples.length} esempi`;
    }
    function goTo(i){
      if(!sessions.length) return;
      currentIndex = Math.max(0, Math.min(sessions.length-1, i));
      renderSession(currentIndex);
    }
    prevBtn?.addEventListener("click",()=>goTo(currentIndex-1));
    nextBtn?.addEventListener("click",()=>goTo(currentIndex+1));
    scrubSlider?.addEventListener("input",()=>goTo(parseInt(scrubSlider.value||"0",10)));
    window.addEventListener("keydown",(e)=>{
      if(e.target && ["INPUT","TEXTAREA","SELECT"].includes(e.target.tagName)) return;
      if(e.key==="ArrowLeft") goTo(currentIndex-1);
      if(e.key==="ArrowRight") goTo(currentIndex+1);
      if(e.key==="?") introOverlay.classList.remove("hidden");
    });

    function midpoint(a, b){ if(!a||!b) return null; return { x:(a.x+b.x)/2, y:(a.y+b.y)/2, z:(a.z+b.z)/2 }; }
    function averagePoints(points){
      const valid=points.filter(p=>p);
      if(!valid.length) return null;
      const sum=valid.reduce((acc,p)=>{ acc.x+=p.x; acc.y+=p.y; acc.z+=(p.z||0); return acc; },{x:0,y:0,z:0});
      return { x:sum.x/valid.length, y:sum.y/valid.length, z:sum.z/valid.length };
    }
    function distance(a,b){ if(!a||!b) return 0; return Math.hypot(a.x-b.x,a.y-b.y); }
    function rad2deg(r){ return (r*180)/Math.PI; }
    function normalizeAngle90(deg){
      if(deg===null||deg===undefined||!Number.isFinite(deg)) return null;
      let a=deg; while(a<=-90) a+=180; while(a>90) a-=180; return a;
    }
    function angleOfLineDeg(p1,p2){
      if(!p1||!p2) return null;
      const raw=rad2deg(Math.atan2(p2.y-p1.y,p2.x-p1.x));
      return normalizeAngle90(raw);
    }
    function headTiltRelativeVerticalDeg(head, neck){
      if(!head||!neck) return null;
      const vx=head.x-neck.x, vy=head.y-neck.y;
      const norm=Math.hypot(vx,vy)||1;
      const ux=0, uy=-1;
      let cos=(vx*ux+vy*uy)/norm; cos=Math.min(1,Math.max(-1,cos));
      let angle=rad2deg(Math.acos(cos)); if(angle>90) angle=180-angle;
      const sign=vx>=0?1:-1;
      return normalizeAngle90(angle*sign);
    }
    function angleBetweenVectorsDeg(v1,v2){
      const dot=v1.x*v2.x+v1.y*v2.y;
      const n1=Math.hypot(v1.x,v1.y), n2=Math.hypot(v2.x,v2.y);
      if(n1===0||n2===0) return 0;
      let cos=dot/(n1*n2); cos=Math.min(1,Math.max(-1,cos));
      return rad2deg(Math.acos(cos));
    }

    function computeAlignmentTransform(kp, img){
      const pelvis=kp.pelvisCenter;
      const top=kp.headCenter||kp.neckBase||kp.shoulderMid;
      if(!pelvis||!top){
        return { pelvis:{x:img.naturalWidth/2,y:img.naturalHeight*0.8}, rotation:0, scale:1, tx:mainCanvas.width/2, ty:mainCanvas.height*0.8 };
      }
      const dx=top.x-pelvis.x, dy=top.y-pelvis.y;
      const currentAngle=Math.atan2(dy,dx);
      const desiredAngle=-Math.PI/2;
      const rotation=desiredAngle-currentAngle;
      const torsoLen=Math.max(distance(top,pelvis),1);
      const desiredTorsoLen=mainCanvas.height*0.5;
      const scale=desiredTorsoLen/torsoLen;
      const tx=mainCanvas.width/2, ty=mainCanvas.height*0.8;
      return { pelvis, rotation, scale, tx, ty };
    }
    function transformPoint(p, t){
      const {pelvis, rotation, scale, tx, ty}=t;
      const x0=p.x-pelvis.x, y0=p.y-pelvis.y;
      const x1=x0*scale, y1=y0*scale;
      const cosA=Math.cos(rotation), sinA=Math.sin(rotation);
      const x2=x1*cosA-y1*sinA;
      const y2=x1*sinA+y1*cosA;
      return { x:x2+tx, y:y2+ty };
    }
    function drawImageWithTransform(ctx, image, t){
      const {pelvis, rotation, scale, tx, ty}=t;
      ctx.save();
      ctx.translate(tx,ty);
      ctx.rotate(rotation);
      ctx.scale(scale,scale);
      ctx.translate(-pelvis.x,-pelvis.y);
      ctx.drawImage(image,0,0);
      ctx.restore();
    }

    function extractKeypoints(landmarks,width,height){
      const p=(idx)=>{
        const lm=landmarks[idx];
        if(!lm) return null;
        return { x:lm.x*width, y:lm.y*height, z:lm.z||0, visibility:lm.visibility??1 };
      };
      const leftShoulder=p(PoseIdx.LEFT_SHOULDER);
      const rightShoulder=p(PoseIdx.RIGHT_SHOULDER);
      const leftHip=p(PoseIdx.LEFT_HIP);
      const rightHip=p(PoseIdx.RIGHT_HIP);
      const pelvisCenter=midpoint(leftHip,rightHip);
      const shoulderMid=midpoint(leftShoulder,rightShoulder);
      const leftEar=p(PoseIdx.LEFT_EAR);
      const rightEar=p(PoseIdx.RIGHT_EAR);
      const nose=p(PoseIdx.NOSE);
      const leftEye=p(PoseIdx.LEFT_EYE);
      const rightEye=p(PoseIdx.RIGHT_EYE);
      const mouthLeft=p(PoseIdx.MOUTH_LEFT);
      const mouthRight=p(PoseIdx.MOUTH_RIGHT);
      const headCenter=averagePoints([leftEar,rightEar,nose,leftEye,rightEye]);
      const neckBase=midpoint(shoulderMid, headCenter||shoulderMid);
      const midTorso=midpoint(shoulderMid, pelvisCenter);
      return { nose,leftEye,rightEye,mouthLeft,mouthRight,leftShoulder,rightShoulder,leftHip,rightHip,pelvisCenter,shoulderMid,headCenter,neckBase,midTorso,leftEar,rightEar };
    }

    function detectPoseOrientation(landmarks,kp){
      const ls=kp.leftShoulder, rs=kp.rightShoulder, pelvis=kp.pelvisCenter, neck=kp.neckBase||kp.shoulderMid;
      if(!ls||!rs||!pelvis||!neck) return "non determinata";
      const torsoLen=distance(neck,pelvis)||1;
      const shoulderWidth=Math.abs(ls.x-rs.x);
      const shoulderWidthNorm=shoulderWidth/torsoLen;
      if(shoulderWidthNorm<0.25) return "laterale";
      const nose=landmarks[PoseIdx.NOSE], le=landmarks[PoseIdx.LEFT_EYE], re=landmarks[PoseIdx.RIGHT_EYE],
            ml=landmarks[PoseIdx.MOUTH_LEFT], mr=landmarks[PoseIdx.MOUTH_RIGHT];
      const faceVisible=[nose,le,re,ml,mr].filter(l=>l && typeof l.visibility==="number");
      let score=0;
      if(faceVisible.length) score=faceVisible.reduce((s,l)=>s+l.visibility,0)/faceVisible.length;
      return score>0.35 ? "frontale" : "posteriore";
    }

    function computeDetailedCanonicalRepere(kpC){
      const ribsLeft=[], ribsRight=[], ribsMid=[];
      const ribFracs=[0.15,0.3,0.45,0.6,0.75,0.9];
      if(kpC.leftShoulder && kpC.leftHip && kpC.rightShoulder && kpC.rightHip){
        for(const f of ribFracs){
          const L={ x:kpC.leftShoulder.x+f*(kpC.leftHip.x-kpC.leftShoulder.x),
                    y:kpC.leftShoulder.y+f*(kpC.leftHip.y-kpC.leftShoulder.y), z:0 };
          const R={ x:kpC.rightShoulder.x+f*(kpC.rightHip.x-kpC.rightShoulder.x),
                    y:kpC.rightShoulder.y+f*(kpC.rightHip.y-kpC.rightShoulder.y), z:0 };
          ribsLeft.push(L); ribsRight.push(R); ribsMid.push(midpoint(L,R));
        }
      }
      let sternum=null;
      if(ribsMid.length) sternum=ribsMid[0];
      else if(kpC.shoulderMid && kpC.midTorso) sternum=midpoint(kpC.shoulderMid,kpC.midTorso);
      else sternum=kpC.shoulderMid||kpC.neckBase||null;

      const clavSegments=[];
      if(kpC.neckBase){
        if(kpC.leftShoulder) clavSegments.push({start:kpC.neckBase,end:kpC.leftShoulder});
        if(kpC.rightShoulder) clavSegments.push({start:kpC.neckBase,end:kpC.rightShoulder});
      }

      const scmSegments=[];
      const leftMastoid=kpC.leftEar||kpC.headCenter;
      const rightMastoid=kpC.rightEar||kpC.headCenter;
      if(leftMastoid && sternum) scmSegments.push({start:leftMastoid,end:sternum});
      if(rightMastoid && sternum) scmSegments.push({start:rightMastoid,end:sternum});

      return { ribsLeft,ribsRight,ribsMid,sternum,clavSegments,scmSegments };
    }

    function estimateSpineCanonical(kpC, viewType){
      const points=[];
      const vt=viewType||"non determinata";
      if(vt==="laterale"){
        if(kpC.pelvisCenter) points.push(kpC.pelvisCenter);
        if(kpC.midTorso) points.push(kpC.midTorso);
        if(kpC.neckBase||kpC.shoulderMid) points.push(kpC.neckBase||kpC.shoulderMid);
        if(kpC.headCenter) points.push(kpC.headCenter);
      } else if(vt==="posteriore"){
        if(kpC.pelvisCenter) points.push(kpC.pelvisCenter);
        if(kpC.ribsMid && kpC.ribsMid.length){
          const sorted=[...kpC.ribsMid].sort((a,b)=>b.y-a.y);
          sorted.forEach(p=>points.push(p));
        } else if(kpC.midTorso) points.push(kpC.midTorso);
        if(kpC.neckBase||kpC.shoulderMid) points.push(kpC.neckBase||kpC.shoulderMid);
        if(kpC.headCenter) points.push(kpC.headCenter);
      } else {
        if(kpC.pelvisCenter) points.push(kpC.pelvisCenter);
        if(kpC.ribsMid && kpC.ribsMid.length){
          const sorted=[...kpC.ribsMid].sort((a,b)=>b.y-a.y);
          sorted.forEach(p=>points.push(p));
        } else if(kpC.midTorso) points.push(kpC.midTorso);
        if(kpC.sternum) points.push(kpC.sternum);
        if(kpC.neckBase||kpC.shoulderMid) points.push(kpC.neckBase||kpC.shoulderMid);
        if(kpC.headCenter) points.push(kpC.headCenter);
      }
      if(points.length<2) return null;
      const anglesLocal=[];
      for(let i=1;i<points.length-1;i++){
        const v1={x:points[i].x-points[i-1].x,y:points[i].y-points[i-1].y};
        const v2={x:points[i+1].x-points[i].x,y:points[i+1].y-points[i].y};
        anglesLocal.push(angleBetweenVectorsDeg(v1,v2));
      }
      const maxAngle=anglesLocal.reduce((acc,v)=>Math.max(acc,Math.abs(v)),0);
      return { basePoints:points, maxAngleLocal:maxAngle };
    }

    function computeSpineSpline(basePoints, samples=SPINE_SAMPLES){
      if(!basePoints||basePoints.length<2) return { points:null };
      const n=basePoints.length;
      const pts=[];
      for(let i=0;i<samples;i++){
        const tGlobal=(i/(samples-1))*(n-1);
        const i0=Math.floor(tGlobal);
        const i1=Math.min(n-1,i0+1);
        const localT=tGlobal-i0;
        const p0=basePoints[i0], p1=basePoints[i1];
        pts.push({ x:p0.x+(p1.x-p0.x)*localT, y:p0.y+(p1.y-p0.y)*localT });
      }
      const smoothed=pts.map((p,idx)=>{
        const w=[]; if(idx>0) w.push(pts[idx-1]); w.push(p); if(idx<pts.length-1) w.push(pts[idx+1]);
        return { x:w.reduce((s,q)=>s+q.x,0)/w.length, y:w.reduce((s,q)=>s+q.y,0)/w.length };
      });
      return { points:smoothed };
    }

    function estimateCobbAngle(pelvisTiltDeg, headAxisDeg, splinePoints){
      let bottomSplineA=null, topSplineA=null;
      if(splinePoints && splinePoints.length>=6){
        const k=2;
        bottomSplineA=angleOfLineDeg(splinePoints[0], splinePoints[k]);
        topSplineA=angleOfLineDeg(splinePoints[splinePoints.length-1-k], splinePoints[splinePoints.length-1]);
      }
      let bottomA=bottomSplineA, topA=topSplineA;
      const hasPelvis=pelvisTiltDeg!=null && Number.isFinite(pelvisTiltDeg);
      const hasHead=headAxisDeg!=null && Number.isFinite(headAxisDeg);
      if(hasPelvis){
        const axisInf=normalizeAngle90(pelvisTiltDeg+90);
        bottomA = bottomA==null ? axisInf : 0.5*bottomA + 0.5*axisInf;
      }
      if(hasHead){
        const axisSup=normalizeAngle90(headAxisDeg);
        topA = topA==null ? axisSup : 0.5*topA + 0.5*axisSup;
      }
      if(bottomA==null || topA==null) return null;
      const aTop=normalizeAngle90(topA), aBot=normalizeAngle90(bottomA);
      let diff=Math.abs(aTop-aBot);
      if(diff>90) diff=180-diff;
      return diff;
    }

    function analyzeSpineDeviation(spinePoints, kpC){
      if(!spinePoints||spinePoints.length<2||!kpC||!kpC.pelvisCenter) return null;
      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid;
      if(!headC) return null;
      const vx=headC.x-pelvisC.x, vy=headC.y-pelvisC.y;
      const len=Math.hypot(vx,vy)||1;
      const nx=-vy/len, ny=vx/len;
      let maxAbsOff=0, sumAbsOff=0, midOffset=0;
      const n=spinePoints.length;
      const offsetsNorm=[];
      for(let i=0;i<n;i++){
        const p=spinePoints[i]; if(!p) continue;
        const wx=p.x-pelvisC.x, wy=p.y-pelvisC.y;
        const off=wx*nx + wy*ny;
        const absOff=Math.abs(off);
        if(absOff>maxAbsOff) maxAbsOff=absOff;
        sumAbsOff += absOff;
        if(i===Math.floor(n/2)) midOffset=off;
        offsetsNorm.push(off/len);
      }
      const meanAbsOff=n ? sumAbsOff/n : 0;
      const maxDevNorm=maxAbsOff/len;
      const meanDevNorm=meanAbsOff/len;
      return {
        maxDeviationPx:maxAbsOff,
        maxDeviationNorm:maxDevNorm,
        meanDeviationNorm:meanDevNorm,
        midOffsetNorm:midOffset/len,
        curveIsNoise:maxDevNorm < CURVE_NOISE_DEV_NORM,
        curveIsBorder:maxDevNorm >= CURVE_NOISE_DEV_NORM && maxDevNorm < CURVE_SUSPECT_DEV_NORM,
        curveIsSignificant:maxDevNorm >= CURVE_SUSPECT_DEV_NORM,
        offsetsNorm
      };
    }

    function computeCurveCategory(absCobb, analysis, viewType){
      if(viewType==="laterale") return "vista laterale (curva sagittale; Cobb non applicabile)";
      if(!analysis) return "non valutabile";
      const dev=analysis.maxDeviationNorm ?? 0;
      if(dev < CURVE_NOISE_DEV_NORM && absCobb < COBB_NOISE_FLOOR_DEG) return "schiena pressoch√© dritta (entro rumore)";
      if(dev < CURVE_SUSPECT_DEV_NORM && absCobb < COBB_SUSPECT_DEG) return "asimmetria lieve / non specifica";
      if(analysis.curveIsSignificant && absCobb >= COBB_SUSPECT_DEG) return "curva potenzialmente scoliotica (da confermare Rx)";
      return "asimmetria moderata";
    }

    function postProcessCurveMetrics(session){
      if(!session||!session.metrics||!session.spineSpline||!session.keypointsCanonical){ session.curveAnalysis=null; return; }
      const vType=getEffectiveViewType(session);
      const analysis=analyzeSpineDeviation(session.spineSpline, session.keypointsCanonical);
      session.curveAnalysis=analysis;
      if(!analysis){ session.metrics.curveMaxDeviationNorm=null; session.metrics.curveCategory="non valutabile"; return; }
      if(vType==="laterale"){
        session.metrics.cobbAngleDeg=null;
        session.metrics.curveMaxDeviationNorm=analysis.maxDeviationNorm;
        session.metrics.curveCategory=computeCurveCategory(0,analysis,vType);
        return;
      }
      let cobb=session.metrics.cobbAngleDeg;
      if(cobb==null||!Number.isFinite(cobb)) cobb=0;
      let absCobb=Math.abs(cobb);
      if(absCobb < COBB_NOISE_FLOOR_DEG){ cobb=0; absCobb=0; }
      session.metrics.cobbAngleDeg=cobb;
      session.metrics.curveMaxDeviationNorm=analysis.maxDeviationNorm;
      session.metrics.curveCategory=computeCurveCategory(absCobb,analysis,vType);
    }

    function drawSkeleton(ctx,kpC,viewType){
      if(!toggleSkeleton.checked||!kpC) return;
      ctx.save();
      function drawSegment(a,b,color,width=3){
        if(!a||!b) return;
        ctx.strokeStyle=color; ctx.lineWidth=width;
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      }
      const vt=viewType||"non determinata";
      const shoulderColor=vt==="posteriore"?"rgba(248,113,113,0.95)":"rgba(148,163,184,0.95)";
      const ribColor=vt==="posteriore"?"rgba(248,250,252,0.9)":"rgba(59,130,246,0.9)";

      drawSegment(kpC.leftShoulder,kpC.rightShoulder,shoulderColor);
      drawSegment(kpC.leftHip,kpC.rightHip,"rgba(248,113,113,0.9)");
      drawSegment(kpC.leftShoulder,kpC.leftHip,"rgba(148,163,184,0.7)",2);
      drawSegment(kpC.rightShoulder,kpC.rightHip,"rgba(148,163,184,0.7)",2);
      drawSegment(kpC.shoulderMid,kpC.pelvisCenter,"rgba(148,163,184,0.6)",2);
      drawSegment(kpC.headCenter,kpC.neckBase,"rgba(148,163,184,0.9)",2);

      if(kpC.ribsLeft && kpC.ribsRight){
        ctx.strokeStyle=ribColor; ctx.lineWidth=2; ctx.fillStyle=ribColor;
        for(let i=0;i<kpC.ribsLeft.length;i++){
          const L=kpC.ribsLeft[i], R=kpC.ribsRight[i];
          if(!L||!R) continue;
          ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(R.x,R.y); ctx.stroke();
          ctx.beginPath(); ctx.arc(L.x,L.y,3,0,Math.PI*2); ctx.arc(R.x,R.y,3,0,Math.PI*2); ctx.fill();
        }
      }
      if(kpC.sternum){
        ctx.fillStyle="rgba(56,189,248,0.95)";
        ctx.beginPath(); ctx.arc(kpC.sternum.x,kpC.sternum.y,5,0,Math.PI*2); ctx.fill();
      }
      if(kpC.clavSegments){
        for(const seg of kpC.clavSegments) drawSegment(seg.start, seg.end, "rgba(56,189,248,0.9)", 3);
      }
      if(kpC.scmSegments){
        for(const seg of kpC.scmSegments) drawSegment(seg.start, seg.end, "rgba(251,191,36,0.9)", 2);
      }
      ctx.fillStyle="rgba(56,189,248,0.95)";
      const pts=[kpC.headCenter,kpC.neckBase,kpC.shoulderMid,kpC.leftShoulder,kpC.rightShoulder,kpC.leftHip,kpC.rightHip,kpC.pelvisCenter];
      for(const p of pts){ if(!p) continue; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
    }

    function emphasizedSpinePoints(session){
      const pts=session.spineSpline;
      if(!pts||!pts.length) return null;
      const lambda=curveLambda;
      let sumX=0; pts.forEach(p=>sumX+=p.x);
      const cx=sumX/pts.length;
      return pts.map(p=>({ x: cx + lambda*(p.x-cx), y:p.y }));
    }

    function drawManualPointOverlay(ctx,session){
      if(!session.manualPoints||session.manualPoints.length===0) return;
      ctx.save();
      ctx.strokeStyle="rgba(251,191,36,0.9)";
      ctx.lineWidth=2;
      ctx.fillStyle="rgba(251,191,36,0.95)";
      const pts=session.manualPoints;
      if(pts.length>=2){
        ctx.beginPath();
        pts.forEach((p,idx)=>{ if(idx===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
        ctx.stroke();
      }
      for(const p of pts){ ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
    }

    function drawSpineAndHeadCentering(ctx,session){
      if(!toggleSpine.checked){ drawManualPointOverlay(ctx,session); return; }
      const kp=session.keypointsCanonical;
      if(!kp){ drawManualPointOverlay(ctx,session); return; }
      ctx.save();
      const emphasised=emphasizedSpinePoints(session);
      const ca=session.curveAnalysis;
      const isNoise=ca && ca.curveIsNoise;

      if(emphasised && emphasised.length>=2){
        ctx.lineWidth=3;
        if(isNoise){
          ctx.strokeStyle="rgba(148,163,184,0.6)";
          ctx.setLineDash([5,4]);
        } else {
          ctx.strokeStyle="rgba(56,189,248,0.95)";
          ctx.setLineDash([]);
        }
        ctx.beginPath();
        emphasised.forEach((p,idx)=>{ if(idx===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle=isNoise ? "rgba(148,163,184,0.7)" : "rgba(56,189,248,0.85)";
        for(let i=0;i<emphasised.length;i+=3){
          const p=emphasised[i];
          ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill();
        }
      }

      const pelvis=kp.pelvisCenter;
      const head=kp.headCenter;

      if(pelvis){
        ctx.setLineDash([6,4]);
        ctx.lineWidth=1.5;
        ctx.strokeStyle="rgba(148,163,184,0.7)";
        ctx.beginPath(); ctx.moveTo(pelvis.x,pelvis.y-350); ctx.lineTo(pelvis.x,pelvis.y+30); ctx.stroke();
        ctx.setLineDash([]);
      }
      if(head && kp.sternum){
        ctx.strokeStyle="rgba(248,250,252,0.9)";
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(head.x,head.y); ctx.lineTo(kp.sternum.x,kp.sternum.y); ctx.stroke();
      }
      if(pelvis && head){
        const dx=head.x-pelvis.x;
        ctx.fillStyle="rgba(248,250,252,0.95)";
        ctx.font="12px system-ui";
        ctx.fillText(`offset testa/bacino ‚âà ${dx.toFixed(1)} px`, pelvis.x+12, pelvis.y-12);
      }
      ctx.restore();
      drawManualPointOverlay(ctx,session);
    }

    function drawVectorField(ctx, baseline, current){
      if(!toggleVectors.checked||!baseline||!current) return;
      ctx.save();
      ctx.lineWidth=2;
      ctx.strokeStyle="rgba(52,211,153,0.95)";
      ctx.fillStyle="rgba(52,211,153,0.95)";
      const keys=["headCenter","neckBase","shoulderMid","leftShoulder","rightShoulder","leftHip","rightHip","pelvisCenter"];
      for(const k of keys){
        const b=baseline[k], c=current[k]; if(!b||!c) continue;
        const dx=(c.x-b.x), dy=(c.y-b.y);
        const len=Math.hypot(dx,dy);
        if(len<1) continue;
        const x0=b.x,y0=b.y,x1=x0+dx,y1=y0+dy;
        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
        const angle=Math.atan2(dy,dx);
        const ah=7;
        const leftX=x1-ah*Math.cos(angle-Math.PI/6);
        const leftY=y1-ah*Math.sin(angle-Math.PI/6);
        const rightX=x1-ah*Math.cos(angle+Math.PI/6);
        const rightY=y1-ah*Math.sin(angle+Math.PI/6);
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(leftX,leftY); ctx.lineTo(rightX,rightY); ctx.closePath(); ctx.fill();
      }
      ctx.restore();
    }

    function updateMetricRow(session){
      if(!session||!session.metrics){ metricRow.innerHTML=""; return; }
      const m=session.metrics;
      const fmt=(v)=> (v==null||Number.isNaN(v)) ? "‚Äî" : Number(v).toFixed(2);
      const vType=getEffectiveViewType(session);
      const sourceLabel=session.spineSource==="manual"?"manuale":session.spineSource==="learned"?"appresa":"automatica";
      metricRow.innerHTML = `
        <div><strong>Vista:</strong> ${vType}</div>
        <div><strong>Sorgente colonna:</strong> ${sourceLabel}</div>
        <div><strong>Categoria curva:</strong> ${m.curveCategory || "‚Äî"}</div>
        <div><strong>Dev. max curva (norm.):</strong> ${fmt(m.curveMaxDeviationNorm)} u.n.</div>
        <div><strong>Tilt spalle:</strong> ${fmt(m.shoulderTiltDeg)}¬∞</div>
        <div><strong>Tilt bacino:</strong> ${fmt(m.pelvisTiltDeg)}¬∞</div>
        <div><strong>Tilt testa (vs verticale):</strong> ${fmt(m.headAxisDeg)}¬∞</div>
        <div><strong>Angolo di Cobb:</strong> ${fmt(m.cobbAngleDeg)}¬∞</div>
        <div><strong>Offset testa/bacino:</strong> ${fmt(m.headPelvisOffsetNorm)} u.n.</div>
        <div><strong>Offset testa/sterno:</strong> ${fmt(m.headSternumOffsetNorm)} u.n.</div>
        <div><strong>Rot. bacino (depth):</strong> ${fmt(m.pelvisDepthRotDiff)} Œîu</div>
        <div><strong>Lunghezza tronco:</strong> ${fmt(m.torsoLengthPx)} px</div>
      `;
    }

    function highlightFileItem(index){
      const items=fileListEl.querySelectorAll(".file-item");
      items.forEach(el=>el.classList.remove("active"));
      const active=fileListEl.querySelector(`.file-item[data-idx="${index}"]`);
      if(active) active.classList.add("active");
    }

    function renderSession(index){
      const session=sessions[index];
      if(!session || !session.keypointsCanonical || !session.transform) { updateNavUI(); return; }
      if(manualMode && session.keypointsCanonical) ensureManualControlPoints(session);

      mainCtx.clearRect(0,0,mainCanvas.width,mainCanvas.height);
      drawImageWithTransform(mainCtx, session.img, session.transform);

      const vType=getEffectiveViewType(session);
      drawSkeleton(mainCtx, session.keypointsCanonical, vType);
      drawSpineAndHeadCentering(mainCtx, session);

      const baseline=sessions[0];
      if(baseline && baseline.keypointsCanonical && index>0){
        drawVectorField(mainCtx, baseline.keypointsCanonical, session.keypointsCanonical);
      }

      updateMetricRow(session);
      highlightFileItem(index);
      updateNavUI();
    }

    // Charts theme helpers
    function chartTheme(){
      const dark = (document.documentElement.getAttribute("data-theme")||"dark")==="dark";
      return {
        tick: dark ? "#9aa4b2" : "#64748b",
        grid: dark ? "rgba(148,163,184,0.22)" : "rgba(15,23,42,0.10)",
        legend: dark ? "#e5e7eb" : "#0f172a"
      };
    }

    function updateCharts(){
      if(!sessions.length) return;
      const labels=sessions.map((s,i)=>`${i+1}`);

      const shoulders=sessions.map(s=>s.metrics?.shoulderTiltDeg ?? null);
      const pelvis=sessions.map(s=>s.metrics?.pelvisTiltDeg ?? null);
      const headAxis=sessions.map(s=>s.metrics?.headAxisDeg ?? null);
      const cobb=sessions.map(s=>s.metrics?.cobbAngleDeg ?? null);

      const headPelvis=sessions.map(s=>s.metrics?.headPelvisOffsetNorm ?? null);
      const headSternum=sessions.map(s=>s.metrics?.headSternumOffsetNorm ?? null);

      const th=chartTheme();

      const anglesCtx=document.getElementById("chartAngles").getContext("2d");
      if(!anglesChart){
        anglesChart = new Chart(anglesCtx,{
          type:"line",
          data:{ labels, datasets:[
            { label:"Tilt spalle (¬∞)", data:shoulders, tension:0.3 },
            { label:"Tilt bacino (¬∞)", data:pelvis, tension:0.3 },
            { label:"Tilt testa vs verticale (¬∞)", data:headAxis, tension:0.3 },
            { label:"Cobb (¬∞)", data:cobb, tension:0.3 }
          ]},
          options:{
            responsive:true,
            plugins:{ legend:{ labels:{ color: th.legend, font:{ size: 10 } } } },
            scales:{
              x:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } },
              y:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } }
            }
          }
        });
      } else {
        anglesChart.data.labels=labels;
        anglesChart.data.datasets[0].data=shoulders;
        anglesChart.data.datasets[1].data=pelvis;
        anglesChart.data.datasets[2].data=headAxis;
        anglesChart.data.datasets[3].data=cobb;
        anglesChart.options.plugins.legend.labels.color=th.legend;
        anglesChart.options.scales.x.ticks.color=th.tick;
        anglesChart.options.scales.y.ticks.color=th.tick;
        anglesChart.options.scales.x.grid.color=th.grid;
        anglesChart.options.scales.y.grid.color=th.grid;
        anglesChart.update();
      }

      const offsetsCtx=document.getElementById("chartOffsets").getContext("2d");
      if(!offsetsChart){
        offsetsChart = new Chart(offsetsCtx,{
          type:"line",
          data:{ labels, datasets:[
            { label:"Offset testa/bacino (norm.)", data:headPelvis, tension:0.3 },
            { label:"Offset testa/sterno (norm.)", data:headSternum, tension:0.3 }
          ]},
          options:{
            responsive:true,
            plugins:{ legend:{ labels:{ color: th.legend, font:{ size: 10 } } } },
            scales:{
              x:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } },
              y:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } }
            }
          }
        });
      } else {
        offsetsChart.data.labels=labels;
        offsetsChart.data.datasets[0].data=headPelvis;
        offsetsChart.data.datasets[1].data=headSternum;
        offsetsChart.options.plugins.legend.labels.color=th.legend;
        offsetsChart.options.scales.x.ticks.color=th.tick;
        offsetsChart.options.scales.y.ticks.color=th.tick;
        offsetsChart.options.scales.x.grid.color=th.grid;
        offsetsChart.options.scales.y.grid.color=th.grid;
        offsetsChart.update();
      }
    }

    function updateModelChart(){
      const canvas=document.getElementById("chartModel");
      if(!canvas) return;
      const ctx=canvas.getContext("2d");
      const labels=modelErrorHistory.map((_,i)=>`${i+1}`);
      const data=modelErrorHistory;
      const th=chartTheme();

      if(!modelChart){
        modelChart=new Chart(ctx,{
          type:"line",
          data:{ labels, datasets:[{ label:"Errore medio offset (RMSE)", data, tension:0.3 }] },
          options:{
            responsive:true,
            plugins:{ legend:{ labels:{ color: th.legend, font:{ size: 10 } } } },
            scales:{
              x:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } },
              y:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } }
            }
          }
        });
      } else {
        modelChart.data.labels=labels;
        modelChart.data.datasets[0].data=data;
        modelChart.options.plugins.legend.labels.color=th.legend;
        modelChart.options.scales.x.ticks.color=th.tick;
        modelChart.options.scales.y.ticks.color=th.tick;
        modelChart.options.scales.x.grid.color=th.grid;
        modelChart.options.scales.y.grid.color=th.grid;
        modelChart.update();
      }
      updateNavUI();
    }

    // Training/model helpers (come tuo, invariati dove possibile)
    function evaluateModelOnce(examples){
      if(examples.length<2) return 0;
      const errors=[], kBase=3;
      for(let i=0;i<examples.length;i++){
        const ex=examples[i];
        const feat=ex.features;
        const trueOffsets=ex.offsets;
        const distArr=[];
        for(let j=0;j<examples.length;j++){
          if(j===i) continue;
          const ex2=examples[j];
          const f2=ex2.features;
          let s=0;
          const len=Math.min(feat.length,f2.length);
          for(let t=0;t<len;t++){ const d=(feat[t]||0)-(f2[t]||0); s+=d*d; }
          distArr.push({idx:j, dist:Math.sqrt(s)});
        }
        if(!distArr.length) continue;
        distArr.sort((a,b)=>a.dist-b.dist);
        const k=Math.min(kBase, distArr.length);
        const neighbors=distArr.slice(0,k);
        const weights=neighbors.map(n=>1/(n.dist+1e-6));
        const sumW=weights.reduce((s,w)=>s+w,0)||1;
        const predOffsets=new Array(SPINE_SAMPLES).fill(0);
        for(let j=0;j<SPINE_SAMPLES;j++){
          let num=0;
          for(let t=0;t<k;t++){
            const ex2=examples[neighbors[t].idx];
            const w=weights[t];
            num += (ex2.offsets[j]||0)*w;
          }
          predOffsets[j]=num/sumW;
        }
        let seSum=0,count=0;
        for(let j=0;j<SPINE_SAMPLES;j++){
          const diff=(predOffsets[j]||0)-(trueOffsets[j]||0);
          seSum+=diff*diff; count++;
        }
        if(count>0) errors.push(Math.sqrt(seSum/count));
      }
      if(!errors.length) return 0;
      return errors.reduce((s,e)=>s+e,0)/errors.length;
    }

    function recomputeModelErrorHistory(){
      modelErrorHistory=[];
      for(let n=1;n<=trainingExamples.length;n++){
        const subset=trainingExamples.slice(0,n);
        modelErrorHistory.push(evaluateModelOnce(subset));
      }
      updateModelChart();
    }

    function computeFeatureVector(session){
      const m=session.metrics||{};
      const v=[ m.shoulderTiltDeg||0, m.pelvisTiltDeg||0, m.headAxisDeg||0, m.headPelvisOffsetNorm||0, m.headSternumOffsetNorm||0, m.pelvisDepthRotDiff||0 ];
      return v.map(x => (x==null||Number.isNaN(x)) ? 0 : x);
    }

    function saveTrainingExamples(){
      try{ localStorage.setItem("scoliosisTraining_v2", JSON.stringify(trainingExamples)); }catch(e){}
    }
    function loadTrainingExamples(){
      try{
        const raw=localStorage.getItem("scoliosisTraining_v2");
        if(!raw) return;
        const arr=JSON.parse(raw);
        if(Array.isArray(arr)){
          trainingExamples=arr.filter(ex=>Array.isArray(ex.features)&&Array.isArray(ex.offsets)&&ex.offsets.length===SPINE_SAMPLES);
          if(trainingExamples.length) recomputeModelErrorHistory();
        }
      }catch(e){}
      updateNavUI();
    }

    function predictOffsetsFromModel(session){
      if(!trainingExamples.length) return null;
      const feat=computeFeatureVector(session);
      const k=Math.min(3,trainingExamples.length);
      const distArr=trainingExamples.map((ex,idx)=>{
        const f=ex.features||[];
        const len=Math.min(f.length, feat.length);
        let s=0;
        for(let i=0;i<len;i++){ const d=(feat[i]||0)-(f[i]||0); s+=d*d; }
        return { idx, dist:Math.sqrt(s) };
      });
      distArr.sort((a,b)=>a.dist-b.dist);
      const neighbors=distArr.slice(0,k);
      const weights=neighbors.map(n=>1/(n.dist+1e-6));
      const sumW=weights.reduce((s,w)=>s+w,0)||1;
      const offsets=new Array(SPINE_SAMPLES).fill(0);
      for(let j=0;j<SPINE_SAMPLES;j++){
        let num=0;
        for(let t=0;t<neighbors.length;t++){
          const ex=trainingExamples[neighbors[t].idx];
          const w=weights[t];
          num += (ex.offsets[j]||0)*w;
        }
        offsets[j]=num/sumW;
      }
      return offsets;
    }

    function applyOffsetsToSessionSpine(session, offsets){
      const kpC=session.keypointsCanonical;
      if(!kpC||!kpC.pelvisCenter) return;
      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid||pelvisC;
      const torsoVec={x:headC.x-pelvisC.x,y:headC.y-pelvisC.y};
      const torsoLenC=Math.hypot(torsoVec.x,torsoVec.y)||1;
      const nx=-torsoVec.y/torsoLenC, ny=torsoVec.x/torsoLenC;
      const pts=[];
      for(let i=0;i<SPINE_SAMPLES;i++){
        const hi=i/(SPINE_SAMPLES-1);
        const off=offsets[i]||0;
        const baseX=pelvisC.x+torsoVec.x*hi;
        const baseY=pelvisC.y+torsoVec.y*hi;
        pts.push({ x: baseX + nx*off*torsoLenC, y: baseY + ny*off*torsoLenC });
      }
      session.spineSpline=pts;
      session.spineSource="learned";
    }

    function rebuildSpineFromControlPoints(session){
      if(!session.manualPoints||session.manualPoints.length===0) return;
      const kpC=session.keypointsCanonical;
      if(!kpC||!kpC.pelvisCenter) return;
      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid||pelvisC;
      const torsoVec={x:headC.x-pelvisC.x,y:headC.y-pelvisC.y};
      const torsoLenC=Math.hypot(torsoVec.x,torsoVec.y)||1;
      const nx=-torsoVec.y/torsoLenC, ny=torsoVec.x/torsoLenC;
      const ctrlSamples=[];
      const nCtrl=session.manualPoints.length;
      for(let i=0;i<nCtrl;i++){
        const hi=i/(nCtrl-1);
        const baseX=pelvisC.x+torsoVec.x*hi;
        const baseY=pelvisC.y+torsoVec.y*hi;
        const p=session.manualPoints[i];
        const off=(p.x-baseX)/torsoLenC;
        ctrlSamples.push({hi,off});
      }
      ctrlSamples.sort((a,b)=>a.hi-b.hi);
      const hiGrid=[]; for(let i=0;i<SPINE_SAMPLES;i++) hiGrid.push(i/(SPINE_SAMPLES-1));
      const offsets=[]; let idx=0;
      for(const hg of hiGrid){
        while(idx<ctrlSamples.length-1 && ctrlSamples[idx+1].hi<hg) idx++;
        if(idx===ctrlSamples.length-1) offsets.push(ctrlSamples[ctrlSamples.length-1].off);
        else{
          const d0=ctrlSamples[idx], d1=ctrlSamples[idx+1];
          const t=(d1.hi===d0.hi) ? 0 : (hg-d0.hi)/(d1.hi-d0.hi);
          offsets.push(d0.off + (d1.off-d0.off)*t);
        }
      }
      const spinePts=[];
      for(let i=0;i<SPINE_SAMPLES;i++){
        const hi=hiGrid[i], off=offsets[i];
        const baseX=pelvisC.x+torsoVec.x*hi;
        const baseY=pelvisC.y+torsoVec.y*hi;
        spinePts.push({ x: baseX + nx*off*torsoLenC, y: baseY + ny*off*torsoLenC });
      }
      session.spineSpline=spinePts;
      session.manualOffsets=offsets;
      session.spineSource="manual";
      if(session.metrics) postProcessCurveMetrics(session);

      // snap points
      session.manualPoints=session.manualPoints.map((p,i)=>{
        const hi=i/(nCtrl-1);
        const baseX=pelvisC.x+torsoVec.x*hi;
        const baseY=pelvisC.y+torsoVec.y*hi;
        const off=ctrlSamples[i].off;
        return { x: baseX + nx*off*torsoLenC, y: baseY + ny*off*torsoLenC };
      });
    }

    function ensureManualControlPoints(session){
      if(!session.keypointsCanonical||!session.keypointsCanonical.pelvisCenter) return;
      if(session.manualPoints && session.manualPoints.length===CONTROL_POINTS) return;
      const kpC=session.keypointsCanonical;
      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid||pelvisC;
      const torsoVec={x:headC.x-pelvisC.x,y:headC.y-pelvisC.y};
      const spine=session.spineSpline;
      session.manualPoints=[];
      for(let i=0;i<CONTROL_POINTS;i++){
        const hi=i/(CONTROL_POINTS-1);
        let pInit=null;
        if(spine && spine.length>=2){
          const idx=Math.round(hi*(spine.length-1));
          pInit=spine[idx];
        }
        if(!pInit){
          const baseX=pelvisC.x+torsoVec.x*hi;
          const baseY=pelvisC.y+torsoVec.y*hi;
          pInit={x:baseX,y:baseY};
        }
        session.manualPoints.push({x:pInit.x,y:pInit.y});
      }
      rebuildSpineFromControlPoints(session);
    }

    function saveManualExampleCurrentSession(){
      const s=sessions[currentIndex];
      if(!s||!s.manualOffsets||!s.metrics){
        setStatus("Per salvare un esempio: attiva punti manuali e modifica almeno un punto.", true);
        return;
      }
      trainingExamples.push({ features: computeFeatureVector(s), offsets: s.manualOffsets.slice() });
      saveTrainingExamples();
      recomputeModelErrorHistory();
      setStatus(`Esempio manuale salvato. Totale esempi: ${trainingExamples.length}.`, false);
      reapplyLearnedModelToAllSessions();
    }

    function reapplyLearnedModelToAllSessions(){
      if(!sessions.length) return;
      if(!enableLearning.checked || trainingExamples.length < 3) return;
      for(const s of sessions){
        if(!s.metrics||!s.keypointsCanonical) continue;
        if(s.spineSource==="manual") continue;
        const offsets=predictOffsetsFromModel(s);
        if(!offsets) continue;
        applyOffsetsToSessionSpine(s, offsets);
        const pelvisTilt=s.metrics.pelvisTiltDeg;
        const headAxis=s.metrics.headAxisDeg;
        const cobbAngle=estimateCobbAngle(pelvisTilt, headAxis, s.spineSpline);
        s.metrics.cobbAngleDeg = cobbAngle ?? null;
        postProcessCurveMetrics(s);
      }
      updateCharts();
      buildTechnicalReport();
      renderSession(currentIndex);
      setStatus("Modello riapplicato a tutte le immagini.", false);
    }

    function recomputeSpineForSession(session){
      if(!session||!session.keypointsCanonical||!session.metrics) return;
      if(session.spineSource==="manual"){ renderSession(currentIndex); return; }
      const vType=getEffectiveViewType(session);
      const spineC=estimateSpineCanonical(session.keypointsCanonical, vType);
      session.spineCanonical=spineC;
      session.spineSource="auto";
      session.spineSpline = spineC ? computeSpineSpline(spineC.basePoints, SPINE_SAMPLES).points : null;
      const pelvisTilt=session.metrics.pelvisTiltDeg;
      const headAxis=session.metrics.headAxisDeg;
      const cobbAngle=estimateCobbAngle(pelvisTilt, headAxis, session.spineSpline);
      session.metrics.cobbAngleDeg=cobbAngle ?? null;
      postProcessCurveMetrics(session);
    }

    async function estimateDepthMap(session){
      if(!depthEstimator || !depthReady) return null;
      try{
        const depthNS = globalThis.depthEstimation || window.depthEstimation;
        if(!depthNS) return null;
        const estimationConfig={ minDepth:0.2, maxDepth:0.9, flipHorizontal:false };
        const depthMap = await depthEstimator.estimateDepth(session.img, estimationConfig);
        return await depthMap.toArray();
      }catch(err){ return null; }
    }
    function sampleDepthAtImagePoint(depthMap,img,pt,radius=2){
      if(!depthMap||!pt) return null;
      const h=depthMap.length, w=depthMap[0].length;
      const xNorm=pt.x/img.naturalWidth, yNorm=pt.y/img.naturalHeight;
      const cx=Math.round(xNorm*(w-1)), cy=Math.round(yNorm*(h-1));
      let sum=0,count=0;
      for(let j=-radius;j<=radius;j++){
        for(let i=-radius;i<=radius;i++){
          const xx=cx+i, yy=cy+j;
          if(xx<0||xx>=w||yy<0||yy>=h) continue;
          sum+=depthMap[yy][xx]; count++;
        }
      }
      return count? (sum/count) : null;
    }
    function computePelvisDepthRotationDiff(session){
      if(!session.depthMap||!session.keypoints2D) return null;
      const dL=sampleDepthAtImagePoint(session.depthMap, session.img, session.keypoints2D.leftHip, 3);
      const dR=sampleDepthAtImagePoint(session.depthMap, session.img, session.keypoints2D.rightHip, 3);
      if(dL==null||dR==null) return null;
      return dR - dL;
    }

    // Report (arricchito con paziente + date/note)
    function describeTowardZero(name, baseline, last, unit, threshold){
      if(baseline==null||last==null||!Number.isFinite(baseline)||!Number.isFinite(last)) return null;
      const abs0=Math.abs(baseline), abs1=Math.abs(last);
      const deltaAbs=abs1-abs0;
      if(Math.abs(deltaAbs)<threshold) return `‚Ä¢ ${name}: variazione minima (da ${baseline.toFixed(2)}${unit} a ${last.toFixed(2)}${unit}).`;
      if(deltaAbs<0) return `‚Ä¢ ${name}: <strong>miglioramento</strong> (da ${baseline.toFixed(2)}${unit} a ${last.toFixed(2)}${unit}).`;
      return `‚Ä¢ ${name}: <strong>peggioramento</strong> (da ${baseline.toFixed(2)}${unit} a ${last.toFixed(2)}${unit}).`;
    }

    function buildTechnicalReport(){
      if(!sessions.length || !sessions[0].metrics){
        reportPanel.innerHTML = `<h3 style="margin:0 0 6px;">Report tecnico automatico</h3><p style="margin:0;color:var(--muted);font-weight:700;">Analizza le immagini per generare il report.</p>`;
        return;
      }
      if(sessions.length<2){
        reportPanel.innerHTML = `<h3 style="margin:0 0 6px;">Report tecnico automatico</h3><p style="margin:0;color:var(--muted);font-weight:700;">Servono almeno due sessioni per confrontare l‚Äôevoluzione.</p>`;
        return;
      }

      const patient=readPatient();
      const first=sessions[0], last=sessions[sessions.length-1];
      const m0=first.metrics, m1=last.metrics;
      const items=[];
      const cat0=m0.curveCategory||"non valutabile";
      const cat1=m1.curveCategory||"non valutabile";
      items.push(`‚Ä¢ Classificazione curva (inizio ‚Üí fine): <strong>${cat0}</strong> ‚Üí <strong>${cat1}</strong>.`);

      const sShoulders=describeTowardZero("Inclinazione spalle", m0.shoulderTiltDeg, m1.shoulderTiltDeg, "¬∞", 1); if(sShoulders) items.push(sShoulders);
      const sPelvis=describeTowardZero("Inclinazione bacino", m0.pelvisTiltDeg, m1.pelvisTiltDeg, "¬∞", 1); if(sPelvis) items.push(sPelvis);
      const sHead=describeTowardZero("Tilt testa vs verticale", m0.headAxisDeg, m1.headAxisDeg, "¬∞", 1); if(sHead) items.push(sHead);
      const sCobb=describeTowardZero("Cobb (stima)", m0.cobbAngleDeg, m1.cobbAngleDeg, "¬∞", 1); if(sCobb) items.push(sCobb);
      const sHP=describeTowardZero("Centratura testa/bacino", m0.headPelvisOffsetNorm, m1.headPelvisOffsetNorm, "", 0.02); if(sHP) items.push(sHP);
      const sHS=describeTowardZero("Centratura testa/sterno", m0.headSternumOffsetNorm, m1.headSternumOffsetNorm, "", 0.02); if(sHS) items.push(sHS);
      const sRot=describeTowardZero("Rotazione bacino (depth)", m0.pelvisDepthRotDiff, m1.pelvisDepthRotDiff, "", 0.02); if(sRot) items.push(sRot);

      const metaLine = (s)=> {
        const parts=[];
        if(s.dateISO) parts.push(s.dateISO);
        if(s.note) parts.push(s.note);
        return parts.length ? ` <span style="color:var(--muted);font-weight:700;">(${parts.join(" ‚Ä¢ ")})</span>` : "";
      };

      reportPanel.innerHTML = `
        <h3 style="margin:0 0 6px;">Report tecnico automatico</h3>
        <div style="color:var(--muted);font-weight:800;line-height:1.35;">
          <div><strong>Paziente:</strong> ${patient.id ? patient.id + " ‚Ä¢ " : ""}${patient.name || "‚Äî"} ${patient.dob ? "‚Ä¢ " + patient.dob : ""} ${patient.sex ? "‚Ä¢ " + patient.sex : ""}</div>
          ${patient.note ? `<div><strong>Nota:</strong> ${patient.note}</div>` : ""}
          <div style="margin-top:6px;"><strong>Baseline:</strong> ${first.fileName}${metaLine(first)}</div>
          <div><strong>Ultima:</strong> ${last.fileName}${metaLine(last)}</div>
        </div>
        <ul style="margin:10px 0 0;padding-left:18px;color:var(--muted);font-weight:700;line-height:1.35;">
          ${items.map(t=>`<li>${t}</li>`).join("")}
        </ul>
        <p style="margin:10px 0 0;color:var(--muted);font-weight:700;line-height:1.35;">
          <em>Nota clinica:</em> Cobb e curve sono stime su foto. Gli angoli sono normalizzati in ¬±90¬∞.
          Il training usa esempi manuali per migliorare la ricostruzione delle curve su casi simili.
        </p>
      `;
    }

    // File list UI (thumbnail + data + note + view override + delete confirm)
    function rebuildFileList(){
      fileListEl.innerHTML="";
      updateNavUI();
      sessions.forEach((s,idx)=>{
        const row=document.createElement("div");
        row.className="file-item";
        row.dataset.idx=String(idx);
        const autoLabel = (s.viewTypeAuto && s.viewTypeAuto!=="non determinata") ? `Auto (${s.viewTypeAuto})` : "Auto (?)";

        row.innerHTML = `
          <div class="thumb" style="background-image:url('${s.objectUrl || ""}')"></div>
          <div class="file-main">
            <div class="file-name" title="${s.fileName}">${idx+1}. ${s.fileName}</div>
            <div class="file-meta">
              <span class="chip">${autoLabel}</span>
              <input id="date_${idx}" type="date" value="${s.dateISO||""}" style="height:32px;padding:.3rem .5rem;" />
              <select class="view-select" style="height:32px;">
                <option value="auto">Auto</option>
                <option value="frontale">Frontale</option>
                <option value="posteriore">Posteriore</option>
                <option value="laterale">Laterale</option>
              </select>
            </div>
            <div class="file-meta" style="margin-top:2px;">
              <input id="note_${idx}" placeholder="Nota (opz.)" value="${(s.note||"").replaceAll('"',"&quot;")}"
                     style="width:100%;min-width:180px;height:32px;padding:.3rem .5rem;" />
            </div>
          </div>
          <div class="file-controls">
            <div class="mini-row">
              <button class="mini-btn up" title="Sposta su">‚Üë</button>
              <button class="mini-btn down" title="Sposta gi√π">‚Üì</button>
            </div>
            <button class="mini-btn mini-danger del" title="Rimuovi">‚úï</button>
          </div>
        `;

        row.addEventListener("click",(ev)=>{
          const t=ev.target;
          if(t.matches("button, select, input")) return;
          currentIndex=idx;
          renderSession(currentIndex);
        });

        fileListEl.appendChild(row);

        const upBtn=row.querySelector(".up");
        const downBtn=row.querySelector(".down");
        const delBtn=row.querySelector(".del");
        const viewSelect=row.querySelector(".view-select");
        const dateInput=row.querySelector(`#date_${idx}`);
        const noteInput=row.querySelector(`#note_${idx}`);

        // view select
        viewSelect.options[0].textContent = autoLabel;
        viewSelect.value = s.viewTypeOverride ? s.viewTypeOverride : "auto";
        viewSelect.title = `Vista riconosciuta: ${s.viewTypeAuto||"non determinata"}`;

        upBtn.addEventListener("click",(e)=>{ e.stopPropagation(); moveSession(idx,-1); });
        downBtn.addEventListener("click",(e)=>{ e.stopPropagation(); moveSession(idx, 1); });

        delBtn.addEventListener("click", async (e)=>{
          e.stopPropagation();
          const ok=await confirmAsync(`Rimuovere ‚Äú${s.fileName}‚Äù?`);
          if(!ok) return;
          removeSession(idx);
        });

        viewSelect.addEventListener("click",(e)=>e.stopPropagation());
        viewSelect.addEventListener("change",(e)=>{
          const val=e.target.value;
          if(val==="auto") s.viewTypeOverride=null;
          else s.viewTypeOverride=val;
          setStatus(`Vista per ${s.fileName}: ${getEffectiveViewType(s)}.`, false);
          if(s.keypointsCanonical && s.metrics){
            recomputeSpineForSession(s);
            updateCharts();
            buildTechnicalReport();
            renderSession(currentIndex);
          }
        });

        dateInput.addEventListener("click",(e)=>e.stopPropagation());
        dateInput.addEventListener("change",()=>{
          s.dateISO = dateInput.value || "";
          saveSessionsMeta();
          buildTechnicalReport();
        });
        noteInput.addEventListener("click",(e)=>e.stopPropagation());
        noteInput.addEventListener("input",()=>{
          s.note = noteInput.value || "";
          saveSessionsMeta();
        });
      });
      highlightFileItem(currentIndex);
      updateNavUI();
    }

    function saveSessionsMeta(){
      try{
        localStorage.setItem("scoliosisSessionsMeta_v2", JSON.stringify(sessions.map(x=>({fileName:x.fileName,dateISO:x.dateISO||"",note:x.note||""}))));
      }catch{}
    }
    function loadSessionsMeta(){
      try{
        const raw=localStorage.getItem("scoliosisSessionsMeta_v2");
        if(!raw) return new Map();
        const arr=JSON.parse(raw);
        const m=new Map();
        if(Array.isArray(arr)){
          for(const it of arr){
            if(it && it.fileName) m.set(it.fileName, { dateISO: it.dateISO||"", note: it.note||"" });
          }
        }
        return m;
      }catch{ return new Map(); }
    }

    function moveSession(oldIndex, delta){
      const newIndex=oldIndex+delta;
      if(newIndex<0||newIndex>=sessions.length) return;
      const [item]=sessions.splice(oldIndex,1);
      sessions.splice(newIndex,0,item);
      sessions.forEach((s,i)=>s.index=i);
      currentIndex=newIndex;
      rebuildFileList();
      updateCharts();
      renderSession(currentIndex);
      saveSessionsMeta();
    }

    function removeSession(idx){
      if(idx<0||idx>=sessions.length) return;
      const s=sessions[idx];
      if(s?.objectUrl) URL.revokeObjectURL(s.objectUrl);
      sessions.splice(idx,1);
      if(!sessions.length){
        currentIndex=0;
        mainCtx.clearRect(0,0,mainCanvas.width,mainCanvas.height);
        metricRow.innerHTML="";
        reportPanel.innerHTML=`<h3 style="margin:0 0 6px;">Report tecnico automatico</h3><p style="margin:0;color:var(--muted);font-weight:700;">Analizza le immagini per generare il report.</p>`;
      }else{
        if(currentIndex>=sessions.length) currentIndex=sessions.length-1;
      }
      sessions.forEach((s,i)=>s.index=i);
      rebuildFileList();
      updateCharts();
      buildTechnicalReport();
      if(sessions.length) renderSession(currentIndex);
      updateAnalyzeButton();
      setStatus(sessions.length ? "Foto rimossa." : "Tutte le foto rimosse.", false);
      saveSessionsMeta();
    }

    function updateAnalyzeButton(){
      analyzeBtn.disabled = !(modelReady && imagesReady && sessions.length>0);
    }

    // Load image with object URL (fix memory leaks)
    function loadImageFile(file){
      return new Promise((resolve,reject)=>{
        const img=new Image();
        const url=URL.createObjectURL(file);
        img.onload=()=>resolve({ file, img, url });
        img.onerror=(e)=>{ URL.revokeObjectURL(url); reject(e); };
        img.src=url;
      });
    }

    // Core analyze
    async function analyzeAllSessions(){
      if(!poseLandmarker || !sessions.length) return;
      analyzeBtn.disabled=true;
      setStatus("Analisi in corso...", false);
      showBusy("Analisi immagini in corso...",0);

      for(let i=0;i<sessions.length;i++){
        const s=sessions[i];
        try{
          const result=poseLandmarker.detect(s.img);
          if(!result||!result.landmarks||!result.landmarks.length) continue;
          const landmarks=result.landmarks[0];
          s.landmarks=landmarks;

          const kp=extractKeypoints(landmarks, s.img.naturalWidth, s.img.naturalHeight);
          s.keypoints2D=kp;

          s.viewTypeAuto=detectPoseOrientation(landmarks,kp);
          s.viewType=s.viewTypeAuto;

          const transform=computeAlignmentTransform(kp,s.img);
          s.transform=transform;

          const kpC={};
          Object.keys(kp).forEach((k)=>{ if(!kp[k]) return; kpC[k]=transformPoint(kp[k],transform); });

          const repere=computeDetailedCanonicalRepere(kpC);
          kpC.ribsLeft=repere.ribsLeft; kpC.ribsRight=repere.ribsRight; kpC.ribsMid=repere.ribsMid;
          kpC.sternum=repere.sternum; kpC.clavSegments=repere.clavSegments; kpC.scmSegments=repere.scmSegments;

          s.keypointsCanonical=kpC;

          const spineC=estimateSpineCanonical(kpC, s.viewTypeAuto);
          s.spineCanonical=spineC;
          s.spineSource="auto";
          s.spineSpline = spineC ? computeSpineSpline(spineC.basePoints, SPINE_SAMPLES).points : null;

          s.depthMap = await estimateDepthMap(s);

          const shoulderTilt=angleOfLineDeg(kp.leftShoulder,kp.rightShoulder);
          const pelvisTilt=angleOfLineDeg(kp.leftHip,kp.rightHip);

          let headAxisDeg=null;
          if(kp.headCenter && (kp.neckBase||kp.shoulderMid)){
            headAxisDeg=headTiltRelativeVerticalDeg(kp.headCenter, kp.neckBase||kp.shoulderMid);
          }

          const torsoLength=distance(kp.neckBase||kp.shoulderMid, kp.pelvisCenter);
          const headPelvisOffset = (kp.headCenter && kp.pelvisCenter) ? kp.headCenter.x-kp.pelvisCenter.x : null;
          const headSternumOffset = (kp.headCenter && kp.shoulderMid) ? kp.headCenter.x-kp.shoulderMid.x : null;

          const pelvisDepthRotDiff=computePelvisDepthRotationDiff(s);

          if(s.manualPoints && s.manualPoints.length===CONTROL_POINTS){
            rebuildSpineFromControlPoints(s);
          }else if(enableLearning.checked && trainingExamples.length>=3){
            const learnedOffsets=predictOffsetsFromModel(s);
            if(learnedOffsets) applyOffsetsToSessionSpine(s, learnedOffsets);
          }

          const cobbAngle=estimateCobbAngle(pelvisTilt, headAxisDeg, s.spineSpline);

          s.metrics={
            shoulderTiltDeg: shoulderTilt,
            pelvisTiltDeg: pelvisTilt,
            headAxisDeg: headAxisDeg,
            cobbAngleDeg: cobbAngle ?? null,
            maxSpineAngleDeg: spineC?.maxAngleLocal ?? null,
            torsoLengthPx: torsoLength || 0,
            headPelvisOffsetNorm: torsoLength && headPelvisOffset!=null ? headPelvisOffset/torsoLength : null,
            headSternumOffsetNorm: torsoLength && headSternumOffset!=null ? headSternumOffset/torsoLength : null,
            pelvisDepthRotDiff: pelvisDepthRotDiff,
            curveMaxDeviationNorm: null,
            curveCategory: "non valutabile"
          };

          postProcessCurveMetrics(s);

          updateBusy(`Analisi foto ${i+1}/${sessions.length}...`, (i+1)/sessions.length);
        }catch(err){
          console.error(err);
          setStatus("Errore durante l'analisi di una o pi√π immagini.", true);
        }
      }

      updateCharts();
      currentIndex=0;
      rebuildFileList();
      renderSession(currentIndex);
      analyzeBtn.disabled=false;
      buildTechnicalReport();
      setTimeout(hideBusy, 250);
      setStatus("Analisi completata.", false);
    }

    // File input change (caricamento immagini + restore metadati)
    fileInput.addEventListener("change", async (e)=>{
      const files=Array.from(e.target.files||[]);
      // cleanup old URLs
      sessions.forEach(s=>{ if(s.objectUrl) URL.revokeObjectURL(s.objectUrl); });

      sessions=[];
      reportPanel.innerHTML = `<h3 style="margin:0 0 6px;">Report tecnico automatico</h3><p style="margin:0;color:var(--muted);font-weight:700;">Analizza le immagini per generare il report.</p>`;

      if(!files.length){
        imagesReady=false; updateAnalyzeButton();
        fileListEl.innerHTML="";
        mainCtx.clearRect(0,0,mainCanvas.width,mainCanvas.height);
        setStatus("Nessun file selezionato.", false);
        updateNavUI();
        return;
      }

      files.sort((a,b)=>a.name.localeCompare(b.name,"it",{numeric:true}));
      setStatus("Carico immagini...", false);

      const metaMap = loadSessionsMeta();

      try{
        const loaded=await Promise.all(files.map(loadImageFile));
        sessions = loaded.map((obj,idx)=>{
          const oldMeta = metaMap.get(obj.file.name);
          return {
            index: idx,
            fileName: obj.file.name,
            img: obj.img,
            objectUrl: obj.url,
            dateISO: oldMeta?.dateISO || inferDateFromFilename(obj.file.name),
            note: oldMeta?.note || "",
            landmarks: null,
            keypoints2D: null,
            keypointsCanonical: null,
            spineCanonical: null,
            spineSpline: null,
            transform: null,
            depthMap: null,
            metrics: null,
            viewTypeAuto: "non determinata",
            viewTypeOverride: null,
            viewType: "non determinata",
            manualPoints: null,
            manualOffsets: null,
            spineSource: "auto"
          };
        });

        imagesReady=true;
        rebuildFileList();
        updateAnalyzeButton();
        setStatus("Immagini caricate. Premi Analizza per procedere.", false);
        updateNavUI();
        saveSessionsMeta();
      }catch(err){
        console.error(err);
        imagesReady=false;
        updateAnalyzeButton();
        setStatus("Errore nel caricamento immagini.", true);
      }
    });

    clearBtn.addEventListener("click", async ()=>{
      if(sessions.length){
        const ok = await confirmAsync("Svuotare tutte le immagini e i risultati correnti?");
        if(!ok) return;
      }
      sessions.forEach(s=>{ if(s.objectUrl) URL.revokeObjectURL(s.objectUrl); });
      fileInput.value="";
      sessions=[];
      imagesReady=false;
      updateAnalyzeButton();
      fileListEl.innerHTML="";
      mainCtx.clearRect(0,0,mainCanvas.width,mainCanvas.height);
      metricRow.innerHTML="";
      reportPanel.innerHTML = `<h3 style="margin:0 0 6px;">Report tecnico automatico</h3><p style="margin:0;color:var(--muted);font-weight:700;">Analizza le immagini per generare il report.</p>`;
      setStatus("Pulito. Carica nuove foto per iniziare.", false);
      updateCharts();
      updateNavUI();
      try{ localStorage.removeItem("scoliosisSessionsMeta_v2"); }catch{}
    });

    analyzeBtn.addEventListener("click",()=>analyzeAllSessions());

    [toggleSkeleton,toggleSpine,toggleVectors].forEach(el=>el.addEventListener("change",()=>renderSession(currentIndex)));

    lambdaSlider.addEventListener("input",()=>{
      curveLambda=parseFloat(lambdaSlider.value);
      lambdaValue.textContent=curveLambda.toFixed(1);
      renderSession(currentIndex);
    });

    toggleManualBtn.addEventListener("click",()=>{
      manualMode=!manualMode;
      if(manualMode){
        lambdaBackup=curveLambda;
        curveLambda=1;
        lambdaSlider.value="1";
        lambdaValue.textContent="1.0";
        lambdaSlider.disabled=true;

        toggleManualBtn.textContent="Punti manuali: ON";
        toggleManualBtn.classList.add("active-manual");
        const s=sessions[currentIndex];
        if(s && s.keypointsCanonical) ensureManualControlPoints(s);
        setStatus("Modalit√† punti manuali: Œª fissato a 1. Trascina i marcatori.", false);
      }else{
        toggleManualBtn.textContent="Punti manuali: OFF";
        toggleManualBtn.classList.remove("active-manual");
        lambdaSlider.disabled=false;
        curveLambda=parseFloat(lambdaBackup)||2.5;
        lambdaSlider.value=String(curveLambda);
        lambdaValue.textContent=curveLambda.toFixed(1);
        setStatus("Modalit√† punti manuali disattivata.", false);
      }
      renderSession(currentIndex);
    });

    undoPointBtn.addEventListener("click",()=>{
      const s=sessions[currentIndex];
      if(!s||!s.manualPoints||!s.manualPoints.length) return;
      if(lastDraggedIndex<0||lastDraggedIndex>=s.manualPoints.length) return;
      const kpC=s.keypointsCanonical;
      if(!kpC||!kpC.pelvisCenter) return;

      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid||pelvisC;
      const torsoVec={x:headC.x-pelvisC.x,y:headC.y-pelvisC.y};

      const idx=lastDraggedIndex;
      const hi=idx/(s.manualPoints.length-1);
      const baseX=pelvisC.x+torsoVec.x*hi;
      const baseY=pelvisC.y+torsoVec.y*hi;

      s.manualPoints[idx]={x:baseX,y:baseY};
      rebuildSpineFromControlPoints(s);
      renderSession(currentIndex);
    });

    clearManualBtn.addEventListener("click",()=>{
      const s=sessions[currentIndex];
      if(!s||!s.keypointsCanonical) return;
      s.manualPoints=null;
      s.manualOffsets=null;
      s.spineSource="auto";
      if(s.spineCanonical) s.spineSpline = computeSpineSpline(s.spineCanonical.basePoints, SPINE_SAMPLES).points;
      else s.spineSpline=null;
      lastDraggedIndex=-1;
      postProcessCurveMetrics(s);
      renderSession(currentIndex);
      setStatus("Punti manuali raddrizzati (ritorno ad auto).", false);
    });

    saveExampleBtn.addEventListener("click",()=>saveManualExampleCurrentSession());

    enableLearning.addEventListener("change",()=>{
      if(enableLearning.checked){
        reapplyLearnedModelToAllSessions();
      }else{
        for(const s of sessions){
          if(s.spineSource==="learned"){
            s.spineSource="auto";
            if(s.spineCanonical) s.spineSpline=computeSpineSpline(s.spineCanonical.basePoints,SPINE_SAMPLES).points;
          }
          if(s.metrics) postProcessCurveMetrics(s);
        }
        updateCharts(); buildTechnicalReport(); renderSession(currentIndex);
        setStatus("Uso modello appreso disattivato.", false);
      }
    });

    // Manual drag
    function endDrag(){ if(isDraggingControl){ isDraggingControl=false; draggingControlIndex=-1; } }
    function pointerToCanvasCoords(evt){
      const rect=mainCanvas.getBoundingClientRect();
      const scaleX=mainCanvas.width/rect.width;
      const scaleY=mainCanvas.height/rect.height;
      return { x:(evt.clientX-rect.left)*scaleX, y:(evt.clientY-rect.top)*scaleY };
    }
    mainCanvas.addEventListener("pointerdown",(e)=>{
      if(!manualMode||!sessions.length) return;
      const s=sessions[currentIndex];
      if(!s||!s.manualPoints||!s.manualPoints.length) return;
      const {x,y}=pointerToCanvasCoords(e);
      const pts=s.manualPoints;
      let bestIdx=-1,bestDist=Infinity;
      for(let i=0;i<pts.length;i++){
        const dist=Math.hypot(pts[i].x-x, pts[i].y-y);
        if(dist<bestDist){ bestDist=dist; bestIdx=i; }
      }
      if(bestIdx!==-1 && bestDist<18){
        isDraggingControl=true;
        draggingControlIndex=bestIdx;
        lastDraggedIndex=bestIdx;
        e.preventDefault();
      }
    });
    mainCanvas.addEventListener("pointermove",(e)=>{
      if(!isDraggingControl||!sessions.length) return;
      const s=sessions[currentIndex];
      if(!s||!s.manualPoints||!s.manualPoints.length) return;
      const {x}=pointerToCanvasCoords(e);

      const kpC=s.keypointsCanonical;
      if(!kpC||!kpC.pelvisCenter) return;

      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid||pelvisC;
      const torsoVec={x:headC.x-pelvisC.x,y:headC.y-pelvisC.y};

      const idx=draggingControlIndex;
      const hi=idx/(s.manualPoints.length-1);
      const baseY=pelvisC.y+torsoVec.y*hi;

      s.manualPoints[idx]={ x, y: baseY };
      rebuildSpineFromControlPoints(s);
      renderSession(currentIndex);
      e.preventDefault();
    });
    mainCanvas.addEventListener("pointerup",endDrag);
    mainCanvas.addEventListener("pointercancel",endDrag);
    mainCanvas.addEventListener("pointerleave",endDrag);

    // Model export/import
    downloadModelBtn?.addEventListener("click",()=>{
      try{
        const blob=new Blob([JSON.stringify(trainingExamples,null,2)],{type:"text/plain;charset=utf-8"});
        const url=URL.createObjectURL(blob);
        const a=document.createElement("a");
        a.href=url; a.download="scoliosis_model.txt";
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
        toast("Modello esportato.","info");
      }catch(err){ setStatus("Errore durante l'esportazione del modello.", true); }
    });
    modelFileInput?.addEventListener("change",(e)=>{
      const file=e.target.files?.[0];
      if(!file) return;
      const reader=new FileReader();
      reader.onload=(ev)=>{
        try{
          const arr=JSON.parse(ev.target.result);
          if(!Array.isArray(arr)) throw new Error("Formato non valido");
          trainingExamples=arr.filter(ex=>Array.isArray(ex.features)&&Array.isArray(ex.offsets)&&ex.offsets.length===SPINE_SAMPLES);
          saveTrainingExamples();
          recomputeModelErrorHistory();
          toast(`Modello caricato. Esempi: ${trainingExamples.length}.`,"info");
          reapplyLearnedModelToAllSessions();
        }catch(err){ setStatus("Errore nel formato del modello (txt/json).", true); }
      };
      reader.readAsText(file);
    });

    // Init MediaPipe + depth
    async function initPoseLandmarker(){
      try{
        setStatus("Carico modello MediaPipe Pose...", false);
        const vision=await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
        poseLandmarker=await PoseLandmarker.createFromOptions(vision,{
          baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task" },
          runningMode:"IMAGE",
          numPoses:1
        });
        modelReady=true;
        setStatus("Modello pose caricato. Carica le foto e premi Analizza.", false);
        updateAnalyzeButton();
      }catch(err){
        console.error(err);<!doctype html>
<html lang="it" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <title>Analisi Evolutiva Scoliosi ‚Äì Medical UI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b1220" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- TensorFlow.js + Depth Estimation (solo per metrica bacino) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/depth-estimation"></script>

  <style>
    :root{
      --bg:#f6f8fb;--bg2:#eef2f7;--panel:#ffffff;--panel2:#ffffff;
      --text:#0f172a;--muted:#64748b;--border:rgba(15,23,42,.10);
      --shadow:0 18px 55px rgba(15,23,42,.10);--shadow2:0 10px 30px rgba(15,23,42,.08);
      --accent:#0ea5e9;--accent2:#0284c7;--accentSoft:rgba(14,165,233,.12);
      --ok:#10b981;--warn:#f59e0b;--danger:#ef4444;
      --r-xl:22px;--r-lg:16px;--r-md:12px;--r-sm:10px;
      --font:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",Roboto,Arial,"Apple Color Emoji","Segoe UI Emoji";
    }
    html[data-theme="dark"]{
      --bg:#0b1220;--bg2:#070d18;--panel:#0f172a;--panel2:#0b1325;
      --text:#e5e7eb;--muted:#9aa4b2;--border:rgba(148,163,184,.18);
      --shadow:0 22px 65px rgba(0,0,0,.45);--shadow2:0 10px 30px rgba(0,0,0,.35);
      --accent:#38bdf8;--accent2:#0ea5e9;--accentSoft:rgba(56,189,248,.12);
    }

    *{box-sizing:border-box}
    body{
      margin:0;font-family:var(--font);color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(14,165,233,.20), transparent 60%),
        radial-gradient(900px 450px at 90% 0%, rgba(16,185,129,.10), transparent 50%),
        linear-gradient(180deg,var(--bg),var(--bg2));
      min-height:100vh;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    a{color:inherit}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}

    .topbar{
      position:sticky;top:0;z-index:50;
      backdrop-filter:blur(10px);
      background:color-mix(in oklab,var(--bg) 82%,transparent);
      border-bottom:1px solid var(--border);
    }
    .topbar-inner{
      max-width:1400px;margin:0 auto;padding:14px 16px;
      display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;
    }
    .brand{display:flex;align-items:center;gap:10px;min-width:240px}
    .brand-badge{
      width:38px;height:38px;border-radius:12px;
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      box-shadow:0 10px 26px rgba(14,165,233,.25);
      display:flex;align-items:center;justify-content:center;
      color:#04131f;font-weight:900;letter-spacing:.02em;
      flex:0 0 auto;
    }
    html[data-theme="dark"] .brand-badge{color:#06111f}
    .brand h1{margin:0;font-size:1.02rem;letter-spacing:.02em;line-height:1.1}
    .brand p{margin:0;font-size:.82rem;color:var(--muted);line-height:1.25}

    .top-actions{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end}

    button{
      border:1px solid transparent;border-radius:999px;
      padding:.58rem 1rem;font-size:.88rem;font-weight:700;
      cursor:pointer;touch-action:manipulation;
      background:linear-gradient(180deg,var(--accent),var(--accent2));
      color:#04131f;box-shadow:0 10px 26px rgba(14,165,233,.22);
      transition:transform .08s ease,box-shadow .12s ease,opacity .12s ease;
    }
    button:hover:not(:disabled){transform:translateY(-1px);box-shadow:0 14px 34px rgba(14,165,233,.26)}
    button:disabled{opacity:.55;cursor:default;box-shadow:none}
    .btn-secondary{
      background:color-mix(in oklab,var(--panel) 80%,transparent);
      color:var(--text);
      border-color:var(--border);
      box-shadow:var(--shadow2);
    }
    .btn-ghost{
      background:transparent;color:var(--text);
      border-color:var(--border);box-shadow:none;
    }
    .btn-danger{
      background:linear-gradient(180deg,#fb7185,#ef4444);
      color:#1a0206;box-shadow:0 10px 26px rgba(239,68,68,.18);
    }
    .icon-btn{padding:.55rem .75rem;display:inline-flex;align-items:center;gap:.45rem}

    input,select,textarea{
      font-family:var(--font);color:var(--text);
      background:color-mix(in oklab,var(--panel) 90%,transparent);
      border:1px solid var(--border);border-radius:12px;
      padding:.56rem .7rem;outline:none;
      transition:box-shadow .12s ease,border-color .12s ease;
    }
    input:focus,select:focus,textarea:focus{
      border-color:color-mix(in oklab,var(--accent) 60%,var(--border));
      box-shadow:0 0 0 4px var(--accentSoft);
    }
    label{font-size:.78rem;color:var(--muted);font-weight:700}
    input[type="file"]{width:100%}

    .app-shell{max-width:1400px;margin:16px auto;padding:16px}
    .grid{
      display:grid;
      grid-template-columns:minmax(0, 340px) minmax(0, 1.35fr) minmax(0, 430px);
      gap:14px;
      align-items:start;
    }
    @media (max-width: 1120px){
      .grid{grid-template-columns:1fr}
      .brand{min-width:unset}
    }

    .panel{
      background:color-mix(in oklab,var(--panel) 92%,transparent);
      border:1px solid var(--border);
      border-radius:var(--r-xl);
      box-shadow:var(--shadow2);
      padding:14px;
      overflow:hidden;
    }
    .panel-header{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
    .panel h2{margin:0;font-size:.98rem;letter-spacing:.01em}
    .chip{
      font-size:.72rem;color:var(--muted);
      border:1px solid var(--border);
      background:color-mix(in oklab,var(--panel) 85%,transparent);
      padding:.18rem .5rem;border-radius:999px;
      white-space:nowrap;
    }
    .hint{margin-top:10px;font-size:.82rem;color:var(--muted);line-height:1.45}

    .patient-form{
      display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px;
    }
    .patient-form .full{grid-column:1/-1}
    .field{display:flex;flex-direction:column;gap:6px}

    .dropzone{
      border:1.5px dashed color-mix(in oklab,var(--border) 70%,var(--muted));
      background:linear-gradient(180deg,color-mix(in oklab,var(--panel) 86%,transparent),color-mix(in oklab,var(--panel) 94%,transparent));
      border-radius:var(--r-lg);
      padding:12px;
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      margin-top:6px;
    }
    .dropzone.dragover{
      border-color:var(--accent);
      box-shadow:0 0 0 5px var(--accentSoft);
    }
    .dz-title{font-weight:900;font-size:.9rem}
    .dz-hint{color:var(--muted);font-size:.82rem;line-height:1.25}

    .status{margin-top:10px;font-size:.85rem;color:var(--muted);min-height:1.2rem}
    .status.error{color:var(--danger);font-weight:800}

    .file-list{
      margin-top:12px;
      display:flex;flex-direction:column;gap:8px;
      max-height:360px;overflow:auto;padding-right:4px;
    }
    .file-item{
      display:grid;
      grid-template-columns:56px 1fr auto;
      gap:10px;align-items:center;
      padding:10px;border-radius:16px;
      border:1px solid transparent;
      background:color-mix(in oklab,var(--panel2) 92%,transparent);
      cursor:pointer;
      transition:border-color .12s ease,transform .06s ease,background .12s ease;
    }
    .file-item:hover{border-color:color-mix(in oklab,var(--accent) 35%,var(--border));transform:translateY(-1px)}
    .file-item.active{border-color:var(--accent);box-shadow:0 0 0 4px var(--accentSoft)}
    .thumb{
      width:56px;height:56px;border-radius:14px;border:1px solid var(--border);
      background-size:cover;background-position:center;
      background-color:color-mix(in oklab,var(--bg2) 70%,var(--panel));
    }
    .file-main{display:flex;flex-direction:column;gap:6px;min-width:0}
    .file-name{font-weight:900;font-size:.86rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .file-meta{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .file-controls{display:flex;flex-direction:column;gap:6px;align-items:flex-end}
    .mini-row{display:flex;gap:6px;align-items:center}
    .mini-btn{
      padding:.2rem .5rem;border-radius:999px;border:1px solid var(--border);
      background:transparent;color:var(--muted);font-weight:900;box-shadow:none;
    }
    .mini-btn:hover{border-color:var(--accent);color:var(--text)}
    .mini-danger{border-color:color-mix(in oklab,var(--danger) 60%,var(--border));color:color-mix(in oklab,var(--danger) 70%,var(--text))}
    .mini-danger:hover{border-color:var(--danger);color:var(--danger)}

    #mainCanvas{
      width:100%;max-height:70vh;border-radius:var(--r-xl);
      border:1px solid var(--border);
      background:
        radial-gradient(700px 350px at 10% 0%, var(--accentSoft), transparent 55%),
        linear-gradient(180deg,color-mix(in oklab,var(--panel) 75%,transparent),color-mix(in oklab,var(--panel) 92%,transparent));
      box-shadow:var(--shadow2);
      touch-action:none;
    }

    .viewer-toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-top:10px}
    .viewer-nav{display:flex;gap:8px;align-items:center;flex:1 1 280px}
    .viewer-nav input[type="range"]{width:100%;accent-color:var(--accent)}
    .viewer-toggles{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end}
    .toggle{display:inline-flex;gap:8px;align-items:center;color:var(--muted);font-size:.84rem;font-weight:800}
    .toggle input{accent-color:var(--accent)}

    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
    .tab-btn{
      border-radius:999px;padding:.45rem .8rem;
      border:1px solid var(--border);
      background:transparent;color:var(--muted);font-weight:900;box-shadow:none;
    }
    .tab-btn.active{
      background:var(--accentSoft);
      border-color:color-mix(in oklab,var(--accent) 55%,var(--border));
      color:var(--text);
    }
    .tab-panel{display:none}
    .tab-panel.active{display:block}

    .chart-container{
      margin-top:10px;background:color-mix(in oklab,var(--panel2) 95%,transparent);
      border:1px solid var(--border);border-radius:var(--r-lg);
      padding:10px;
    }
    .chart-container h3{margin:0 0 8px 0;font-size:.88rem;color:var(--muted)}

    .manual-row{
      margin-top:12px;border:1px solid var(--border);
      background:color-mix(in oklab,var(--panel2) 94%,transparent);
      border-radius:var(--r-lg);padding:10px;
    }
    .manual-row strong{display:block;margin-bottom:6px;font-size:.86rem}
    .manual-controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .active-manual{border-color:color-mix(in oklab,var(--accent) 70%,var(--border))!important;box-shadow:0 0 0 4px var(--accentSoft)}

    .metric-row{
      margin-top:12px;font-size:.85rem;color:var(--muted);
      display:grid;grid-template-columns:repeat(2,minmax(0,1fr));
      gap:6px 12px;
    }
    @media (max-width: 520px){ .metric-row{grid-template-columns:1fr} }
    .metric-row strong{color:var(--text);font-weight:900}

    /* Busy overlay */
    .loading-overlay{
      position:fixed;inset:0;
      background:rgba(2,6,23,0.62);
      display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;
      z-index:9999;backdrop-filter:blur(10px);
    }
    html[data-theme="dark"] .loading-overlay{background:rgba(2,6,23,0.78)}
    .loading-overlay.hidden{display:none}
    .spinner{
      width:44px;height:44px;border-radius:999px;
      border:3px solid rgba(148,163,184,0.35);
      border-top-color:var(--accent);
      animation:spin .8s linear infinite;
    }
    .busy-text{color:#e2e8f0;font-weight:900;text-align:center;padding:0 16px}
    .progress-outer{
      width:260px;max-width:82vw;height:9px;border-radius:999px;
      background:rgba(15,23,42,0.55);
      border:1px solid rgba(148,163,184,0.35);overflow:hidden;
    }
    .progress-inner{width:0%;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));transition:width .18s ease}
    @keyframes spin{from{transform:rotate(0)}to{transform:rotate(360deg)}}

    /* Intro overlay (ridotto, mobile friendly) */
    .intro-overlay{
      position:fixed;inset:0;
      background:rgba(2,6,23,.70);
      display:flex;align-items:center;justify-content:center;
      z-index:10000;padding:16px;backdrop-filter:blur(10px);
    }
    .intro-overlay.hidden{display:none}
    .intro-card{
      width:min(520px,100%);
      background:color-mix(in oklab,var(--panel) 94%,transparent);
      border:1px solid var(--border);
      border-radius:22px;
      box-shadow:var(--shadow);
      padding:14px;
    }
    .intro-title{margin:0;font-size:1.05rem;font-weight:900}
    .intro-subtitle{margin:8px 0 0;color:var(--muted);font-size:.86rem;line-height:1.35;font-weight:700}
    .intro-steps{margin:10px 0 0;padding-left:18px;color:var(--muted);font-size:.84rem;line-height:1.35}
    .intro-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px;justify-content:flex-end}

    /* Toast */
    .toast-host{
      position:fixed;right:14px;bottom:14px;
      display:flex;flex-direction:column;gap:10px;
      z-index:12000;
      max-width:min(420px,calc(100vw - 28px));
    }
    .toast{
      border-radius:16px;border:1px solid var(--border);
      background:color-mix(in oklab,var(--panel) 92%,transparent);
      box-shadow:var(--shadow);
      padding:10px 12px;
      display:flex;gap:10px;align-items:flex-start;
    }
    .toast .dot{width:10px;height:10px;border-radius:999px;margin-top:5px;background:var(--accent);box-shadow:0 0 0 4px var(--accentSoft);flex:0 0 auto}
    .toast.warn .dot{background:var(--warn);box-shadow:0 0 0 4px rgba(245,158,11,.16)}
    .toast.error .dot{background:var(--danger);box-shadow:0 0 0 4px rgba(239,68,68,.16)}
    .toast .msg{font-size:.88rem;color:var(--text);line-height:1.25;font-weight:900}
    .toast .sub{font-size:.82rem;color:var(--muted);margin-top:2px;font-weight:700}

    /* Confirm modal */
    .confirm-overlay{
      position:fixed;inset:0;background:rgba(2,6,23,.55);
      display:flex;align-items:center;justify-content:center;
      z-index:13000;padding:16px;backdrop-filter:blur(10px);
    }
    .confirm-overlay.hidden{display:none}
    .confirm-card{
      width:min(520px,100%);
      border-radius:22px;border:1px solid var(--border);
      background:color-mix(in oklab,var(--panel) 94%,transparent);
      box-shadow:var(--shadow);
      padding:14px;
    }
    .confirm-card h3{margin:0 0 6px;font-size:1.02rem}
    .confirm-card p{margin:0;color:var(--muted);line-height:1.35;font-weight:700}
    .confirm-actions{margin-top:12px;display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap}

    /* Mobile ergonomics */
    @media (max-width: 520px){
      .topbar-inner{padding:12px 12px}
      .app-shell{padding:12px}
      .panel{padding:12px}
      button{width:100%}
      .top-actions button{width:auto}
      .dropzone{flex-direction:column;align-items:flex-start}
      .viewer-toolbar{gap:10px}
      .viewer-nav button{width:auto}
    }

    /* Print */
    @media print{
      .topbar,.toast-host,.confirm-overlay,#busyOverlay,.hint,.tabs,.manual-row,.viewer-toolbar{display:none!important}
      body{background:#fff!important}
      .panel{box-shadow:none!important;border:1px solid #ddd!important}
      .grid{grid-template-columns:1fr!important}
      #mainCanvas{max-height:none!important}
    }
  </style>
</head>

<body>
  <!-- INTRO -->
  <div id="introOverlay" class="intro-overlay">
    <div class="intro-card">
      <h2 class="intro-title">Analisi evolutiva scoliosi</h2>
      <p class="intro-subtitle">
        Carica pi√π foto dello stesso paziente (tempi diversi). L‚Äôapp stima posa, curve e metriche, genera grafici e report.
      </p>
      <ul class="intro-steps">
        <li>Carica le foto (anche drag&drop) e ordinale.</li>
        <li>Premi <strong>Analizza</strong> per estrarre pose/curve e aggiornare grafici.</li>
        <li>Se serve, forza la vista (Auto/Frontale/Posteriore/Laterale).</li>
        <li>Modalit√† manuale: trascina i punti per rifinire la curva e salva esempi per il training.</li>
      </ul>
      <div class="intro-actions">
        <button id="introStartBtn" type="button">Inizia</button>
        <button id="introSkipBtn" class="btn-secondary" type="button">Non mostrare pi√π</button>
      </div>
    </div>
  </div>

  <!-- TOPBAR -->
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="brand-badge">SC</div>
        <div>
          <h1>Analisi evolutiva scoliosi</h1>
          <p>Medical UI ‚Ä¢ mobile first ‚Ä¢ report stampabile</p>
        </div>
      </div>

      <div class="top-actions">
        <button id="helpBtn" class="btn-ghost icon-btn" type="button">‚ùî Guida</button>
        <button id="exportPrintBtn" class="btn-secondary icon-btn" type="button">üñ®Ô∏è Esporta PDF</button>
        <button id="themeToggleBtn" class="btn-secondary icon-btn" type="button">üåì Tema</button>
      </div>
    </div>
  </div>

  <div class="app-shell">
    <div class="grid">
      <!-- LEFT -->
      <section class="panel">
        <div class="panel-header">
          <h2>1) Paziente & immagini</h2>
          <span class="chip" id="sessionCounterChip">0 immagini</span>
        </div>

        <div class="patient-form" aria-label="Dati paziente">
          <div class="field">
            <label for="patientId">ID paziente</label>
            <input id="patientId" placeholder="es. 2025-001" autocomplete="off" />
          </div>
          <div class="field">
            <label for="patientName">Nome</label>
            <input id="patientName" placeholder="Nome Cognome" autocomplete="name" />
          </div>
          <div class="field">
            <label for="patientDob">Data di nascita</label>
            <input id="patientDob" type="date" />
          </div>
          <div class="field">
            <label for="patientSex">Sesso (opz.)</label>
            <select id="patientSex">
              <option value="">‚Äî</option>
              <option value="F">F</option>
              <option value="M">M</option>
              <option value="Altro">Altro</option>
            </select>
          </div>
          <div class="field full">
            <label for="patientNote">Nota clinica (opz.)</label>
            <input id="patientNote" placeholder="es. brace, trattamento, ecc." />
          </div>
          <div class="field full" style="display:flex;gap:8px;flex-wrap:wrap;">
            <button id="savePatientBtn" class="btn-secondary" type="button">Salva paziente</button>
            <button id="clearPatientBtn" class="btn-ghost" type="button">Svuota dati</button>
          </div>
        </div>

        <div id="dropzone" class="dropzone" role="button" tabindex="0" aria-label="Carica immagini tramite drag and drop o selezione file">
          <div style="display:flex;flex-direction:column;gap:4px;">
            <div class="dz-title">Carica foto (drag&drop)</div>
            <div class="dz-hint">Suggerimento: usa nomi con data (es. 2025-12-01_front.jpg) per timeline automatica.</div>
          </div>
          <button id="pickFilesBtn" class="btn-secondary" type="button">Seleziona</button>
        </div>

        <label class="sr-only" for="fileInput">Seleziona immagini</label>
        <input id="fileInput" type="file" accept="image/*" multiple />

        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;">
          <button id="analyzeBtn" disabled type="button">Analizza tutte le foto</button>
          <button id="clearBtn" class="btn-secondary" type="button">Svuota</button>
        </div>

        <div id="status" class="status"></div>
        <div class="file-list" id="fileList" aria-label="Elenco immagini"></div>

        <p class="hint">
          Tocca una foto per visualizzarla. Puoi cambiare la vista (Auto/Frontale/Posteriore/Laterale) e aggiungere data/nota.
          I metadati restano salvati nel browser (localStorage).
        </p>
      </section>

      <!-- CENTER -->
      <section class="panel">
        <div class="panel-header">
          <h2>2) Visualizzazione</h2>
          <span class="chip" id="viewChip">Vista: ‚Äî</span>
        </div>

        <canvas id="mainCanvas" width="600" height="800"></canvas>

        <div class="viewer-toolbar">
          <div class="viewer-nav">
            <button id="prevBtn" class="btn-secondary" type="button">‚Üê</button>
            <input id="scrubSlider" type="range" min="0" max="0" value="0" step="1" />
            <button id="nextBtn" class="btn-secondary" type="button">‚Üí</button>
          </div>
          <div class="viewer-toggles">
            <label class="toggle"><input type="checkbox" id="toggleSkeleton" checked /> Scheletro</label>
            <label class="toggle"><input type="checkbox" id="toggleSpine" checked /> Curva</label>
            <label class="toggle"><input type="checkbox" id="toggleVectors" checked /> Vettori</label>
          </div>
        </div>

        <div class="hint" style="margin-top:10px;font-weight:900;">
          Enfatizzazione curva (Œª): <span id="lambdaValue">2.5</span>x
        </div>
        <input type="range" id="lambdaSlider" min="1" max="6" step="0.1" value="2.5"
               style="width:100%;accent-color:var(--accent);margin-top:6px;" />

        <div class="manual-row">
          <strong>Controlli manuali colonna & training adattivo</strong>
          <div class="manual-controls">
            <button id="toggleManualBtn" class="btn-secondary" type="button">Punti manuali: OFF</button>
            <button id="undoPointBtn" class="btn-secondary" type="button">Annulla ultimo</button>
            <button id="clearManualBtn" class="btn-secondary" type="button">Raddrizza</button>
          </div>
          <div class="manual-controls" style="margin-top:8px;">
            <button id="saveExampleBtn" type="button">Salva esempio</button>
            <label class="toggle" style="margin-left:4px;">
              <input type="checkbox" id="enableLearning" checked />
              Applica modello appreso
            </label>
          </div>
          <p class="hint">
            In modalit√† manuale: Œª fissato a 1, trascina solo in orizzontale i 10 punti tra bacino e testa.
            Salva esempi per guidare il modello su curve simili.
          </p>
        </div>

        <div class="metric-row" id="metricRow"></div>

        <p class="hint">
          Nota: il Cobb √® una stima fotogrammetrica (non radiografica). Usare come supporto al follow-up, non come sostituto diagnostico.
        </p>
      </section>

      <!-- RIGHT -->
      <section class="panel">
        <div class="panel-header">
          <h2>3) Analitica & report</h2>
          <span class="chip" id="modelChip">Modello: 0 esempi</span>
        </div>

        <div class="tabs" role="tablist" aria-label="Sezioni analitica">
          <button class="tab-btn active" data-tab="tabCharts" type="button" role="tab">Grafici</button>
          <button class="tab-btn" data-tab="tabReport" type="button" role="tab">Report</button>
          <button class="tab-btn" data-tab="tabModel" type="button" role="tab">Modello</button>
        </div>

        <div id="tabCharts" class="tab-panel active" role="tabpanel">
          <div class="chart-container">
            <h3>Angoli spalle, bacino, testa, Cobb</h3>
            <canvas id="chartAngles" height="140"></canvas>
          </div>
          <div class="chart-container">
            <h3>Centratura testa / bacino / ‚Äústerno‚Äù</h3>
            <canvas id="chartOffsets" height="140"></canvas>
          </div>
          <div class="chart-container">
            <h3>Apprendimento modello (errore medio curva)</h3>
            <canvas id="chartModel" height="120"></canvas>
          </div>
        </div>

        <div id="tabReport" class="tab-panel" role="tabpanel">
          <div class="chart-container">
            <h3>Report tecnico</h3>
            <div class="hint" style="margin-top:0;">
              Usa ‚ÄúEsporta PDF‚Äù per stampare o archiviare in cartella clinica.
            </div>
          </div>

          <div class="manual-row" style="margin-top:10px;">
            <div id="reportPanel">
              <h3 style="margin:0 0 6px;">Report tecnico automatico</h3>
              <p style="margin:0;color:var(--muted);font-weight:700;">Analizza le immagini per generare il report.</p>
            </div>
          </div>
        </div>

        <div id="tabModel" class="tab-panel" role="tabpanel">
          <div class="manual-row" id="modelManagementRow">
            <strong>Modello appreso ‚Äì export/import</strong>
            <div class="manual-controls">
              <button id="downloadModelBtn" class="btn-secondary" type="button">Scarica modello (txt)</button>
              <label for="modelFileInput" class="btn-secondary" style="cursor:pointer;">
                Carica modello (txt/json)
              </label>
              <input id="modelFileInput" type="file" accept=".txt,.json" style="display:none;" />
            </div>
            <p class="hint">Il modello (esempi manuali) √® salvato nel browser. Puoi esportarlo e riutilizzarlo.</p>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- Busy overlay -->
  <div id="busyOverlay" class="loading-overlay hidden">
    <div class="spinner"></div>
    <div id="busyText" class="busy-text">Elaborazione in corso...</div>
    <div class="progress-outer">
      <div id="busyProgress" class="progress-inner"></div>
    </div>
  </div>

  <!-- Toast -->
  <div id="toastHost" class="toast-host" aria-live="polite" aria-relevant="additions"></div>

  <!-- Confirm -->
  <div id="confirmOverlay" class="confirm-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
    <div class="confirm-card">
      <h3 id="confirmTitle">Conferma</h3>
      <p id="confirmText">Sei sicuro?</p>
      <div class="confirm-actions">
        <button id="confirmCancelBtn" class="btn-secondary" type="button">Annulla</button>
        <button id="confirmOkBtn" class="btn-danger" type="button">Conferma</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { FilesetResolver, PoseLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js";

    // ---------------- UX helpers (toast, confirm, theme, patient, tabs, nav) ----------------
    const toastHost = document.getElementById("toastHost");
    function toast(msg, type="info", sub=""){
      if(!toastHost) return;
      const el=document.createElement("div");
      el.className=`toast ${type==="error"?"error":type==="warn"?"warn":""}`;
      el.innerHTML=`<div class="dot"></div><div><div class="msg">${msg}</div>${sub?`<div class="sub">${sub}</div>`:""}</div>`;
      toastHost.appendChild(el);
      setTimeout(()=>{ el.style.opacity="0"; el.style.transform="translateY(6px)"; setTimeout(()=>el.remove(),220); },3200);
    }

    const confirmOverlay = document.getElementById("confirmOverlay");
    const confirmText = document.getElementById("confirmText");
    const confirmOkBtn = document.getElementById("confirmOkBtn");
    const confirmCancelBtn = document.getElementById("confirmCancelBtn");
    function confirmAsync(message="Confermi?"){
      return new Promise((resolve)=>{
        if(!confirmOverlay||!confirmText||!confirmOkBtn||!confirmCancelBtn){ resolve(window.confirm(message)); return; }
        confirmText.textContent=message;
        confirmOverlay.classList.remove("hidden");
        const cleanup=()=>{
          confirmOverlay.classList.add("hidden");
          confirmOkBtn.onclick=null;
          confirmCancelBtn.onclick=null;
        };
        confirmOkBtn.onclick=()=>{ cleanup(); resolve(true); };
        confirmCancelBtn.onclick=()=>{ cleanup(); resolve(false); };
        confirmOverlay.addEventListener("click",(e)=>{ if(e.target===confirmOverlay){ cleanup(); resolve(false); } },{once:true});
      });
    }

    const themeBtn = document.getElementById("themeToggleBtn");
    function applyTheme(next){
      document.documentElement.setAttribute("data-theme", next);
      try{ localStorage.setItem("scoliosisTheme_v2", next); }catch{}
      // (charts theme refresh happens lazily on next update)
    }
    (function initTheme(){
      let t=null; try{ t=localStorage.getItem("scoliosisTheme_v2"); }catch{}
      if(!t){
        t = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      }
      applyTheme(t);
    })();
    themeBtn?.addEventListener("click",()=>{
      const cur=document.documentElement.getAttribute("data-theme")||"dark";
      applyTheme(cur==="dark"?"light":"dark");
      // force chart redraw:
      if(anglesChart) anglesChart.update();
      if(offsetsChart) offsetsChart.update();
      if(modelChart) modelChart.update();
    });

    // Tabs
    document.querySelectorAll(".tab-btn").forEach((btn)=>{
      btn.addEventListener("click",()=>{
        document.querySelectorAll(".tab-btn").forEach(b=>b.classList.remove("active"));
        document.querySelectorAll(".tab-panel").forEach(p=>p.classList.remove("active"));
        btn.classList.add("active");
        const id=btn.getAttribute("data-tab");
        document.getElementById(id)?.classList.add("active");
      });
    });

    // Intro overlay
    const introOverlay = document.getElementById("introOverlay");
    const introStartBtn = document.getElementById("introStartBtn");
    const introSkipBtn = document.getElementById("introSkipBtn");
    function hideIntroOverlay(permanent=false){
      introOverlay.classList.add("hidden");
      if(permanent){ try{ localStorage.setItem("scoliosisIntroSeen_v2","1"); }catch{} }
    }
    (function initIntro(){
      let seen=null; try{ seen=localStorage.getItem("scoliosisIntroSeen_v2"); }catch{}
      if(seen==="1") introOverlay.classList.add("hidden");
    })();
    introStartBtn?.addEventListener("click",()=>hideIntroOverlay(false));
    introSkipBtn?.addEventListener("click",()=>hideIntroOverlay(true));
    document.getElementById("helpBtn")?.addEventListener("click",()=>introOverlay.classList.remove("hidden"));

    // Print
    document.getElementById("exportPrintBtn")?.addEventListener("click",()=>{
      document.querySelector('.tab-btn[data-tab="tabReport"]')?.click();
      window.print();
    });

    // Patient
    const patientIdEl = document.getElementById("patientId");
    const patientNameEl = document.getElementById("patientName");
    const patientDobEl = document.getElementById("patientDob");
    const patientSexEl = document.getElementById("patientSex");
    const patientNoteEl = document.getElementById("patientNote");
    function readPatient(){
      return {
        id: patientIdEl?.value?.trim()||"",
        name: patientNameEl?.value?.trim()||"",
        dob: patientDobEl?.value||"",
        sex: patientSexEl?.value||"",
        note: patientNoteEl?.value?.trim()||""
      };
    }
    function loadPatient(){
      try{
        const raw=localStorage.getItem("scoliosisPatient_v2");
        if(!raw) return;
        const p=JSON.parse(raw);
        if(patientIdEl) patientIdEl.value=p.id||"";
        if(patientNameEl) patientNameEl.value=p.name||"";
        if(patientDobEl) patientDobEl.value=p.dob||"";
        if(patientSexEl) patientSexEl.value=p.sex||"";
        if(patientNoteEl) patientNoteEl.value=p.note||"";
      }catch{}
    }
    function savePatient(){
      try{ localStorage.setItem("scoliosisPatient_v2", JSON.stringify(readPatient())); }catch{}
      toast("Dati paziente salvati","info");
      buildTechnicalReport();
    }
    function clearPatient(){
      if(patientIdEl) patientIdEl.value="";
      if(patientNameEl) patientNameEl.value="";
      if(patientDobEl) patientDobEl.value="";
      if(patientSexEl) patientSexEl.value="";
      if(patientNoteEl) patientNoteEl.value="";
      try{ localStorage.removeItem("scoliosisPatient_v2"); }catch{}
      toast("Dati paziente svuotati","warn");
      buildTechnicalReport();
    }
    document.getElementById("savePatientBtn")?.addEventListener("click",savePatient);
    document.getElementById("clearPatientBtn")?.addEventListener("click",clearPatient);
    loadPatient();

    function inferDateFromFilename(name){
      if(!name) return "";
      const s=name.toLowerCase();
      let m=s.match(/(20\\d{2})[-_\\.](0\\d|1[0-2])[-_\\.]([0-2]\\d|3[01])/);
      if(m) return `${m[1]}-${m[2]}-${m[3]}`;
      m=s.match(/(20\\d{2})(0\\d|1[0-2])([0-2]\\d|3[01])/);
      if(m) return `${m[1]}-${m[2]}-${m[3]}`;
      m=s.match(/([0-2]\\d|3[01])[-_\\.](0\\d|1[0-2])[-_\\.](20\\d{2})/);
      if(m) return `${m[3]}-${m[2]}-${m[1]}`;
      return "";
    }

    // Dropzone
    const dropzone = document.getElementById("dropzone");
    const pickFilesBtn = document.getElementById("pickFilesBtn");
    const fileInput = document.getElementById("fileInput");
    pickFilesBtn?.addEventListener("click",()=>fileInput.click());
    dropzone?.addEventListener("click",()=>fileInput.click());
    dropzone?.addEventListener("keydown",(e)=>{ if(e.key==="Enter"||e.key===" ") fileInput.click(); });
    ["dragenter","dragover"].forEach(evt=>{
      dropzone?.addEventListener(evt,(e)=>{ e.preventDefault(); dropzone.classList.add("dragover"); });
    });
    ["dragleave","drop"].forEach(evt=>{
      dropzone?.addEventListener(evt,(e)=>{ e.preventDefault(); dropzone.classList.remove("dragover"); });
    });
    dropzone?.addEventListener("drop",(e)=>{
      const dt=e.dataTransfer;
      if(!dt?.files?.length) return;
      fileInput.files = dt.files;
      fileInput.dispatchEvent(new Event("change"));
    });

    // ---------------- Original logic (con minime migliorie UI) ----------------

    const PoseIdx = {
      NOSE: 0, LEFT_EYE: 2, RIGHT_EYE: 5, MOUTH_LEFT: 9, MOUTH_RIGHT: 10,
      LEFT_SHOULDER: 11, RIGHT_SHOULDER: 12,
      LEFT_HIP: 23, RIGHT_HIP: 24,
      LEFT_EAR: 7, RIGHT_EAR: 8
    };

    const SPINE_SAMPLES = 21;
    const CONTROL_POINTS = 10;

    // soglie clinico-fotogrammetriche
    const CURVE_NOISE_DEV_NORM = 0.02;
    const CURVE_SUSPECT_DEV_NORM = 0.035;
    const COBB_NOISE_FLOOR_DEG = 5;
    const COBB_SUSPECT_DEG = 10;

    let poseLandmarker = null;
    let modelReady = false;
    let depthEstimator = null;
    let depthReady = false;
    let imagesReady = false;

    let sessions = [];
    let currentIndex = 0;
    let curveLambda = 2.5;
    let lambdaBackup = curveLambda;

    let anglesChart = null;
    let offsetsChart = null;
    let modelChart = null;
    let modelErrorHistory = [];

    // manual & training
    let manualMode = false;
    let trainingExamples = []; // {features:[], offsets:[]}
    let isDraggingControl = false;
    let draggingControlIndex = -1;
    let lastDraggedIndex = -1;

    // UI refs
    const analyzeBtn = document.getElementById("analyzeBtn");
    const clearBtn = document.getElementById("clearBtn");
    const statusEl = document.getElementById("status");
    const fileListEl = document.getElementById("fileList");
    const mainCanvas = document.getElementById("mainCanvas");
    const mainCtx = mainCanvas.getContext("2d");
    const metricRow = document.getElementById("metricRow");
    const reportPanel = document.getElementById("reportPanel");

    const toggleSkeleton = document.getElementById("toggleSkeleton");
    const toggleSpine = document.getElementById("toggleSpine");
    const toggleVectors = document.getElementById("toggleVectors");

    const lambdaSlider = document.getElementById("lambdaSlider");
    const lambdaValue = document.getElementById("lambdaValue");

    const toggleManualBtn = document.getElementById("toggleManualBtn");
    const undoPointBtn = document.getElementById("undoPointBtn");
    const clearManualBtn = document.getElementById("clearManualBtn");
    const saveExampleBtn = document.getElementById("saveExampleBtn");
    const enableLearning = document.getElementById("enableLearning");

    const downloadModelBtn = document.getElementById("downloadModelBtn");
    const modelFileInput = document.getElementById("modelFileInput");

    const busyOverlay = document.getElementById("busyOverlay");
    const busyText = document.getElementById("busyText");
    const busyProgress = document.getElementById("busyProgress");

    // Viewer nav
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const scrubSlider = document.getElementById("scrubSlider");
    const viewChip = document.getElementById("viewChip");
    const modelChip = document.getElementById("modelChip");
    const sessionCounterChip = document.getElementById("sessionCounterChip");

    function setStatus(text, isError=false){
      statusEl.classList.toggle("error", !!isError);
      statusEl.textContent = text || "";
      if(text) toast(text, isError ? "error" : "info");
    }

    function getEffectiveViewType(session) {
      if (!session) return "non determinata";
      if (session.viewTypeOverride && session.viewTypeOverride !== "auto") return session.viewTypeOverride;
      return session.viewTypeAuto || session.viewType || "non determinata";
    }

    function showBusy(text = "Elaborazione in corso...", fraction = 0) {
      busyOverlay.classList.remove("hidden");
      busyText.textContent = text;
      busyProgress.style.width = `${Math.round(fraction * 100)}%`;
    }
    function updateBusy(text, fraction) {
      if (text) busyText.textContent = text;
      if (typeof fraction === "number") busyProgress.style.width = `${Math.round(fraction * 100)}%`;
    }
    function hideBusy() {
      busyOverlay.classList.add("hidden");
      busyProgress.style.width = "0%";
    }

    function updateNavUI(){
      const n=sessions.length;
      if(sessionCounterChip) sessionCounterChip.textContent = `${n} immagini`;
      scrubSlider.max = String(Math.max(0,n-1));
      scrubSlider.value = String(Math.min(currentIndex, Math.max(0,n-1)));
      if(prevBtn) prevBtn.disabled = n===0 || currentIndex<=0;
      if(nextBtn) nextBtn.disabled = n===0 || currentIndex>=n-1;

      const s=sessions[currentIndex];
      if(viewChip) viewChip.textContent = `Vista: ${s ? getEffectiveViewType(s) : "‚Äî"}`;
      if(modelChip) modelChip.textContent = `Modello: ${trainingExamples.length} esempi`;
    }
    function goTo(i){
      if(!sessions.length) return;
      currentIndex = Math.max(0, Math.min(sessions.length-1, i));
      renderSession(currentIndex);
    }
    prevBtn?.addEventListener("click",()=>goTo(currentIndex-1));
    nextBtn?.addEventListener("click",()=>goTo(currentIndex+1));
    scrubSlider?.addEventListener("input",()=>goTo(parseInt(scrubSlider.value||"0",10)));
    window.addEventListener("keydown",(e)=>{
      if(e.target && ["INPUT","TEXTAREA","SELECT"].includes(e.target.tagName)) return;
      if(e.key==="ArrowLeft") goTo(currentIndex-1);
      if(e.key==="ArrowRight") goTo(currentIndex+1);
      if(e.key==="?") introOverlay.classList.remove("hidden");
    });

    function midpoint(a, b){ if(!a||!b) return null; return { x:(a.x+b.x)/2, y:(a.y+b.y)/2, z:(a.z+b.z)/2 }; }
    function averagePoints(points){
      const valid=points.filter(p=>p);
      if(!valid.length) return null;
      const sum=valid.reduce((acc,p)=>{ acc.x+=p.x; acc.y+=p.y; acc.z+=(p.z||0); return acc; },{x:0,y:0,z:0});
      return { x:sum.x/valid.length, y:sum.y/valid.length, z:sum.z/valid.length };
    }
    function distance(a,b){ if(!a||!b) return 0; return Math.hypot(a.x-b.x,a.y-b.y); }
    function rad2deg(r){ return (r*180)/Math.PI; }
    function normalizeAngle90(deg){
      if(deg===null||deg===undefined||!Number.isFinite(deg)) return null;
      let a=deg; while(a<=-90) a+=180; while(a>90) a-=180; return a;
    }
    function angleOfLineDeg(p1,p2){
      if(!p1||!p2) return null;
      const raw=rad2deg(Math.atan2(p2.y-p1.y,p2.x-p1.x));
      return normalizeAngle90(raw);
    }
    function headTiltRelativeVerticalDeg(head, neck){
      if(!head||!neck) return null;
      const vx=head.x-neck.x, vy=head.y-neck.y;
      const norm=Math.hypot(vx,vy)||1;
      const ux=0, uy=-1;
      let cos=(vx*ux+vy*uy)/norm; cos=Math.min(1,Math.max(-1,cos));
      let angle=rad2deg(Math.acos(cos)); if(angle>90) angle=180-angle;
      const sign=vx>=0?1:-1;
      return normalizeAngle90(angle*sign);
    }
    function angleBetweenVectorsDeg(v1,v2){
      const dot=v1.x*v2.x+v1.y*v2.y;
      const n1=Math.hypot(v1.x,v1.y), n2=Math.hypot(v2.x,v2.y);
      if(n1===0||n2===0) return 0;
      let cos=dot/(n1*n2); cos=Math.min(1,Math.max(-1,cos));
      return rad2deg(Math.acos(cos));
    }

    function computeAlignmentTransform(kp, img){
      const pelvis=kp.pelvisCenter;
      const top=kp.headCenter||kp.neckBase||kp.shoulderMid;
      if(!pelvis||!top){
        return { pelvis:{x:img.naturalWidth/2,y:img.naturalHeight*0.8}, rotation:0, scale:1, tx:mainCanvas.width/2, ty:mainCanvas.height*0.8 };
      }
      const dx=top.x-pelvis.x, dy=top.y-pelvis.y;
      const currentAngle=Math.atan2(dy,dx);
      const desiredAngle=-Math.PI/2;
      const rotation=desiredAngle-currentAngle;
      const torsoLen=Math.max(distance(top,pelvis),1);
      const desiredTorsoLen=mainCanvas.height*0.5;
      const scale=desiredTorsoLen/torsoLen;
      const tx=mainCanvas.width/2, ty=mainCanvas.height*0.8;
      return { pelvis, rotation, scale, tx, ty };
    }
    function transformPoint(p, t){
      const {pelvis, rotation, scale, tx, ty}=t;
      const x0=p.x-pelvis.x, y0=p.y-pelvis.y;
      const x1=x0*scale, y1=y0*scale;
      const cosA=Math.cos(rotation), sinA=Math.sin(rotation);
      const x2=x1*cosA-y1*sinA;
      const y2=x1*sinA+y1*cosA;
      return { x:x2+tx, y:y2+ty };
    }
    function drawImageWithTransform(ctx, image, t){
      const {pelvis, rotation, scale, tx, ty}=t;
      ctx.save();
      ctx.translate(tx,ty);
      ctx.rotate(rotation);
      ctx.scale(scale,scale);
      ctx.translate(-pelvis.x,-pelvis.y);
      ctx.drawImage(image,0,0);
      ctx.restore();
    }

    function extractKeypoints(landmarks,width,height){
      const p=(idx)=>{
        const lm=landmarks[idx];
        if(!lm) return null;
        return { x:lm.x*width, y:lm.y*height, z:lm.z||0, visibility:lm.visibility??1 };
      };
      const leftShoulder=p(PoseIdx.LEFT_SHOULDER);
      const rightShoulder=p(PoseIdx.RIGHT_SHOULDER);
      const leftHip=p(PoseIdx.LEFT_HIP);
      const rightHip=p(PoseIdx.RIGHT_HIP);
      const pelvisCenter=midpoint(leftHip,rightHip);
      const shoulderMid=midpoint(leftShoulder,rightShoulder);
      const leftEar=p(PoseIdx.LEFT_EAR);
      const rightEar=p(PoseIdx.RIGHT_EAR);
      const nose=p(PoseIdx.NOSE);
      const leftEye=p(PoseIdx.LEFT_EYE);
      const rightEye=p(PoseIdx.RIGHT_EYE);
      const mouthLeft=p(PoseIdx.MOUTH_LEFT);
      const mouthRight=p(PoseIdx.MOUTH_RIGHT);
      const headCenter=averagePoints([leftEar,rightEar,nose,leftEye,rightEye]);
      const neckBase=midpoint(shoulderMid, headCenter||shoulderMid);
      const midTorso=midpoint(shoulderMid, pelvisCenter);
      return { nose,leftEye,rightEye,mouthLeft,mouthRight,leftShoulder,rightShoulder,leftHip,rightHip,pelvisCenter,shoulderMid,headCenter,neckBase,midTorso,leftEar,rightEar };
    }

    function detectPoseOrientation(landmarks,kp){
      const ls=kp.leftShoulder, rs=kp.rightShoulder, pelvis=kp.pelvisCenter, neck=kp.neckBase||kp.shoulderMid;
      if(!ls||!rs||!pelvis||!neck) return "non determinata";
      const torsoLen=distance(neck,pelvis)||1;
      const shoulderWidth=Math.abs(ls.x-rs.x);
      const shoulderWidthNorm=shoulderWidth/torsoLen;
      if(shoulderWidthNorm<0.25) return "laterale";
      const nose=landmarks[PoseIdx.NOSE], le=landmarks[PoseIdx.LEFT_EYE], re=landmarks[PoseIdx.RIGHT_EYE],
            ml=landmarks[PoseIdx.MOUTH_LEFT], mr=landmarks[PoseIdx.MOUTH_RIGHT];
      const faceVisible=[nose,le,re,ml,mr].filter(l=>l && typeof l.visibility==="number");
      let score=0;
      if(faceVisible.length) score=faceVisible.reduce((s,l)=>s+l.visibility,0)/faceVisible.length;
      return score>0.35 ? "frontale" : "posteriore";
    }

    function computeDetailedCanonicalRepere(kpC){
      const ribsLeft=[], ribsRight=[], ribsMid=[];
      const ribFracs=[0.15,0.3,0.45,0.6,0.75,0.9];
      if(kpC.leftShoulder && kpC.leftHip && kpC.rightShoulder && kpC.rightHip){
        for(const f of ribFracs){
          const L={ x:kpC.leftShoulder.x+f*(kpC.leftHip.x-kpC.leftShoulder.x),
                    y:kpC.leftShoulder.y+f*(kpC.leftHip.y-kpC.leftShoulder.y), z:0 };
          const R={ x:kpC.rightShoulder.x+f*(kpC.rightHip.x-kpC.rightShoulder.x),
                    y:kpC.rightShoulder.y+f*(kpC.rightHip.y-kpC.rightShoulder.y), z:0 };
          ribsLeft.push(L); ribsRight.push(R); ribsMid.push(midpoint(L,R));
        }
      }
      let sternum=null;
      if(ribsMid.length) sternum=ribsMid[0];
      else if(kpC.shoulderMid && kpC.midTorso) sternum=midpoint(kpC.shoulderMid,kpC.midTorso);
      else sternum=kpC.shoulderMid||kpC.neckBase||null;

      const clavSegments=[];
      if(kpC.neckBase){
        if(kpC.leftShoulder) clavSegments.push({start:kpC.neckBase,end:kpC.leftShoulder});
        if(kpC.rightShoulder) clavSegments.push({start:kpC.neckBase,end:kpC.rightShoulder});
      }

      const scmSegments=[];
      const leftMastoid=kpC.leftEar||kpC.headCenter;
      const rightMastoid=kpC.rightEar||kpC.headCenter;
      if(leftMastoid && sternum) scmSegments.push({start:leftMastoid,end:sternum});
      if(rightMastoid && sternum) scmSegments.push({start:rightMastoid,end:sternum});

      return { ribsLeft,ribsRight,ribsMid,sternum,clavSegments,scmSegments };
    }

    function estimateSpineCanonical(kpC, viewType){
      const points=[];
      const vt=viewType||"non determinata";
      if(vt==="laterale"){
        if(kpC.pelvisCenter) points.push(kpC.pelvisCenter);
        if(kpC.midTorso) points.push(kpC.midTorso);
        if(kpC.neckBase||kpC.shoulderMid) points.push(kpC.neckBase||kpC.shoulderMid);
        if(kpC.headCenter) points.push(kpC.headCenter);
      } else if(vt==="posteriore"){
        if(kpC.pelvisCenter) points.push(kpC.pelvisCenter);
        if(kpC.ribsMid && kpC.ribsMid.length){
          const sorted=[...kpC.ribsMid].sort((a,b)=>b.y-a.y);
          sorted.forEach(p=>points.push(p));
        } else if(kpC.midTorso) points.push(kpC.midTorso);
        if(kpC.neckBase||kpC.shoulderMid) points.push(kpC.neckBase||kpC.shoulderMid);
        if(kpC.headCenter) points.push(kpC.headCenter);
      } else {
        if(kpC.pelvisCenter) points.push(kpC.pelvisCenter);
        if(kpC.ribsMid && kpC.ribsMid.length){
          const sorted=[...kpC.ribsMid].sort((a,b)=>b.y-a.y);
          sorted.forEach(p=>points.push(p));
        } else if(kpC.midTorso) points.push(kpC.midTorso);
        if(kpC.sternum) points.push(kpC.sternum);
        if(kpC.neckBase||kpC.shoulderMid) points.push(kpC.neckBase||kpC.shoulderMid);
        if(kpC.headCenter) points.push(kpC.headCenter);
      }
      if(points.length<2) return null;
      const anglesLocal=[];
      for(let i=1;i<points.length-1;i++){
        const v1={x:points[i].x-points[i-1].x,y:points[i].y-points[i-1].y};
        const v2={x:points[i+1].x-points[i].x,y:points[i+1].y-points[i].y};
        anglesLocal.push(angleBetweenVectorsDeg(v1,v2));
      }
      const maxAngle=anglesLocal.reduce((acc,v)=>Math.max(acc,Math.abs(v)),0);
      return { basePoints:points, maxAngleLocal:maxAngle };
    }

    function computeSpineSpline(basePoints, samples=SPINE_SAMPLES){
      if(!basePoints||basePoints.length<2) return { points:null };
      const n=basePoints.length;
      const pts=[];
      for(let i=0;i<samples;i++){
        const tGlobal=(i/(samples-1))*(n-1);
        const i0=Math.floor(tGlobal);
        const i1=Math.min(n-1,i0+1);
        const localT=tGlobal-i0;
        const p0=basePoints[i0], p1=basePoints[i1];
        pts.push({ x:p0.x+(p1.x-p0.x)*localT, y:p0.y+(p1.y-p0.y)*localT });
      }
      const smoothed=pts.map((p,idx)=>{
        const w=[]; if(idx>0) w.push(pts[idx-1]); w.push(p); if(idx<pts.length-1) w.push(pts[idx+1]);
        return { x:w.reduce((s,q)=>s+q.x,0)/w.length, y:w.reduce((s,q)=>s+q.y,0)/w.length };
      });
      return { points:smoothed };
    }

    function estimateCobbAngle(pelvisTiltDeg, headAxisDeg, splinePoints){
      let bottomSplineA=null, topSplineA=null;
      if(splinePoints && splinePoints.length>=6){
        const k=2;
        bottomSplineA=angleOfLineDeg(splinePoints[0], splinePoints[k]);
        topSplineA=angleOfLineDeg(splinePoints[splinePoints.length-1-k], splinePoints[splinePoints.length-1]);
      }
      let bottomA=bottomSplineA, topA=topSplineA;
      const hasPelvis=pelvisTiltDeg!=null && Number.isFinite(pelvisTiltDeg);
      const hasHead=headAxisDeg!=null && Number.isFinite(headAxisDeg);
      if(hasPelvis){
        const axisInf=normalizeAngle90(pelvisTiltDeg+90);
        bottomA = bottomA==null ? axisInf : 0.5*bottomA + 0.5*axisInf;
      }
      if(hasHead){
        const axisSup=normalizeAngle90(headAxisDeg);
        topA = topA==null ? axisSup : 0.5*topA + 0.5*axisSup;
      }
      if(bottomA==null || topA==null) return null;
      const aTop=normalizeAngle90(topA), aBot=normalizeAngle90(bottomA);
      let diff=Math.abs(aTop-aBot);
      if(diff>90) diff=180-diff;
      return diff;
    }

    function analyzeSpineDeviation(spinePoints, kpC){
      if(!spinePoints||spinePoints.length<2||!kpC||!kpC.pelvisCenter) return null;
      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid;
      if(!headC) return null;
      const vx=headC.x-pelvisC.x, vy=headC.y-pelvisC.y;
      const len=Math.hypot(vx,vy)||1;
      const nx=-vy/len, ny=vx/len;
      let maxAbsOff=0, sumAbsOff=0, midOffset=0;
      const n=spinePoints.length;
      const offsetsNorm=[];
      for(let i=0;i<n;i++){
        const p=spinePoints[i]; if(!p) continue;
        const wx=p.x-pelvisC.x, wy=p.y-pelvisC.y;
        const off=wx*nx + wy*ny;
        const absOff=Math.abs(off);
        if(absOff>maxAbsOff) maxAbsOff=absOff;
        sumAbsOff += absOff;
        if(i===Math.floor(n/2)) midOffset=off;
        offsetsNorm.push(off/len);
      }
      const meanAbsOff=n ? sumAbsOff/n : 0;
      const maxDevNorm=maxAbsOff/len;
      const meanDevNorm=meanAbsOff/len;
      return {
        maxDeviationPx:maxAbsOff,
        maxDeviationNorm:maxDevNorm,
        meanDeviationNorm:meanDevNorm,
        midOffsetNorm:midOffset/len,
        curveIsNoise:maxDevNorm < CURVE_NOISE_DEV_NORM,
        curveIsBorder:maxDevNorm >= CURVE_NOISE_DEV_NORM && maxDevNorm < CURVE_SUSPECT_DEV_NORM,
        curveIsSignificant:maxDevNorm >= CURVE_SUSPECT_DEV_NORM,
        offsetsNorm
      };
    }

    function computeCurveCategory(absCobb, analysis, viewType){
      if(viewType==="laterale") return "vista laterale (curva sagittale; Cobb non applicabile)";
      if(!analysis) return "non valutabile";
      const dev=analysis.maxDeviationNorm ?? 0;
      if(dev < CURVE_NOISE_DEV_NORM && absCobb < COBB_NOISE_FLOOR_DEG) return "schiena pressoch√© dritta (entro rumore)";
      if(dev < CURVE_SUSPECT_DEV_NORM && absCobb < COBB_SUSPECT_DEG) return "asimmetria lieve / non specifica";
      if(analysis.curveIsSignificant && absCobb >= COBB_SUSPECT_DEG) return "curva potenzialmente scoliotica (da confermare Rx)";
      return "asimmetria moderata";
    }

    function postProcessCurveMetrics(session){
      if(!session||!session.metrics||!session.spineSpline||!session.keypointsCanonical){ session.curveAnalysis=null; return; }
      const vType=getEffectiveViewType(session);
      const analysis=analyzeSpineDeviation(session.spineSpline, session.keypointsCanonical);
      session.curveAnalysis=analysis;
      if(!analysis){ session.metrics.curveMaxDeviationNorm=null; session.metrics.curveCategory="non valutabile"; return; }
      if(vType==="laterale"){
        session.metrics.cobbAngleDeg=null;
        session.metrics.curveMaxDeviationNorm=analysis.maxDeviationNorm;
        session.metrics.curveCategory=computeCurveCategory(0,analysis,vType);
        return;
      }
      let cobb=session.metrics.cobbAngleDeg;
      if(cobb==null||!Number.isFinite(cobb)) cobb=0;
      let absCobb=Math.abs(cobb);
      if(absCobb < COBB_NOISE_FLOOR_DEG){ cobb=0; absCobb=0; }
      session.metrics.cobbAngleDeg=cobb;
      session.metrics.curveMaxDeviationNorm=analysis.maxDeviationNorm;
      session.metrics.curveCategory=computeCurveCategory(absCobb,analysis,vType);
    }

    function drawSkeleton(ctx,kpC,viewType){
      if(!toggleSkeleton.checked||!kpC) return;
      ctx.save();
      function drawSegment(a,b,color,width=3){
        if(!a||!b) return;
        ctx.strokeStyle=color; ctx.lineWidth=width;
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
      }
      const vt=viewType||"non determinata";
      const shoulderColor=vt==="posteriore"?"rgba(248,113,113,0.95)":"rgba(148,163,184,0.95)";
      const ribColor=vt==="posteriore"?"rgba(248,250,252,0.9)":"rgba(59,130,246,0.9)";

      drawSegment(kpC.leftShoulder,kpC.rightShoulder,shoulderColor);
      drawSegment(kpC.leftHip,kpC.rightHip,"rgba(248,113,113,0.9)");
      drawSegment(kpC.leftShoulder,kpC.leftHip,"rgba(148,163,184,0.7)",2);
      drawSegment(kpC.rightShoulder,kpC.rightHip,"rgba(148,163,184,0.7)",2);
      drawSegment(kpC.shoulderMid,kpC.pelvisCenter,"rgba(148,163,184,0.6)",2);
      drawSegment(kpC.headCenter,kpC.neckBase,"rgba(148,163,184,0.9)",2);

      if(kpC.ribsLeft && kpC.ribsRight){
        ctx.strokeStyle=ribColor; ctx.lineWidth=2; ctx.fillStyle=ribColor;
        for(let i=0;i<kpC.ribsLeft.length;i++){
          const L=kpC.ribsLeft[i], R=kpC.ribsRight[i];
          if(!L||!R) continue;
          ctx.beginPath(); ctx.moveTo(L.x,L.y); ctx.lineTo(R.x,R.y); ctx.stroke();
          ctx.beginPath(); ctx.arc(L.x,L.y,3,0,Math.PI*2); ctx.arc(R.x,R.y,3,0,Math.PI*2); ctx.fill();
        }
      }
      if(kpC.sternum){
        ctx.fillStyle="rgba(56,189,248,0.95)";
        ctx.beginPath(); ctx.arc(kpC.sternum.x,kpC.sternum.y,5,0,Math.PI*2); ctx.fill();
      }
      if(kpC.clavSegments){
        for(const seg of kpC.clavSegments) drawSegment(seg.start, seg.end, "rgba(56,189,248,0.9)", 3);
      }
      if(kpC.scmSegments){
        for(const seg of kpC.scmSegments) drawSegment(seg.start, seg.end, "rgba(251,191,36,0.9)", 2);
      }
      ctx.fillStyle="rgba(56,189,248,0.95)";
      const pts=[kpC.headCenter,kpC.neckBase,kpC.shoulderMid,kpC.leftShoulder,kpC.rightShoulder,kpC.leftHip,kpC.rightHip,kpC.pelvisCenter];
      for(const p of pts){ if(!p) continue; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
    }

    function emphasizedSpinePoints(session){
      const pts=session.spineSpline;
      if(!pts||!pts.length) return null;
      const lambda=curveLambda;
      let sumX=0; pts.forEach(p=>sumX+=p.x);
      const cx=sumX/pts.length;
      return pts.map(p=>({ x: cx + lambda*(p.x-cx), y:p.y }));
    }

    function drawManualPointOverlay(ctx,session){
      if(!session.manualPoints||session.manualPoints.length===0) return;
      ctx.save();
      ctx.strokeStyle="rgba(251,191,36,0.9)";
      ctx.lineWidth=2;
      ctx.fillStyle="rgba(251,191,36,0.95)";
      const pts=session.manualPoints;
      if(pts.length>=2){
        ctx.beginPath();
        pts.forEach((p,idx)=>{ if(idx===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
        ctx.stroke();
      }
      for(const p of pts){ ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
    }

    function drawSpineAndHeadCentering(ctx,session){
      if(!toggleSpine.checked){ drawManualPointOverlay(ctx,session); return; }
      const kp=session.keypointsCanonical;
      if(!kp){ drawManualPointOverlay(ctx,session); return; }
      ctx.save();
      const emphasised=emphasizedSpinePoints(session);
      const ca=session.curveAnalysis;
      const isNoise=ca && ca.curveIsNoise;

      if(emphasised && emphasised.length>=2){
        ctx.lineWidth=3;
        if(isNoise){
          ctx.strokeStyle="rgba(148,163,184,0.6)";
          ctx.setLineDash([5,4]);
        } else {
          ctx.strokeStyle="rgba(56,189,248,0.95)";
          ctx.setLineDash([]);
        }
        ctx.beginPath();
        emphasised.forEach((p,idx)=>{ if(idx===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle=isNoise ? "rgba(148,163,184,0.7)" : "rgba(56,189,248,0.85)";
        for(let i=0;i<emphasised.length;i+=3){
          const p=emphasised[i];
          ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill();
        }
      }

      const pelvis=kp.pelvisCenter;
      const head=kp.headCenter;

      if(pelvis){
        ctx.setLineDash([6,4]);
        ctx.lineWidth=1.5;
        ctx.strokeStyle="rgba(148,163,184,0.7)";
        ctx.beginPath(); ctx.moveTo(pelvis.x,pelvis.y-350); ctx.lineTo(pelvis.x,pelvis.y+30); ctx.stroke();
        ctx.setLineDash([]);
      }
      if(head && kp.sternum){
        ctx.strokeStyle="rgba(248,250,252,0.9)";
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(head.x,head.y); ctx.lineTo(kp.sternum.x,kp.sternum.y); ctx.stroke();
      }
      if(pelvis && head){
        const dx=head.x-pelvis.x;
        ctx.fillStyle="rgba(248,250,252,0.95)";
        ctx.font="12px system-ui";
        ctx.fillText(`offset testa/bacino ‚âà ${dx.toFixed(1)} px`, pelvis.x+12, pelvis.y-12);
      }
      ctx.restore();
      drawManualPointOverlay(ctx,session);
    }

    function drawVectorField(ctx, baseline, current){
      if(!toggleVectors.checked||!baseline||!current) return;
      ctx.save();
      ctx.lineWidth=2;
      ctx.strokeStyle="rgba(52,211,153,0.95)";
      ctx.fillStyle="rgba(52,211,153,0.95)";
      const keys=["headCenter","neckBase","shoulderMid","leftShoulder","rightShoulder","leftHip","rightHip","pelvisCenter"];
      for(const k of keys){
        const b=baseline[k], c=current[k]; if(!b||!c) continue;
        const dx=(c.x-b.x), dy=(c.y-b.y);
        const len=Math.hypot(dx,dy);
        if(len<1) continue;
        const x0=b.x,y0=b.y,x1=x0+dx,y1=y0+dy;
        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
        const angle=Math.atan2(dy,dx);
        const ah=7;
        const leftX=x1-ah*Math.cos(angle-Math.PI/6);
        const leftY=y1-ah*Math.sin(angle-Math.PI/6);
        const rightX=x1-ah*Math.cos(angle+Math.PI/6);
        const rightY=y1-ah*Math.sin(angle+Math.PI/6);
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(leftX,leftY); ctx.lineTo(rightX,rightY); ctx.closePath(); ctx.fill();
      }
      ctx.restore();
    }

    function updateMetricRow(session){
      if(!session||!session.metrics){ metricRow.innerHTML=""; return; }
      const m=session.metrics;
      const fmt=(v)=> (v==null||Number.isNaN(v)) ? "‚Äî" : Number(v).toFixed(2);
      const vType=getEffectiveViewType(session);
      const sourceLabel=session.spineSource==="manual"?"manuale":session.spineSource==="learned"?"appresa":"automatica";
      metricRow.innerHTML = `
        <div><strong>Vista:</strong> ${vType}</div>
        <div><strong>Sorgente colonna:</strong> ${sourceLabel}</div>
        <div><strong>Categoria curva:</strong> ${m.curveCategory || "‚Äî"}</div>
        <div><strong>Dev. max curva (norm.):</strong> ${fmt(m.curveMaxDeviationNorm)} u.n.</div>
        <div><strong>Tilt spalle:</strong> ${fmt(m.shoulderTiltDeg)}¬∞</div>
        <div><strong>Tilt bacino:</strong> ${fmt(m.pelvisTiltDeg)}¬∞</div>
        <div><strong>Tilt testa (vs verticale):</strong> ${fmt(m.headAxisDeg)}¬∞</div>
        <div><strong>Angolo di Cobb:</strong> ${fmt(m.cobbAngleDeg)}¬∞</div>
        <div><strong>Offset testa/bacino:</strong> ${fmt(m.headPelvisOffsetNorm)} u.n.</div>
        <div><strong>Offset testa/sterno:</strong> ${fmt(m.headSternumOffsetNorm)} u.n.</div>
        <div><strong>Rot. bacino (depth):</strong> ${fmt(m.pelvisDepthRotDiff)} Œîu</div>
        <div><strong>Lunghezza tronco:</strong> ${fmt(m.torsoLengthPx)} px</div>
      `;
    }

    function highlightFileItem(index){
      const items=fileListEl.querySelectorAll(".file-item");
      items.forEach(el=>el.classList.remove("active"));
      const active=fileListEl.querySelector(`.file-item[data-idx="${index}"]`);
      if(active) active.classList.add("active");
    }

    function renderSession(index){
      const session=sessions[index];
      if(!session || !session.keypointsCanonical || !session.transform) { updateNavUI(); return; }
      if(manualMode && session.keypointsCanonical) ensureManualControlPoints(session);

      mainCtx.clearRect(0,0,mainCanvas.width,mainCanvas.height);
      drawImageWithTransform(mainCtx, session.img, session.transform);

      const vType=getEffectiveViewType(session);
      drawSkeleton(mainCtx, session.keypointsCanonical, vType);
      drawSpineAndHeadCentering(mainCtx, session);

      const baseline=sessions[0];
      if(baseline && baseline.keypointsCanonical && index>0){
        drawVectorField(mainCtx, baseline.keypointsCanonical, session.keypointsCanonical);
      }

      updateMetricRow(session);
      highlightFileItem(index);
      updateNavUI();
    }

    // Charts theme helpers
    function chartTheme(){
      const dark = (document.documentElement.getAttribute("data-theme")||"dark")==="dark";
      return {
        tick: dark ? "#9aa4b2" : "#64748b",
        grid: dark ? "rgba(148,163,184,0.22)" : "rgba(15,23,42,0.10)",
        legend: dark ? "#e5e7eb" : "#0f172a"
      };
    }

    function updateCharts(){
      if(!sessions.length) return;
      const labels=sessions.map((s,i)=>`${i+1}`);

      const shoulders=sessions.map(s=>s.metrics?.shoulderTiltDeg ?? null);
      const pelvis=sessions.map(s=>s.metrics?.pelvisTiltDeg ?? null);
      const headAxis=sessions.map(s=>s.metrics?.headAxisDeg ?? null);
      const cobb=sessions.map(s=>s.metrics?.cobbAngleDeg ?? null);

      const headPelvis=sessions.map(s=>s.metrics?.headPelvisOffsetNorm ?? null);
      const headSternum=sessions.map(s=>s.metrics?.headSternumOffsetNorm ?? null);

      const th=chartTheme();

      const anglesCtx=document.getElementById("chartAngles").getContext("2d");
      if(!anglesChart){
        anglesChart = new Chart(anglesCtx,{
          type:"line",
          data:{ labels, datasets:[
            { label:"Tilt spalle (¬∞)", data:shoulders, tension:0.3 },
            { label:"Tilt bacino (¬∞)", data:pelvis, tension:0.3 },
            { label:"Tilt testa vs verticale (¬∞)", data:headAxis, tension:0.3 },
            { label:"Cobb (¬∞)", data:cobb, tension:0.3 }
          ]},
          options:{
            responsive:true,
            plugins:{ legend:{ labels:{ color: th.legend, font:{ size: 10 } } } },
            scales:{
              x:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } },
              y:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } }
            }
          }
        });
      } else {
        anglesChart.data.labels=labels;
        anglesChart.data.datasets[0].data=shoulders;
        anglesChart.data.datasets[1].data=pelvis;
        anglesChart.data.datasets[2].data=headAxis;
        anglesChart.data.datasets[3].data=cobb;
        anglesChart.options.plugins.legend.labels.color=th.legend;
        anglesChart.options.scales.x.ticks.color=th.tick;
        anglesChart.options.scales.y.ticks.color=th.tick;
        anglesChart.options.scales.x.grid.color=th.grid;
        anglesChart.options.scales.y.grid.color=th.grid;
        anglesChart.update();
      }

      const offsetsCtx=document.getElementById("chartOffsets").getContext("2d");
      if(!offsetsChart){
        offsetsChart = new Chart(offsetsCtx,{
          type:"line",
          data:{ labels, datasets:[
            { label:"Offset testa/bacino (norm.)", data:headPelvis, tension:0.3 },
            { label:"Offset testa/sterno (norm.)", data:headSternum, tension:0.3 }
          ]},
          options:{
            responsive:true,
            plugins:{ legend:{ labels:{ color: th.legend, font:{ size: 10 } } } },
            scales:{
              x:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } },
              y:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } }
            }
          }
        });
      } else {
        offsetsChart.data.labels=labels;
        offsetsChart.data.datasets[0].data=headPelvis;
        offsetsChart.data.datasets[1].data=headSternum;
        offsetsChart.options.plugins.legend.labels.color=th.legend;
        offsetsChart.options.scales.x.ticks.color=th.tick;
        offsetsChart.options.scales.y.ticks.color=th.tick;
        offsetsChart.options.scales.x.grid.color=th.grid;
        offsetsChart.options.scales.y.grid.color=th.grid;
        offsetsChart.update();
      }
    }

    function updateModelChart(){
      const canvas=document.getElementById("chartModel");
      if(!canvas) return;
      const ctx=canvas.getContext("2d");
      const labels=modelErrorHistory.map((_,i)=>`${i+1}`);
      const data=modelErrorHistory;
      const th=chartTheme();

      if(!modelChart){
        modelChart=new Chart(ctx,{
          type:"line",
          data:{ labels, datasets:[{ label:"Errore medio offset (RMSE)", data, tension:0.3 }] },
          options:{
            responsive:true,
            plugins:{ legend:{ labels:{ color: th.legend, font:{ size: 10 } } } },
            scales:{
              x:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } },
              y:{ ticks:{ color: th.tick, font:{ size: 9 } }, grid:{ color: th.grid } }
            }
          }
        });
      } else {
        modelChart.data.labels=labels;
        modelChart.data.datasets[0].data=data;
        modelChart.options.plugins.legend.labels.color=th.legend;
        modelChart.options.scales.x.ticks.color=th.tick;
        modelChart.options.scales.y.ticks.color=th.tick;
        modelChart.options.scales.x.grid.color=th.grid;
        modelChart.options.scales.y.grid.color=th.grid;
        modelChart.update();
      }
      updateNavUI();
    }

    // Training/model helpers (come tuo, invariati dove possibile)
    function evaluateModelOnce(examples){
      if(examples.length<2) return 0;
      const errors=[], kBase=3;
      for(let i=0;i<examples.length;i++){
        const ex=examples[i];
        const feat=ex.features;
        const trueOffsets=ex.offsets;
        const distArr=[];
        for(let j=0;j<examples.length;j++){
          if(j===i) continue;
          const ex2=examples[j];
          const f2=ex2.features;
          let s=0;
          const len=Math.min(feat.length,f2.length);
          for(let t=0;t<len;t++){ const d=(feat[t]||0)-(f2[t]||0); s+=d*d; }
          distArr.push({idx:j, dist:Math.sqrt(s)});
        }
        if(!distArr.length) continue;
        distArr.sort((a,b)=>a.dist-b.dist);
        const k=Math.min(kBase, distArr.length);
        const neighbors=distArr.slice(0,k);
        const weights=neighbors.map(n=>1/(n.dist+1e-6));
        const sumW=weights.reduce((s,w)=>s+w,0)||1;
        const predOffsets=new Array(SPINE_SAMPLES).fill(0);
        for(let j=0;j<SPINE_SAMPLES;j++){
          let num=0;
          for(let t=0;t<k;t++){
            const ex2=examples[neighbors[t].idx];
            const w=weights[t];
            num += (ex2.offsets[j]||0)*w;
          }
          predOffsets[j]=num/sumW;
        }
        let seSum=0,count=0;
        for(let j=0;j<SPINE_SAMPLES;j++){
          const diff=(predOffsets[j]||0)-(trueOffsets[j]||0);
          seSum+=diff*diff; count++;
        }
        if(count>0) errors.push(Math.sqrt(seSum/count));
      }
      if(!errors.length) return 0;
      return errors.reduce((s,e)=>s+e,0)/errors.length;
    }

    function recomputeModelErrorHistory(){
      modelErrorHistory=[];
      for(let n=1;n<=trainingExamples.length;n++){
        const subset=trainingExamples.slice(0,n);
        modelErrorHistory.push(evaluateModelOnce(subset));
      }
      updateModelChart();
    }

    function computeFeatureVector(session){
      const m=session.metrics||{};
      const v=[ m.shoulderTiltDeg||0, m.pelvisTiltDeg||0, m.headAxisDeg||0, m.headPelvisOffsetNorm||0, m.headSternumOffsetNorm||0, m.pelvisDepthRotDiff||0 ];
      return v.map(x => (x==null||Number.isNaN(x)) ? 0 : x);
    }

    function saveTrainingExamples(){
      try{ localStorage.setItem("scoliosisTraining_v2", JSON.stringify(trainingExamples)); }catch(e){}
    }
    function loadTrainingExamples(){
      try{
        const raw=localStorage.getItem("scoliosisTraining_v2");
        if(!raw) return;
        const arr=JSON.parse(raw);
        if(Array.isArray(arr)){
          trainingExamples=arr.filter(ex=>Array.isArray(ex.features)&&Array.isArray(ex.offsets)&&ex.offsets.length===SPINE_SAMPLES);
          if(trainingExamples.length) recomputeModelErrorHistory();
        }
      }catch(e){}
      updateNavUI();
    }

    function predictOffsetsFromModel(session){
      if(!trainingExamples.length) return null;
      const feat=computeFeatureVector(session);
      const k=Math.min(3,trainingExamples.length);
      const distArr=trainingExamples.map((ex,idx)=>{
        const f=ex.features||[];
        const len=Math.min(f.length, feat.length);
        let s=0;
        for(let i=0;i<len;i++){ const d=(feat[i]||0)-(f[i]||0); s+=d*d; }
        return { idx, dist:Math.sqrt(s) };
      });
      distArr.sort((a,b)=>a.dist-b.dist);
      const neighbors=distArr.slice(0,k);
      const weights=neighbors.map(n=>1/(n.dist+1e-6));
      const sumW=weights.reduce((s,w)=>s+w,0)||1;
      const offsets=new Array(SPINE_SAMPLES).fill(0);
      for(let j=0;j<SPINE_SAMPLES;j++){
        let num=0;
        for(let t=0;t<neighbors.length;t++){
          const ex=trainingExamples[neighbors[t].idx];
          const w=weights[t];
          num += (ex.offsets[j]||0)*w;
        }
        offsets[j]=num/sumW;
      }
      return offsets;
    }

    function applyOffsetsToSessionSpine(session, offsets){
      const kpC=session.keypointsCanonical;
      if(!kpC||!kpC.pelvisCenter) return;
      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid||pelvisC;
      const torsoVec={x:headC.x-pelvisC.x,y:headC.y-pelvisC.y};
      const torsoLenC=Math.hypot(torsoVec.x,torsoVec.y)||1;
      const nx=-torsoVec.y/torsoLenC, ny=torsoVec.x/torsoLenC;
      const pts=[];
      for(let i=0;i<SPINE_SAMPLES;i++){
        const hi=i/(SPINE_SAMPLES-1);
        const off=offsets[i]||0;
        const baseX=pelvisC.x+torsoVec.x*hi;
        const baseY=pelvisC.y+torsoVec.y*hi;
        pts.push({ x: baseX + nx*off*torsoLenC, y: baseY + ny*off*torsoLenC });
      }
      session.spineSpline=pts;
      session.spineSource="learned";
    }

    function rebuildSpineFromControlPoints(session){
      if(!session.manualPoints||session.manualPoints.length===0) return;
      const kpC=session.keypointsCanonical;
      if(!kpC||!kpC.pelvisCenter) return;
      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid||pelvisC;
      const torsoVec={x:headC.x-pelvisC.x,y:headC.y-pelvisC.y};
      const torsoLenC=Math.hypot(torsoVec.x,torsoVec.y)||1;
      const nx=-torsoVec.y/torsoLenC, ny=torsoVec.x/torsoLenC;
      const ctrlSamples=[];
      const nCtrl=session.manualPoints.length;
      for(let i=0;i<nCtrl;i++){
        const hi=i/(nCtrl-1);
        const baseX=pelvisC.x+torsoVec.x*hi;
        const baseY=pelvisC.y+torsoVec.y*hi;
        const p=session.manualPoints[i];
        const off=(p.x-baseX)/torsoLenC;
        ctrlSamples.push({hi,off});
      }
      ctrlSamples.sort((a,b)=>a.hi-b.hi);
      const hiGrid=[]; for(let i=0;i<SPINE_SAMPLES;i++) hiGrid.push(i/(SPINE_SAMPLES-1));
      const offsets=[]; let idx=0;
      for(const hg of hiGrid){
        while(idx<ctrlSamples.length-1 && ctrlSamples[idx+1].hi<hg) idx++;
        if(idx===ctrlSamples.length-1) offsets.push(ctrlSamples[ctrlSamples.length-1].off);
        else{
          const d0=ctrlSamples[idx], d1=ctrlSamples[idx+1];
          const t=(d1.hi===d0.hi) ? 0 : (hg-d0.hi)/(d1.hi-d0.hi);
          offsets.push(d0.off + (d1.off-d0.off)*t);
        }
      }
      const spinePts=[];
      for(let i=0;i<SPINE_SAMPLES;i++){
        const hi=hiGrid[i], off=offsets[i];
        const baseX=pelvisC.x+torsoVec.x*hi;
        const baseY=pelvisC.y+torsoVec.y*hi;
        spinePts.push({ x: baseX + nx*off*torsoLenC, y: baseY + ny*off*torsoLenC });
      }
      session.spineSpline=spinePts;
      session.manualOffsets=offsets;
      session.spineSource="manual";
      if(session.metrics) postProcessCurveMetrics(session);

      // snap points
      session.manualPoints=session.manualPoints.map((p,i)=>{
        const hi=i/(nCtrl-1);
        const baseX=pelvisC.x+torsoVec.x*hi;
        const baseY=pelvisC.y+torsoVec.y*hi;
        const off=ctrlSamples[i].off;
        return { x: baseX + nx*off*torsoLenC, y: baseY + ny*off*torsoLenC };
      });
    }

    function ensureManualControlPoints(session){
      if(!session.keypointsCanonical||!session.keypointsCanonical.pelvisCenter) return;
      if(session.manualPoints && session.manualPoints.length===CONTROL_POINTS) return;
      const kpC=session.keypointsCanonical;
      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid||pelvisC;
      const torsoVec={x:headC.x-pelvisC.x,y:headC.y-pelvisC.y};
      const spine=session.spineSpline;
      session.manualPoints=[];
      for(let i=0;i<CONTROL_POINTS;i++){
        const hi=i/(CONTROL_POINTS-1);
        let pInit=null;
        if(spine && spine.length>=2){
          const idx=Math.round(hi*(spine.length-1));
          pInit=spine[idx];
        }
        if(!pInit){
          const baseX=pelvisC.x+torsoVec.x*hi;
          const baseY=pelvisC.y+torsoVec.y*hi;
          pInit={x:baseX,y:baseY};
        }
        session.manualPoints.push({x:pInit.x,y:pInit.y});
      }
      rebuildSpineFromControlPoints(session);
    }

    function saveManualExampleCurrentSession(){
      const s=sessions[currentIndex];
      if(!s||!s.manualOffsets||!s.metrics){
        setStatus("Per salvare un esempio: attiva punti manuali e modifica almeno un punto.", true);
        return;
      }
      trainingExamples.push({ features: computeFeatureVector(s), offsets: s.manualOffsets.slice() });
      saveTrainingExamples();
      recomputeModelErrorHistory();
      setStatus(`Esempio manuale salvato. Totale esempi: ${trainingExamples.length}.`, false);
      reapplyLearnedModelToAllSessions();
    }

    function reapplyLearnedModelToAllSessions(){
      if(!sessions.length) return;
      if(!enableLearning.checked || trainingExamples.length < 3) return;
      for(const s of sessions){
        if(!s.metrics||!s.keypointsCanonical) continue;
        if(s.spineSource==="manual") continue;
        const offsets=predictOffsetsFromModel(s);
        if(!offsets) continue;
        applyOffsetsToSessionSpine(s, offsets);
        const pelvisTilt=s.metrics.pelvisTiltDeg;
        const headAxis=s.metrics.headAxisDeg;
        const cobbAngle=estimateCobbAngle(pelvisTilt, headAxis, s.spineSpline);
        s.metrics.cobbAngleDeg = cobbAngle ?? null;
        postProcessCurveMetrics(s);
      }
      updateCharts();
      buildTechnicalReport();
      renderSession(currentIndex);
      setStatus("Modello riapplicato a tutte le immagini.", false);
    }

    function recomputeSpineForSession(session){
      if(!session||!session.keypointsCanonical||!session.metrics) return;
      if(session.spineSource==="manual"){ renderSession(currentIndex); return; }
      const vType=getEffectiveViewType(session);
      const spineC=estimateSpineCanonical(session.keypointsCanonical, vType);
      session.spineCanonical=spineC;
      session.spineSource="auto";
      session.spineSpline = spineC ? computeSpineSpline(spineC.basePoints, SPINE_SAMPLES).points : null;
      const pelvisTilt=session.metrics.pelvisTiltDeg;
      const headAxis=session.metrics.headAxisDeg;
      const cobbAngle=estimateCobbAngle(pelvisTilt, headAxis, session.spineSpline);
      session.metrics.cobbAngleDeg=cobbAngle ?? null;
      postProcessCurveMetrics(session);
    }

    async function estimateDepthMap(session){
      if(!depthEstimator || !depthReady) return null;
      try{
        const depthNS = globalThis.depthEstimation || window.depthEstimation;
        if(!depthNS) return null;
        const estimationConfig={ minDepth:0.2, maxDepth:0.9, flipHorizontal:false };
        const depthMap = await depthEstimator.estimateDepth(session.img, estimationConfig);
        return await depthMap.toArray();
      }catch(err){ return null; }
    }
    function sampleDepthAtImagePoint(depthMap,img,pt,radius=2){
      if(!depthMap||!pt) return null;
      const h=depthMap.length, w=depthMap[0].length;
      const xNorm=pt.x/img.naturalWidth, yNorm=pt.y/img.naturalHeight;
      const cx=Math.round(xNorm*(w-1)), cy=Math.round(yNorm*(h-1));
      let sum=0,count=0;
      for(let j=-radius;j<=radius;j++){
        for(let i=-radius;i<=radius;i++){
          const xx=cx+i, yy=cy+j;
          if(xx<0||xx>=w||yy<0||yy>=h) continue;
          sum+=depthMap[yy][xx]; count++;
        }
      }
      return count? (sum/count) : null;
    }
    function computePelvisDepthRotationDiff(session){
      if(!session.depthMap||!session.keypoints2D) return null;
      const dL=sampleDepthAtImagePoint(session.depthMap, session.img, session.keypoints2D.leftHip, 3);
      const dR=sampleDepthAtImagePoint(session.depthMap, session.img, session.keypoints2D.rightHip, 3);
      if(dL==null||dR==null) return null;
      return dR - dL;
    }

    // Report (arricchito con paziente + date/note)
    function describeTowardZero(name, baseline, last, unit, threshold){
      if(baseline==null||last==null||!Number.isFinite(baseline)||!Number.isFinite(last)) return null;
      const abs0=Math.abs(baseline), abs1=Math.abs(last);
      const deltaAbs=abs1-abs0;
      if(Math.abs(deltaAbs)<threshold) return `‚Ä¢ ${name}: variazione minima (da ${baseline.toFixed(2)}${unit} a ${last.toFixed(2)}${unit}).`;
      if(deltaAbs<0) return `‚Ä¢ ${name}: <strong>miglioramento</strong> (da ${baseline.toFixed(2)}${unit} a ${last.toFixed(2)}${unit}).`;
      return `‚Ä¢ ${name}: <strong>peggioramento</strong> (da ${baseline.toFixed(2)}${unit} a ${last.toFixed(2)}${unit}).`;
    }

    function buildTechnicalReport(){
      if(!sessions.length || !sessions[0].metrics){
        reportPanel.innerHTML = `<h3 style="margin:0 0 6px;">Report tecnico automatico</h3><p style="margin:0;color:var(--muted);font-weight:700;">Analizza le immagini per generare il report.</p>`;
        return;
      }
      if(sessions.length<2){
        reportPanel.innerHTML = `<h3 style="margin:0 0 6px;">Report tecnico automatico</h3><p style="margin:0;color:var(--muted);font-weight:700;">Servono almeno due sessioni per confrontare l‚Äôevoluzione.</p>`;
        return;
      }

      const patient=readPatient();
      const first=sessions[0], last=sessions[sessions.length-1];
      const m0=first.metrics, m1=last.metrics;
      const items=[];
      const cat0=m0.curveCategory||"non valutabile";
      const cat1=m1.curveCategory||"non valutabile";
      items.push(`‚Ä¢ Classificazione curva (inizio ‚Üí fine): <strong>${cat0}</strong> ‚Üí <strong>${cat1}</strong>.`);

      const sShoulders=describeTowardZero("Inclinazione spalle", m0.shoulderTiltDeg, m1.shoulderTiltDeg, "¬∞", 1); if(sShoulders) items.push(sShoulders);
      const sPelvis=describeTowardZero("Inclinazione bacino", m0.pelvisTiltDeg, m1.pelvisTiltDeg, "¬∞", 1); if(sPelvis) items.push(sPelvis);
      const sHead=describeTowardZero("Tilt testa vs verticale", m0.headAxisDeg, m1.headAxisDeg, "¬∞", 1); if(sHead) items.push(sHead);
      const sCobb=describeTowardZero("Cobb (stima)", m0.cobbAngleDeg, m1.cobbAngleDeg, "¬∞", 1); if(sCobb) items.push(sCobb);
      const sHP=describeTowardZero("Centratura testa/bacino", m0.headPelvisOffsetNorm, m1.headPelvisOffsetNorm, "", 0.02); if(sHP) items.push(sHP);
      const sHS=describeTowardZero("Centratura testa/sterno", m0.headSternumOffsetNorm, m1.headSternumOffsetNorm, "", 0.02); if(sHS) items.push(sHS);
      const sRot=describeTowardZero("Rotazione bacino (depth)", m0.pelvisDepthRotDiff, m1.pelvisDepthRotDiff, "", 0.02); if(sRot) items.push(sRot);

      const metaLine = (s)=> {
        const parts=[];
        if(s.dateISO) parts.push(s.dateISO);
        if(s.note) parts.push(s.note);
        return parts.length ? ` <span style="color:var(--muted);font-weight:700;">(${parts.join(" ‚Ä¢ ")})</span>` : "";
      };

      reportPanel.innerHTML = `
        <h3 style="margin:0 0 6px;">Report tecnico automatico</h3>
        <div style="color:var(--muted);font-weight:800;line-height:1.35;">
          <div><strong>Paziente:</strong> ${patient.id ? patient.id + " ‚Ä¢ " : ""}${patient.name || "‚Äî"} ${patient.dob ? "‚Ä¢ " + patient.dob : ""} ${patient.sex ? "‚Ä¢ " + patient.sex : ""}</div>
          ${patient.note ? `<div><strong>Nota:</strong> ${patient.note}</div>` : ""}
          <div style="margin-top:6px;"><strong>Baseline:</strong> ${first.fileName}${metaLine(first)}</div>
          <div><strong>Ultima:</strong> ${last.fileName}${metaLine(last)}</div>
        </div>
        <ul style="margin:10px 0 0;padding-left:18px;color:var(--muted);font-weight:700;line-height:1.35;">
          ${items.map(t=>`<li>${t}</li>`).join("")}
        </ul>
        <p style="margin:10px 0 0;color:var(--muted);font-weight:700;line-height:1.35;">
          <em>Nota clinica:</em> Cobb e curve sono stime su foto. Gli angoli sono normalizzati in ¬±90¬∞.
          Il training usa esempi manuali per migliorare la ricostruzione delle curve su casi simili.
        </p>
      `;
    }

    // File list UI (thumbnail + data + note + view override + delete confirm)
    function rebuildFileList(){
      fileListEl.innerHTML="";
      updateNavUI();
      sessions.forEach((s,idx)=>{
        const row=document.createElement("div");
        row.className="file-item";
        row.dataset.idx=String(idx);
        const autoLabel = (s.viewTypeAuto && s.viewTypeAuto!=="non determinata") ? `Auto (${s.viewTypeAuto})` : "Auto (?)";

        row.innerHTML = `
          <div class="thumb" style="background-image:url('${s.objectUrl || ""}')"></div>
          <div class="file-main">
            <div class="file-name" title="${s.fileName}">${idx+1}. ${s.fileName}</div>
            <div class="file-meta">
              <span class="chip">${autoLabel}</span>
              <input id="date_${idx}" type="date" value="${s.dateISO||""}" style="height:32px;padding:.3rem .5rem;" />
              <select class="view-select" style="height:32px;">
                <option value="auto">Auto</option>
                <option value="frontale">Frontale</option>
                <option value="posteriore">Posteriore</option>
                <option value="laterale">Laterale</option>
              </select>
            </div>
            <div class="file-meta" style="margin-top:2px;">
              <input id="note_${idx}" placeholder="Nota (opz.)" value="${(s.note||"").replaceAll('"',"&quot;")}"
                     style="width:100%;min-width:180px;height:32px;padding:.3rem .5rem;" />
            </div>
          </div>
          <div class="file-controls">
            <div class="mini-row">
              <button class="mini-btn up" title="Sposta su">‚Üë</button>
              <button class="mini-btn down" title="Sposta gi√π">‚Üì</button>
            </div>
            <button class="mini-btn mini-danger del" title="Rimuovi">‚úï</button>
          </div>
        `;

        row.addEventListener("click",(ev)=>{
          const t=ev.target;
          if(t.matches("button, select, input")) return;
          currentIndex=idx;
          renderSession(currentIndex);
        });

        fileListEl.appendChild(row);

        const upBtn=row.querySelector(".up");
        const downBtn=row.querySelector(".down");
        const delBtn=row.querySelector(".del");
        const viewSelect=row.querySelector(".view-select");
        const dateInput=row.querySelector(`#date_${idx}`);
        const noteInput=row.querySelector(`#note_${idx}`);

        // view select
        viewSelect.options[0].textContent = autoLabel;
        viewSelect.value = s.viewTypeOverride ? s.viewTypeOverride : "auto";
        viewSelect.title = `Vista riconosciuta: ${s.viewTypeAuto||"non determinata"}`;

        upBtn.addEventListener("click",(e)=>{ e.stopPropagation(); moveSession(idx,-1); });
        downBtn.addEventListener("click",(e)=>{ e.stopPropagation(); moveSession(idx, 1); });

        delBtn.addEventListener("click", async (e)=>{
          e.stopPropagation();
          const ok=await confirmAsync(`Rimuovere ‚Äú${s.fileName}‚Äù?`);
          if(!ok) return;
          removeSession(idx);
        });

        viewSelect.addEventListener("click",(e)=>e.stopPropagation());
        viewSelect.addEventListener("change",(e)=>{
          const val=e.target.value;
          if(val==="auto") s.viewTypeOverride=null;
          else s.viewTypeOverride=val;
          setStatus(`Vista per ${s.fileName}: ${getEffectiveViewType(s)}.`, false);
          if(s.keypointsCanonical && s.metrics){
            recomputeSpineForSession(s);
            updateCharts();
            buildTechnicalReport();
            renderSession(currentIndex);
          }
        });

        dateInput.addEventListener("click",(e)=>e.stopPropagation());
        dateInput.addEventListener("change",()=>{
          s.dateISO = dateInput.value || "";
          saveSessionsMeta();
          buildTechnicalReport();
        });
        noteInput.addEventListener("click",(e)=>e.stopPropagation());
        noteInput.addEventListener("input",()=>{
          s.note = noteInput.value || "";
          saveSessionsMeta();
        });
      });
      highlightFileItem(currentIndex);
      updateNavUI();
    }

    function saveSessionsMeta(){
      try{
        localStorage.setItem("scoliosisSessionsMeta_v2", JSON.stringify(sessions.map(x=>({fileName:x.fileName,dateISO:x.dateISO||"",note:x.note||""}))));
      }catch{}
    }
    function loadSessionsMeta(){
      try{
        const raw=localStorage.getItem("scoliosisSessionsMeta_v2");
        if(!raw) return new Map();
        const arr=JSON.parse(raw);
        const m=new Map();
        if(Array.isArray(arr)){
          for(const it of arr){
            if(it && it.fileName) m.set(it.fileName, { dateISO: it.dateISO||"", note: it.note||"" });
          }
        }
        return m;
      }catch{ return new Map(); }
    }

    function moveSession(oldIndex, delta){
      const newIndex=oldIndex+delta;
      if(newIndex<0||newIndex>=sessions.length) return;
      const [item]=sessions.splice(oldIndex,1);
      sessions.splice(newIndex,0,item);
      sessions.forEach((s,i)=>s.index=i);
      currentIndex=newIndex;
      rebuildFileList();
      updateCharts();
      renderSession(currentIndex);
      saveSessionsMeta();
    }

    function removeSession(idx){
      if(idx<0||idx>=sessions.length) return;
      const s=sessions[idx];
      if(s?.objectUrl) URL.revokeObjectURL(s.objectUrl);
      sessions.splice(idx,1);
      if(!sessions.length){
        currentIndex=0;
        mainCtx.clearRect(0,0,mainCanvas.width,mainCanvas.height);
        metricRow.innerHTML="";
        reportPanel.innerHTML=`<h3 style="margin:0 0 6px;">Report tecnico automatico</h3><p style="margin:0;color:var(--muted);font-weight:700;">Analizza le immagini per generare il report.</p>`;
      }else{
        if(currentIndex>=sessions.length) currentIndex=sessions.length-1;
      }
      sessions.forEach((s,i)=>s.index=i);
      rebuildFileList();
      updateCharts();
      buildTechnicalReport();
      if(sessions.length) renderSession(currentIndex);
      updateAnalyzeButton();
      setStatus(sessions.length ? "Foto rimossa." : "Tutte le foto rimosse.", false);
      saveSessionsMeta();
    }

    function updateAnalyzeButton(){
      analyzeBtn.disabled = !(modelReady && imagesReady && sessions.length>0);
    }

    // Load image with object URL (fix memory leaks)
    function loadImageFile(file){
      return new Promise((resolve,reject)=>{
        const img=new Image();
        const url=URL.createObjectURL(file);
        img.onload=()=>resolve({ file, img, url });
        img.onerror=(e)=>{ URL.revokeObjectURL(url); reject(e); };
        img.src=url;
      });
    }

    // Core analyze
    async function analyzeAllSessions(){
      if(!poseLandmarker || !sessions.length) return;
      analyzeBtn.disabled=true;
      setStatus("Analisi in corso...", false);
      showBusy("Analisi immagini in corso...",0);

      for(let i=0;i<sessions.length;i++){
        const s=sessions[i];
        try{
          const result=poseLandmarker.detect(s.img);
          if(!result||!result.landmarks||!result.landmarks.length) continue;
          const landmarks=result.landmarks[0];
          s.landmarks=landmarks;

          const kp=extractKeypoints(landmarks, s.img.naturalWidth, s.img.naturalHeight);
          s.keypoints2D=kp;

          s.viewTypeAuto=detectPoseOrientation(landmarks,kp);
          s.viewType=s.viewTypeAuto;

          const transform=computeAlignmentTransform(kp,s.img);
          s.transform=transform;

          const kpC={};
          Object.keys(kp).forEach((k)=>{ if(!kp[k]) return; kpC[k]=transformPoint(kp[k],transform); });

          const repere=computeDetailedCanonicalRepere(kpC);
          kpC.ribsLeft=repere.ribsLeft; kpC.ribsRight=repere.ribsRight; kpC.ribsMid=repere.ribsMid;
          kpC.sternum=repere.sternum; kpC.clavSegments=repere.clavSegments; kpC.scmSegments=repere.scmSegments;

          s.keypointsCanonical=kpC;

          const spineC=estimateSpineCanonical(kpC, s.viewTypeAuto);
          s.spineCanonical=spineC;
          s.spineSource="auto";
          s.spineSpline = spineC ? computeSpineSpline(spineC.basePoints, SPINE_SAMPLES).points : null;

          s.depthMap = await estimateDepthMap(s);

          const shoulderTilt=angleOfLineDeg(kp.leftShoulder,kp.rightShoulder);
          const pelvisTilt=angleOfLineDeg(kp.leftHip,kp.rightHip);

          let headAxisDeg=null;
          if(kp.headCenter && (kp.neckBase||kp.shoulderMid)){
            headAxisDeg=headTiltRelativeVerticalDeg(kp.headCenter, kp.neckBase||kp.shoulderMid);
          }

          const torsoLength=distance(kp.neckBase||kp.shoulderMid, kp.pelvisCenter);
          const headPelvisOffset = (kp.headCenter && kp.pelvisCenter) ? kp.headCenter.x-kp.pelvisCenter.x : null;
          const headSternumOffset = (kp.headCenter && kp.shoulderMid) ? kp.headCenter.x-kp.shoulderMid.x : null;

          const pelvisDepthRotDiff=computePelvisDepthRotationDiff(s);

          if(s.manualPoints && s.manualPoints.length===CONTROL_POINTS){
            rebuildSpineFromControlPoints(s);
          }else if(enableLearning.checked && trainingExamples.length>=3){
            const learnedOffsets=predictOffsetsFromModel(s);
            if(learnedOffsets) applyOffsetsToSessionSpine(s, learnedOffsets);
          }

          const cobbAngle=estimateCobbAngle(pelvisTilt, headAxisDeg, s.spineSpline);

          s.metrics={
            shoulderTiltDeg: shoulderTilt,
            pelvisTiltDeg: pelvisTilt,
            headAxisDeg: headAxisDeg,
            cobbAngleDeg: cobbAngle ?? null,
            maxSpineAngleDeg: spineC?.maxAngleLocal ?? null,
            torsoLengthPx: torsoLength || 0,
            headPelvisOffsetNorm: torsoLength && headPelvisOffset!=null ? headPelvisOffset/torsoLength : null,
            headSternumOffsetNorm: torsoLength && headSternumOffset!=null ? headSternumOffset/torsoLength : null,
            pelvisDepthRotDiff: pelvisDepthRotDiff,
            curveMaxDeviationNorm: null,
            curveCategory: "non valutabile"
          };

          postProcessCurveMetrics(s);

          updateBusy(`Analisi foto ${i+1}/${sessions.length}...`, (i+1)/sessions.length);
        }catch(err){
          console.error(err);
          setStatus("Errore durante l'analisi di una o pi√π immagini.", true);
        }
      }

      updateCharts();
      currentIndex=0;
      rebuildFileList();
      renderSession(currentIndex);
      analyzeBtn.disabled=false;
      buildTechnicalReport();
      setTimeout(hideBusy, 250);
      setStatus("Analisi completata.", false);
    }

    // File input change (caricamento immagini + restore metadati)
    fileInput.addEventListener("change", async (e)=>{
      const files=Array.from(e.target.files||[]);
      // cleanup old URLs
      sessions.forEach(s=>{ if(s.objectUrl) URL.revokeObjectURL(s.objectUrl); });

      sessions=[];
      reportPanel.innerHTML = `<h3 style="margin:0 0 6px;">Report tecnico automatico</h3><p style="margin:0;color:var(--muted);font-weight:700;">Analizza le immagini per generare il report.</p>`;

      if(!files.length){
        imagesReady=false; updateAnalyzeButton();
        fileListEl.innerHTML="";
        mainCtx.clearRect(0,0,mainCanvas.width,mainCanvas.height);
        setStatus("Nessun file selezionato.", false);
        updateNavUI();
        return;
      }

      files.sort((a,b)=>a.name.localeCompare(b.name,"it",{numeric:true}));
      setStatus("Carico immagini...", false);

      const metaMap = loadSessionsMeta();

      try{
        const loaded=await Promise.all(files.map(loadImageFile));
        sessions = loaded.map((obj,idx)=>{
          const oldMeta = metaMap.get(obj.file.name);
          return {
            index: idx,
            fileName: obj.file.name,
            img: obj.img,
            objectUrl: obj.url,
            dateISO: oldMeta?.dateISO || inferDateFromFilename(obj.file.name),
            note: oldMeta?.note || "",
            landmarks: null,
            keypoints2D: null,
            keypointsCanonical: null,
            spineCanonical: null,
            spineSpline: null,
            transform: null,
            depthMap: null,
            metrics: null,
            viewTypeAuto: "non determinata",
            viewTypeOverride: null,
            viewType: "non determinata",
            manualPoints: null,
            manualOffsets: null,
            spineSource: "auto"
          };
        });

        imagesReady=true;
        rebuildFileList();
        updateAnalyzeButton();
        setStatus("Immagini caricate. Premi Analizza per procedere.", false);
        updateNavUI();
        saveSessionsMeta();
      }catch(err){
        console.error(err);
        imagesReady=false;
        updateAnalyzeButton();
        setStatus("Errore nel caricamento immagini.", true);
      }
    });

    clearBtn.addEventListener("click", async ()=>{
      if(sessions.length){
        const ok = await confirmAsync("Svuotare tutte le immagini e i risultati correnti?");
        if(!ok) return;
      }
      sessions.forEach(s=>{ if(s.objectUrl) URL.revokeObjectURL(s.objectUrl); });
      fileInput.value="";
      sessions=[];
      imagesReady=false;
      updateAnalyzeButton();
      fileListEl.innerHTML="";
      mainCtx.clearRect(0,0,mainCanvas.width,mainCanvas.height);
      metricRow.innerHTML="";
      reportPanel.innerHTML = `<h3 style="margin:0 0 6px;">Report tecnico automatico</h3><p style="margin:0;color:var(--muted);font-weight:700;">Analizza le immagini per generare il report.</p>`;
      setStatus("Pulito. Carica nuove foto per iniziare.", false);
      updateCharts();
      updateNavUI();
      try{ localStorage.removeItem("scoliosisSessionsMeta_v2"); }catch{}
    });

    analyzeBtn.addEventListener("click",()=>analyzeAllSessions());

    [toggleSkeleton,toggleSpine,toggleVectors].forEach(el=>el.addEventListener("change",()=>renderSession(currentIndex)));

    lambdaSlider.addEventListener("input",()=>{
      curveLambda=parseFloat(lambdaSlider.value);
      lambdaValue.textContent=curveLambda.toFixed(1);
      renderSession(currentIndex);
    });

    toggleManualBtn.addEventListener("click",()=>{
      manualMode=!manualMode;
      if(manualMode){
        lambdaBackup=curveLambda;
        curveLambda=1;
        lambdaSlider.value="1";
        lambdaValue.textContent="1.0";
        lambdaSlider.disabled=true;

        toggleManualBtn.textContent="Punti manuali: ON";
        toggleManualBtn.classList.add("active-manual");
        const s=sessions[currentIndex];
        if(s && s.keypointsCanonical) ensureManualControlPoints(s);
        setStatus("Modalit√† punti manuali: Œª fissato a 1. Trascina i marcatori.", false);
      }else{
        toggleManualBtn.textContent="Punti manuali: OFF";
        toggleManualBtn.classList.remove("active-manual");
        lambdaSlider.disabled=false;
        curveLambda=parseFloat(lambdaBackup)||2.5;
        lambdaSlider.value=String(curveLambda);
        lambdaValue.textContent=curveLambda.toFixed(1);
        setStatus("Modalit√† punti manuali disattivata.", false);
      }
      renderSession(currentIndex);
    });

    undoPointBtn.addEventListener("click",()=>{
      const s=sessions[currentIndex];
      if(!s||!s.manualPoints||!s.manualPoints.length) return;
      if(lastDraggedIndex<0||lastDraggedIndex>=s.manualPoints.length) return;
      const kpC=s.keypointsCanonical;
      if(!kpC||!kpC.pelvisCenter) return;

      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid||pelvisC;
      const torsoVec={x:headC.x-pelvisC.x,y:headC.y-pelvisC.y};

      const idx=lastDraggedIndex;
      const hi=idx/(s.manualPoints.length-1);
      const baseX=pelvisC.x+torsoVec.x*hi;
      const baseY=pelvisC.y+torsoVec.y*hi;

      s.manualPoints[idx]={x:baseX,y:baseY};
      rebuildSpineFromControlPoints(s);
      renderSession(currentIndex);
    });

    clearManualBtn.addEventListener("click",()=>{
      const s=sessions[currentIndex];
      if(!s||!s.keypointsCanonical) return;
      s.manualPoints=null;
      s.manualOffsets=null;
      s.spineSource="auto";
      if(s.spineCanonical) s.spineSpline = computeSpineSpline(s.spineCanonical.basePoints, SPINE_SAMPLES).points;
      else s.spineSpline=null;
      lastDraggedIndex=-1;
      postProcessCurveMetrics(s);
      renderSession(currentIndex);
      setStatus("Punti manuali raddrizzati (ritorno ad auto).", false);
    });

    saveExampleBtn.addEventListener("click",()=>saveManualExampleCurrentSession());

    enableLearning.addEventListener("change",()=>{
      if(enableLearning.checked){
        reapplyLearnedModelToAllSessions();
      }else{
        for(const s of sessions){
          if(s.spineSource==="learned"){
            s.spineSource="auto";
            if(s.spineCanonical) s.spineSpline=computeSpineSpline(s.spineCanonical.basePoints,SPINE_SAMPLES).points;
          }
          if(s.metrics) postProcessCurveMetrics(s);
        }
        updateCharts(); buildTechnicalReport(); renderSession(currentIndex);
        setStatus("Uso modello appreso disattivato.", false);
      }
    });

    // Manual drag
    function endDrag(){ if(isDraggingControl){ isDraggingControl=false; draggingControlIndex=-1; } }
    function pointerToCanvasCoords(evt){
      const rect=mainCanvas.getBoundingClientRect();
      const scaleX=mainCanvas.width/rect.width;
      const scaleY=mainCanvas.height/rect.height;
      return { x:(evt.clientX-rect.left)*scaleX, y:(evt.clientY-rect.top)*scaleY };
    }
    mainCanvas.addEventListener("pointerdown",(e)=>{
      if(!manualMode||!sessions.length) return;
      const s=sessions[currentIndex];
      if(!s||!s.manualPoints||!s.manualPoints.length) return;
      const {x,y}=pointerToCanvasCoords(e);
      const pts=s.manualPoints;
      let bestIdx=-1,bestDist=Infinity;
      for(let i=0;i<pts.length;i++){
        const dist=Math.hypot(pts[i].x-x, pts[i].y-y);
        if(dist<bestDist){ bestDist=dist; bestIdx=i; }
      }
      if(bestIdx!==-1 && bestDist<18){
        isDraggingControl=true;
        draggingControlIndex=bestIdx;
        lastDraggedIndex=bestIdx;
        e.preventDefault();
      }
    });
    mainCanvas.addEventListener("pointermove",(e)=>{
      if(!isDraggingControl||!sessions.length) return;
      const s=sessions[currentIndex];
      if(!s||!s.manualPoints||!s.manualPoints.length) return;
      const {x}=pointerToCanvasCoords(e);

      const kpC=s.keypointsCanonical;
      if(!kpC||!kpC.pelvisCenter) return;

      const pelvisC=kpC.pelvisCenter;
      const headC=kpC.headCenter||kpC.neckBase||kpC.shoulderMid||pelvisC;
      const torsoVec={x:headC.x-pelvisC.x,y:headC.y-pelvisC.y};

      const idx=draggingControlIndex;
      const hi=idx/(s.manualPoints.length-1);
      const baseY=pelvisC.y+torsoVec.y*hi;

      s.manualPoints[idx]={ x, y: baseY };
      rebuildSpineFromControlPoints(s);
      renderSession(currentIndex);
      e.preventDefault();
    });
    mainCanvas.addEventListener("pointerup",endDrag);
    mainCanvas.addEventListener("pointercancel",endDrag);
    mainCanvas.addEventListener("pointerleave",endDrag);

    // Model export/import
    downloadModelBtn?.addEventListener("click",()=>{
      try{
        const blob=new Blob([JSON.stringify(trainingExamples,null,2)],{type:"text/plain;charset=utf-8"});
        const url=URL.createObjectURL(blob);
        const a=document.createElement("a");
        a.href=url; a.download="scoliosis_model.txt";
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
        toast("Modello esportato.","info");
      }catch(err){ setStatus("Errore durante l'esportazione del modello.", true); }
    });
    modelFileInput?.addEventListener("change",(e)=>{
      const file=e.target.files?.[0];
      if(!file) return;
      const reader=new FileReader();
      reader.onload=(ev)=>{
        try{
          const arr=JSON.parse(ev.target.result);
          if(!Array.isArray(arr)) throw new Error("Formato non valido");
          trainingExamples=arr.filter(ex=>Array.isArray(ex.features)&&Array.isArray(ex.offsets)&&ex.offsets.length===SPINE_SAMPLES);
          saveTrainingExamples();
          recomputeModelErrorHistory();
          toast(`Modello caricato. Esempi: ${trainingExamples.length}.`,"info");
          reapplyLearnedModelToAllSessions();
        }catch(err){ setStatus("Errore nel formato del modello (txt/json).", true); }
      };
      reader.readAsText(file);
    });

    // Init MediaPipe + depth
    async function initPoseLandmarker(){
      try{
        setStatus("Carico modello MediaPipe Pose...", false);
        const vision=await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
        poseLandmarker=await PoseLandmarker.createFromOptions(vision,{
          baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task" },
          runningMode:"IMAGE",
          numPoses:1
        });
        modelReady=true;
        setStatus("Modello pose caricato. Carica le foto e premi Analizza.", false);
        updateAnalyzeButton();
      }catch(err){
        console.error(err);
        setStatus("Errore nel caricare il modello MediaPipe Pose.", true);
      }
    }
    async function initDepthEstimator(){
      try{
        const depthNS = globalThis.depthEstimation || window.depthEstimation;
        if(!depthNS) return;
        depthEstimator=await depthNS.createEstimator(depthNS.SupportedModels.ARPortraitDepth);
        depthReady=true;
      }catch(err){}
    }

    loadTrainingExamples();
    initPoseLandmarker();
    initDepthEstimator();
    updateNavUI();
  </script>
</body>
</html>

        setStatus("Errore nel caricare il modello MediaPipe Pose.", true);
      }
    }
    async function initDepthEstimator(){
      try{
        const depthNS = globalThis.depthEstimation || window.depthEstimation;
        if(!depthNS) return;
        depthEstimator=await depthNS.createEstimator(depthNS.SupportedModels.ARPortraitDepth);
        depthReady=true;
      }catch(err){}
    }

    loadTrainingExamples();
    initPoseLandmarker();
    initDepthEstimator();
    updateNavUI();
  </script>
</body>
</html>
