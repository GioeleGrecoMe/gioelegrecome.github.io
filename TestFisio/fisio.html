<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Analisi Evolutiva Scoliosi – Mobile Friendly</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chart.js per i grafici -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- TensorFlow.js + Depth Estimation (AR Portrait Depth, usata solo per metrica bacino) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/depth-estimation"></script>

<style>
  :root{
    --bg: #f6f8fb;
    --bg2:#eef2f7;
    --panel:#ffffff;
    --panel2:#ffffff;
    --text:#0f172a;
    --muted:#64748b;
    --border: rgba(15,23,42,.10);
    --shadow: 0 18px 55px rgba(15,23,42,.10);
    --shadow2: 0 10px 30px rgba(15,23,42,.08);

    --accent:#0ea5e9;
    --accent2:#0284c7;
    --accentSoft: rgba(14,165,233,.12);
    --ok:#10b981;
    --warn:#f59e0b;
    --danger:#ef4444;

    --r-xl: 22px;
    --r-lg: 16px;
    --r-md: 12px;
    --r-sm: 10px;

    --font: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
            "Segoe UI", Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }

  html[data-theme="dark"]{
    --bg:#0b1220;
    --bg2:#070d18;
    --panel:#0f172a;
    --panel2:#0b1325;
    --text:#e5e7eb;
    --muted:#9aa4b2;
    --border: rgba(148,163,184,.18);
    --shadow: 0 22px 65px rgba(0,0,0,.45);
    --shadow2: 0 10px 30px rgba(0,0,0,.35);

    --accent:#38bdf8;
    --accent2:#0ea5e9;
    --accentSoft: rgba(56,189,248,.12);
  }

  *{ box-sizing:border-box; }
  body{
    margin:0;
    font-family: var(--font);
    background: radial-gradient(1200px 600px at 20% -10%, rgba(14,165,233,.20), transparent 60%),
                radial-gradient(900px 450px at 90% 0%, rgba(16,185,129,.10), transparent 50%),
                linear-gradient(180deg, var(--bg), var(--bg2));
    color: var(--text);
  }

  a{ color:inherit; }
  .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }

  /* Topbar */
  .topbar{
    position: sticky;
    top:0;
    z-index: 50;
    backdrop-filter: blur(10px);
    background: color-mix(in oklab, var(--bg) 82%, transparent);
    border-bottom: 1px solid var(--border);
  }
  .topbar-inner{
    max-width: 1400px;
    margin:0 auto;
    padding: 14px 16px;
    display:flex;
    gap: 12px;
    align-items:center;
    justify-content: space-between;
  }
  .brand{
    display:flex;
    align-items:center;
    gap: 10px;
    min-width: 240px;
  }
  .brand-badge{
    width: 38px;
    height: 38px;
    border-radius: 12px;
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    box-shadow: 0 10px 26px rgba(14,165,233,.25);
    display:flex;
    align-items:center;
    justify-content:center;
    color: #00121f;
    font-weight: 800;
    letter-spacing: .02em;
  }
  html[data-theme="dark"] .brand-badge{ color:#06111f; }

  .brand h1{
    margin:0;
    font-size: 1.02rem;
    letter-spacing: .02em;
    line-height: 1.1;
  }
  .brand p{
    margin:0;
    font-size: .82rem;
    color: var(--muted);
    line-height: 1.25;
  }

  .top-actions{
    display:flex;
    align-items:center;
    gap: 8px;
    flex-wrap: wrap;
    justify-content:flex-end;
  }

  /* Buttons + inputs */
  button{
    border: 1px solid transparent;
    border-radius: 999px;
    padding: .58rem 1.0rem;
    font-size: .88rem;
    font-weight: 600;
    cursor: pointer;
    background: linear-gradient(180deg, var(--accent), var(--accent2));
    color: #04131f;
    box-shadow: 0 10px 26px rgba(14,165,233,.22);
    transition: transform .08s ease, box-shadow .12s ease, opacity .12s ease, background .12s ease;
    touch-action: manipulation;
  }
  button:hover:not(:disabled){
    transform: translateY(-1px);
    box-shadow: 0 14px 34px rgba(14,165,233,.26);
  }
  button:disabled{ opacity:.55; cursor: default; box-shadow:none; }
  .btn-secondary{
    background: color-mix(in oklab, var(--panel) 80%, transparent);
    color: var(--text);
    border-color: var(--border);
    box-shadow: var(--shadow2);
  }
  .btn-ghost{
    background: transparent;
    color: var(--text);
    border-color: var(--border);
    box-shadow:none;
  }
  .btn-danger{
    background: linear-gradient(180deg, #fb7185, #ef4444);
    color: #1a0206;
    box-shadow: 0 10px 26px rgba(239,68,68,.18);
  }
  .icon-btn{
    padding: .55rem .75rem;
    display:inline-flex;
    align-items:center;
    gap:.45rem;
  }

  input, select, textarea{
    font-family: var(--font);
    color: var(--text);
    background: color-mix(in oklab, var(--panel) 90%, transparent);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: .56rem .7rem;
    outline: none;
    transition: box-shadow .12s ease, border-color .12s ease;
  }
  input:focus, select:focus, textarea:focus{
    border-color: color-mix(in oklab, var(--accent) 60%, var(--border));
    box-shadow: 0 0 0 4px var(--accentSoft);
  }
  label{
    font-size: .78rem;
    color: var(--muted);
    font-weight: 600;
  }

  /* App shell */
  .app-shell{
    max-width: 1400px;
    margin: 16px auto;
    padding: 16px;
  }
  .grid{
    display:grid;
    grid-template-columns: minmax(0, 330px) minmax(0, 1.3fr) minmax(0, 420px);
    gap: 14px;
    align-items:start;
  }
  @media (max-width: 1120px){
    .grid{ grid-template-columns: 1fr; }
    .topbar-inner{ align-items:flex-start; }
    .brand{ min-width: unset; }
  }

  .panel{
    background: color-mix(in oklab, var(--panel) 92%, transparent);
    border: 1px solid var(--border);
    border-radius: var(--r-xl);
    box-shadow: var(--shadow2);
    padding: 14px;
    overflow:hidden;
  }
  .panel-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    margin-bottom: 10px;
  }
  .panel h2{
    margin:0;
    font-size: .98rem;
    letter-spacing:.01em;
  }
  .subtext{ margin:6px 0 0; color: var(--muted); font-size: .84rem; line-height:1.35; }

  /* Patient bar inside left panel */
  .patient-form{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 12px;
  }
  .patient-form .full{ grid-column: 1 / -1; }
  .patient-form .field{ display:flex; flex-direction:column; gap:6px; }

  /* Dropzone */
  .dropzone{
    border: 1.5px dashed color-mix(in oklab, var(--border) 70%, var(--muted));
    background: linear-gradient(180deg, color-mix(in oklab, var(--panel) 86%, transparent), color-mix(in oklab, var(--panel) 94%, transparent));
    border-radius: var(--r-lg);
    padding: 12px;
    display:flex;
    gap: 10px;
    align-items:center;
    justify-content: space-between;
    margin-top: 6px;
  }
  .dropzone.dragover{
    border-color: var(--accent);
    box-shadow: 0 0 0 5px var(--accentSoft);
  }
  .dropzone .dz-left{
    display:flex;
    flex-direction:column;
    gap: 4px;
  }
  .dropzone .dz-title{
    font-weight: 800;
    font-size: .9rem;
  }
  .dropzone .dz-hint{
    color: var(--muted);
    font-size: .82rem;
    line-height: 1.25;
  }
  input[type="file"]{
    width: 100%;
    margin-top: 8px;
  }

  /* Status */
  .status{
    margin-top: 10px;
    font-size: .85rem;
    color: var(--muted);
    min-height: 1.2rem;
  }
  .status.error{ color: var(--danger); font-weight: 700; }

  /* File list (thumbnail, meta) */
  .file-list{
    margin-top: 12px;
    display:flex;
    flex-direction:column;
    gap: 8px;
    max-height: 360px;
    overflow:auto;
    padding-right: 4px;
  }
  .file-item{
    display:grid;
    grid-template-columns: 56px 1fr auto;
    gap: 10px;
    align-items:center;
    padding: 10px;
    border-radius: 16px;
    border: 1px solid transparent;
    background: color-mix(in oklab, var(--panel2) 92%, transparent);
    cursor:pointer;
    transition: border-color .12s ease, transform .06s ease, background .12s ease;
  }
  .file-item:hover{
    border-color: color-mix(in oklab, var(--accent) 35%, var(--border));
    transform: translateY(-1px);
  }
  .file-item.active{
    border-color: var(--accent);
    box-shadow: 0 0 0 4px var(--accentSoft);
  }
  .thumb{
    width: 56px;
    height: 56px;
    border-radius: 14px;
    border: 1px solid var(--border);
    background-size: cover;
    background-position:center;
    background-color: color-mix(in oklab, var(--bg2) 70%, var(--panel));
  }
  .file-main{
    display:flex;
    flex-direction:column;
    gap: 6px;
    min-width:0;
  }
  .file-name{
    font-weight: 800;
    font-size: .86rem;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
  }
  .file-meta{
    display:flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items:center;
  }
  .chip{
    font-size: .72rem;
    color: var(--muted);
    border: 1px solid var(--border);
    background: color-mix(in oklab, var(--panel) 85%, transparent);
    padding: .18rem .5rem;
    border-radius: 999px;
  }
  .file-controls{
    display:flex;
    flex-direction:column;
    gap: 6px;
    align-items:flex-end;
  }
  .mini-row{
    display:flex;
    gap: 6px;
    align-items:center;
  }
  .mini-btn{
    padding: .2rem .5rem;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--muted);
    font-weight: 800;
    box-shadow:none;
  }
  .mini-btn:hover{ border-color: var(--accent); color: var(--text); }
  .mini-danger{ border-color: color-mix(in oklab, var(--danger) 60%, var(--border)); color: color-mix(in oklab, var(--danger) 70%, var(--text)); }
  .mini-danger:hover{ border-color: var(--danger); color: var(--danger); }

  /* Viewer */
  #mainCanvas{
    width: 100%;
    max-height: 70vh;
    border-radius: var(--r-xl);
    border: 1px solid var(--border);
    background: radial-gradient(700px 350px at 10% 0%, var(--accentSoft), transparent 55%),
                linear-gradient(180deg, color-mix(in oklab, var(--panel) 75%, transparent), color-mix(in oklab, var(--panel) 92%, transparent));
    box-shadow: var(--shadow2);
    touch-action: none;
  }

  .viewer-toolbar{
    display:flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items:center;
    justify-content: space-between;
    margin-top: 10px;
  }
  .viewer-nav{
    display:flex;
    gap: 8px;
    align-items:center;
    flex: 1 1 280px;
  }
  .viewer-nav input[type="range"]{ width: 100%; accent-color: var(--accent); }
  .viewer-toggles{
    display:flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items:center;
    justify-content:flex-end;
  }
  .toggle{
    display:inline-flex;
    gap: 8px;
    align-items:center;
    color: var(--muted);
    font-size: .84rem;
    font-weight: 700;
  }
  .toggle input{ accent-color: var(--accent); }

  /* Right side tabs */
  .tabs{
    display:flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 10px;
  }
  .tab-btn{
    border-radius: 999px;
    padding: .45rem .8rem;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--muted);
    font-weight: 900;
    box-shadow:none;
  }
  .tab-btn.active{
    background: var(--accentSoft);
    border-color: color-mix(in oklab, var(--accent) 55%, var(--border));
    color: var(--text);
  }
  .tab-panel{ display:none; }
  .tab-panel.active{ display:block; }

  .chart-container{
    margin-top: 10px;
    background: color-mix(in oklab, var(--panel2) 95%, transparent);
    border: 1px solid var(--border);
    border-radius: var(--r-lg);
    padding: 10px;
  }
  .chart-container h3{
    margin:0 0 8px 0;
    font-size: .88rem;
    color: var(--muted);
  }

  /* Manual block */
  .manual-row{
    margin-top: 12px;
    border: 1px solid var(--border);
    background: color-mix(in oklab, var(--panel2) 94%, transparent);
    border-radius: var(--r-lg);
    padding: 10px;
  }
  .manual-row strong{
    display:block;
    margin-bottom: 6px;
    font-size: .86rem;
  }
  .manual-controls{ display:flex; gap: 8px; flex-wrap: wrap; align-items:center; }
  .manual-controls button{ margin:0; }

  .active-manual{
    border-color: color-mix(in oklab, var(--accent) 70%, var(--border)) !important;
    box-shadow: 0 0 0 4px var(--accentSoft);
  }

  .metric-row{
    margin-top: 12px;
    font-size: .85rem;
    color: var(--muted);
    display:grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 6px 12px;
  }
  .metric-row strong{ color: var(--text); }

  .hint{
    margin-top: 10px;
    font-size: .82rem;
    color: var(--muted);
    line-height: 1.4;
  }

  /* Overlay busy (riuso tuo) */
  .loading-overlay{
    position: fixed;
    inset: 0;
    background: rgba(2,6,23,0.62);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap: 12px;
    z-index: 9999;
    backdrop-filter: blur(10px);
  }
  html[data-theme="dark"] .loading-overlay{ background: rgba(2,6,23,0.78); }
  .loading-overlay.hidden{ display:none; }
  .spinner{
    width: 44px;
    height: 44px;
    border-radius: 999px;
    border: 3px solid rgba(148,163,184,0.35);
    border-top-color: var(--accent);
    animation: spin .8s linear infinite;
  }
  .busy-text{ color: #e2e8f0; font-weight: 800; text-align:center; padding:0 16px; }
  .progress-outer{
    width: 260px;
    max-width: 82vw;
    height: 9px;
    border-radius: 999px;
    background: rgba(15,23,42,0.55);
    border: 1px solid rgba(148,163,184,0.35);
    overflow:hidden;
  }
  .progress-inner{
    width:0%;
    height:100%;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    transition: width .18s ease;
  }
  @keyframes spin{ from{transform:rotate(0)} to{transform:rotate(360deg)} }

  /* Toast */
  .toast-host{
    position: fixed;
    right: 14px;
    bottom: 14px;
    display:flex;
    flex-direction:column;
    gap: 10px;
    z-index: 12000;
    max-width: min(420px, calc(100vw - 28px));
  }
  .toast{
    border-radius: 16px;
    border: 1px solid var(--border);
    background: color-mix(in oklab, var(--panel) 92%, transparent);
    box-shadow: var(--shadow);
    padding: 10px 12px;
    display:flex;
    gap: 10px;
    align-items:flex-start;
  }
  .toast .dot{
    width: 10px; height: 10px; border-radius:999px; margin-top: 5px;
    background: var(--accent);
    box-shadow: 0 0 0 4px var(--accentSoft);
    flex:0 0 auto;
  }
  .toast.warn .dot{ background: var(--warn); box-shadow: 0 0 0 4px rgba(245,158,11,.16); }
  .toast.error .dot{ background: var(--danger); box-shadow: 0 0 0 4px rgba(239,68,68,.16); }
  .toast .msg{ font-size: .88rem; color: var(--text); line-height:1.25; font-weight: 700; }
  .toast .sub{ font-size: .82rem; color: var(--muted); margin-top: 2px; font-weight: 600; }

  /* Confirm modal */
  .confirm-overlay{
    position: fixed;
    inset:0;
    background: rgba(2,6,23,.55);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index: 13000;
    padding: 16px;
    backdrop-filter: blur(10px);
  }
  .confirm-overlay.hidden{ display:none; }
  .confirm-card{
    width: min(520px, 100%);
    border-radius: 22px;
    border: 1px solid var(--border);
    background: color-mix(in oklab, var(--panel) 94%, transparent);
    box-shadow: var(--shadow);
    padding: 14px;
  }
  .confirm-card h3{ margin:0 0 6px; font-size: 1.02rem; }
  .confirm-card p{ margin:0; color: var(--muted); line-height:1.35; font-weight: 600; }
  .confirm-actions{ margin-top: 12px; display:flex; gap: 8px; justify-content:flex-end; flex-wrap:wrap; }

  /* Print (PDF) */
  @media print{
    .topbar, .toast-host, .confirm-overlay, #busyOverlay, .hint, .tabs, .manual-row, .viewer-toolbar { display:none !important; }
    body{ background: #fff !important; }
    .panel{ box-shadow:none !important; border: 1px solid #ddd !important; }
    .grid{ grid-template-columns: 1fr !important; }
    #mainCanvas{ max-height: none !important; }
  }
</style>

</head>
<body>
  <!-- INTRO OVERLAY -->
  <div id="introOverlay" class="intro-overlay">
    <div class="intro-card">
      <div class="intro-header">
        <div>
          <div class="intro-title">
            Analisi evolutiva scoliosi
            <span class="intro-pill">Guida rapida</span>
          </div>
          <p class="intro-subtitle">
            Pensata per smartphone: lavora con le foto del paziente nel tempo e
            visualizza graficamente curve scoliotiche, angoli e centrature testa–bacino,
            con riconoscimento automatico della vista (frontale/posteriore/laterale).
          </p>
        </div>
      </div>

      <ul class="intro-steps">
        <li>
          <span class="intro-step-badge">1</span>
          <div>
            <strong>Carica le foto</strong><br />
            Tocca <em>Seleziona immagini</em> e scegli più foto (fronte, schiena, profilo).
            Ordinale usando le frecce ↑/↓ (es. prima/dopo trattamento).
          </div>
        </li>
        <li>
          <span class="intro-step-badge">2</span>
          <div>
            <strong>Premi “Analizza tutte le foto”</strong><br />
            L’app riconosce automaticamente se la vista è frontale, posteriore o laterale,
            allinea testa–bacino, stima scheletro, curva della schiena (spline λ),
            angoli (spalle, bacino, testa) e un Cobb approssimato.
          </div>
        </li>
        <li>
          <span class="intro-step-badge">3</span>
          <div>
            <strong>Correggi la vista se serve</strong><br />
            Se il riconoscimento è errato, usa il menu a tendina accanto alla foto
            (Auto / Frontale / Posteriore / Laterale): la curva viene ricalcolata
            usando punti di repere diversi (costato/sterno davanti, scapole/fluttuanti
            dietro, linea ear–spalla–bacino di lato).
          </div>
        </li>
        <li>
          <span class="intro-step-badge">4</span>
          <div>
            <strong>Rifinisci la curva manualmente</strong><br />
            Attiva <em>Punti manuali</em>: compaiono 10 punti tra bacino e testa.
            Trascinali orizzontalmente per seguire la curva scoliotica.
          </div>
        </li>
        <li>
          <span class="intro-step-badge">5</span>
          <div>
            <strong>Allena il modello</strong><br />
            Quando la curva è corretta, premi <em>Salva esempio</em>. Ad ogni nuovo
            esempio il modello si riallenza usando tutti i dati inseriti finora
            e aggiorna automaticamente la curva delle altre immagini.
          </div>
        </li>
        <li>
          <span class="intro-step-badge">6</span>
          <div>
            <strong>Leggi il report tecnico</strong><br />
            Nella colonna destra trovi un riepilogo automatico di miglioramenti /
            peggioramenti su spalle, bacino, testa, Cobb, centratura e rotazione del bacino.
          </div>
        </li>
      </ul>

      <p class="intro-subtitle">
        Su smartphone puoi scorrere in basso per vedere grafici e report.
        Usa due dita per fare scroll, non per zoomare sul canvas.
      </p>

      <div class="intro-actions">
        <button id="introStartBtn">Inizia analisi</button>
        <button id="introSkipBtn" class="secondary-btn">Salta (non mostrare più)</button>
      </div>
    </div>
  </div>

  <div class="app-shell">
    <header class="app-header">
      <h1>
        Analisi evolutiva scoliosi
        <span class="badge">Medico + Dev</span>
      </h1>
      <p>
        Carica le foto del paziente nel tempo, estrai automaticamente lo
        scheletro, la curva della schiena (spline λ) su un asse testa–bacino
        normalizzato, la profondità del bacino e un angolo di Cobb approssimato,
        con riconoscimento frontale/posteriore/laterale modificabile dall’utente.
      </p>
    </header>

    <main class="layout">
      <!-- Pannello sinistro -->
      <section class="panel">
        <h2><span class="step">1</span> Carica & ordina le foto</h2>
        <label for="fileInput">Seleziona più immagini (stesso paziente, vista frontale, posteriore o laterale):</label>
        <input id="fileInput" type="file" accept="image/*" multiple />
        <div>
          <button id="analyzeBtn" disabled>Analizza tutte le foto</button>
          <button id="clearBtn" class="secondary-btn">Svuota</button>
        </div>
        <div id="status" class="status-text"></div>

        <div class="file-list" id="fileList"></div>

        <p class="hint">
          Usa le frecce ↑ / ↓ accanto ad ogni foto per riordinarla (per data,
          pre/post trattamento, ecc.). Usa ✕ per rimuovere una foto. Dopo
          l’analisi, puoi correggere la vista (Auto/Frontale/Posteriore/Laterale)
          dal menu a tendina.
        </p>
      </section>

      <!-- Pannello centrale -->
      <section class="panel">
        <h2><span class="step">2</span> Visualizzazione sul corpo</h2>
        <canvas id="mainCanvas" width="600" height="800"></canvas>

        <div class="toggle-row">
          <label>
            <input type="checkbox" id="toggleSkeleton" checked />
            Scheletro + costato/clavicole/SCM
          </label>
          <label>
            <input type="checkbox" id="toggleSpine" checked />
            Curva schiena (spline λ)
          </label>
          <label>
            <input type="checkbox" id="toggleVectors" checked />
            Vettori di cambiamento
          </label>
        </div>

        <div class="lambda-row">
          <label for="lambdaSlider">
            Enfatizzazione curva (λ):
            <span class="value" id="lambdaValue">2.5</span>x
          </label>
          <input
            type="range"
            id="lambdaSlider"
            min="1"
            max="6"
            step="0.1"
            value="2.5"
          />
        </div>

        <div class="manual-row">
          <strong>Controlli manuali colonna & training adattivo</strong>
          <div class="manual-controls">
            <button id="toggleManualBtn" class="secondary-btn">Punti manuali: OFF</button>
            <button id="undoPointBtn" class="secondary-btn">Annulla ultimo spostamento</button>
            <button id="clearManualBtn" class="secondary-btn">Raddrizza punti</button>
          </div>
          <div class="manual-controls">
            <button id="saveExampleBtn">Salva esempio per training</button>
            <label>
              <input type="checkbox" id="enableLearning" checked />
              Usa modello appreso per tutte le immagini
            </label>
          </div>
          <p class="hint">
            Dopo l’analisi, attiva “Punti manuali”: compariranno 10 marcatori
            tra bacino (in basso) e testa (in alto). In questa modalità il
            parametro λ viene fissato a <strong>1</strong> per evitare distorsioni:
            trascina i punti <strong>solo a destra o sinistra</strong> per seguire
            la curva scoliotica. Ogni esempio salvato aggiorna il modello,
            che viene riapplicato a tutte le immagini analizzate.
          </p>
        </div>

        <div class="metric-row" id="metricRow"></div>

        <p class="hint">
          <strong>Angoli</strong>: spalle e bacino sono in ±90° rispetto all’orizzontale,
          la testa è in ±90° ma rispetto alla <strong>verticale</strong> (testa dritta ≈ 0°).
          Vista frontale/posteriore: la colonna usa bacino–costato–sterno–collo–testa
          (o scapole/fluttuanti dietro); vista laterale: bacino–mid-torace–collo–testa
          per una curva sagittale semplificata.
        </p>
      </section>

      <!-- Pannello destro -->
      <section class="panel">
        <h2><span class="step">3</span> Grafici, modello & report</h2>

        <div class="chart-container">
          <h3>Angoli spalle, bacino, testa, Cobb (±90°)</h3>
          <canvas id="chartAngles" height="140"></canvas>
        </div>

        <div class="chart-container">
          <h3>Centratura testa / bacino / “sterno”</h3>
          <canvas id="chartOffsets" height="140"></canvas>
        </div>

        <div class="chart-container">
          <h3>Apprendimento modello (errore medio curva)</h3>
          <canvas id="chartModel" height="120"></canvas>
        </div>

        <div class="manual-row" id="modelManagementRow">
          <strong>Modello appreso – salvataggio in txt</strong>
          <div class="manual-controls">
            <button id="downloadModelBtn" class="secondary-btn">Scarica modello (txt)</button>
            <label for="modelFileInput"
                   class="secondary-btn"
                   style="padding:0.3rem 0.7rem;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;">
              Carica modello (txt)
            </label>
            <input id="modelFileInput" type="file" accept=".txt,.json" style="display:none;" />
          </div>
          <p class="hint">
            Il modello (insieme degli esempi manuali + offset lungo la colonna)
            è salvato automaticamente nel browser. Puoi esportarlo come
            <code>scoliosis_model.txt</code> e ricaricarlo qui per riutilizzarlo
            in altre sessioni o su altri dispositivi.
          </p>
        </div>

        <div class="report-panel" id="reportPanel">
          <h3>Report tecnico automatico</h3>
          <p>Analizza le immagini per generare il report.</p>
        </div>
      </section>
    </main>
  </div>

  <!-- Overlay / waitbar globale -->
  <div id="busyOverlay" class="loading-overlay hidden">
    <div class="spinner"></div>
    <div id="busyText" class="busy-text">Elaborazione in corso...</div>
    <div class="progress-outer">
      <div id="busyProgress" class="progress-inner"></div>
    </div>
  </div>

  <script type="module">
    import {
      FilesetResolver,
      PoseLandmarker
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js";

    const PoseIdx = {
      NOSE: 0,
      LEFT_EYE: 2,
      RIGHT_EYE: 5,
      MOUTH_LEFT: 9,
      MOUTH_RIGHT: 10,
      LEFT_SHOULDER: 11,
      RIGHT_SHOULDER: 12,
      LEFT_HIP: 23,
      RIGHT_HIP: 24,
      LEFT_EAR: 7,
      RIGHT_EAR: 8
    };

    const SPINE_SAMPLES = 21;
    const CONTROL_POINTS = 10;
// --- NUOVE SOGLIE CLINICO-FOTOGRAMMETRICHE ---
// deviazione max laterale / lunghezza tronco < 2% = rumore
// 2–3.5% = asimmetria lieve; >=3.5% = curva significativa
const CURVE_NOISE_DEV_NORM = 0.02;   // 2%
const CURVE_SUSPECT_DEV_NORM = 0.035; // 3.5%

// soglie su "Cobb" stimato da foto (non radiografico!)
// < 5° -> trattato come 0°; 5–10° = asimmetria lieve; >=10° = sospetto scoliosi
const COBB_NOISE_FLOOR_DEG = 5;
const COBB_SUSPECT_DEG = 10;

    let poseLandmarker = null;
    let modelReady = false;
    let depthEstimator = null;
    let depthReady = false;
    let imagesReady = false;

    let sessions = [];
    let currentIndex = 0;
    let curveLambda = 2.5;
    let lambdaBackup = curveLambda;
    let anglesChart = null;
    let offsetsChart = null;
    let modelChart = null;
    let modelErrorHistory = [];

    // manuale & training
    let manualMode = false;
    let trainingExamples = []; // {features:[], offsets:[]}
    let isDraggingControl = false;
    let draggingControlIndex = -1;
    let lastDraggedIndex = -1;

    const fileInput = document.getElementById("fileInput");
    const analyzeBtn = document.getElementById("analyzeBtn");
    const clearBtn = document.getElementById("clearBtn");
    const statusEl = document.getElementById("status");
    const fileListEl = document.getElementById("fileList");
    const mainCanvas = document.getElementById("mainCanvas");
    const mainCtx = mainCanvas.getContext("2d");
    const metricRow = document.getElementById("metricRow");
    const reportPanel = document.getElementById("reportPanel");

    const toggleSkeleton = document.getElementById("toggleSkeleton");
    const toggleSpine = document.getElementById("toggleSpine");
    const toggleVectors = document.getElementById("toggleVectors");

    const lambdaSlider = document.getElementById("lambdaSlider");
    const lambdaValue = document.getElementById("lambdaValue");

    const toggleManualBtn = document.getElementById("toggleManualBtn");
    const undoPointBtn = document.getElementById("undoPointBtn");
    const clearManualBtn = document.getElementById("clearManualBtn");
    const saveExampleBtn = document.getElementById("saveExampleBtn");
    const enableLearning = document.getElementById("enableLearning");

    const downloadModelBtn = document.getElementById("downloadModelBtn");
    const modelFileInput = document.getElementById("modelFileInput");

    const busyOverlay = document.getElementById("busyOverlay");
    const busyText = document.getElementById("busyText");
    const busyProgress = document.getElementById("busyProgress");

    const introOverlay = document.getElementById("introOverlay");
    const introStartBtn = document.getElementById("introStartBtn");
    const introSkipBtn = document.getElementById("introSkipBtn");

    function getEffectiveViewType(session) {
      if (!session) return "non determinata";
      if (session.viewTypeOverride && session.viewTypeOverride !== "auto") {
        return session.viewTypeOverride;
      }
      return session.viewTypeAuto || session.viewType || "non determinata";
    }

    function showBusy(text = "Elaborazione in corso...", fraction = 0) {
      busyOverlay.classList.remove("hidden");
      busyText.textContent = text;
      busyProgress.style.width = `${Math.round(fraction * 100)}%`;
    }

    function updateBusy(text, fraction) {
      if (text) busyText.textContent = text;
      if (typeof fraction === "number") {
        busyProgress.style.width = `${Math.round(fraction * 100)}%`;
      }
    }

    function hideBusy() {
      busyOverlay.classList.add("hidden");
      busyProgress.style.width = "0%";
    }

    function hideIntroOverlay(permanent = false) {
      introOverlay.classList.add("hidden");
      if (permanent) {
        try {
          localStorage.setItem("scoliosisIntroSeen_v1", "1");
        } catch {}
      }
    }

    (function initIntroOverlay() {
      let seen = null;
      try {
        seen = localStorage.getItem("scoliosisIntroSeen_v1");
      } catch {}
      if (seen === "1") {
        introOverlay.classList.add("hidden");
      }
    })();

    if (introStartBtn) {
      introStartBtn.addEventListener("click", () => hideIntroOverlay(false));
    }
    if (introSkipBtn) {
      introSkipBtn.addEventListener("click", () => hideIntroOverlay(true));
    }

    function midpoint(a, b) {
      if (!a || !b) return null;
      return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2, z: (a.z + b.z) / 2 };
    }

    function averagePoints(points) {
      const valid = points.filter((p) => p);
      if (!valid.length) return null;
      const sum = valid.reduce(
        (acc, p) => {
          acc.x += p.x;
          acc.y += p.y;
          acc.z += p.z || 0;
          return acc;
        },
        { x: 0, y: 0, z: 0 }
      );
      return {
        x: sum.x / valid.length,
        y: sum.y / valid.length,
        z: sum.z / valid.length
      };
    }

    function distance(a, b) {
      if (!a || !b) return 0;
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function rad2deg(r) {
      return (r * 180) / Math.PI;
    }

    function normalizeAngle90(deg) {
      if (deg === null || deg === undefined || !Number.isFinite(deg)) return null;
      let a = deg;
      while (a <= -90) a += 180;
      while (a > 90) a -= 180;
      return a;
    }

    // angolo rispetto all'orizzontale (±90°)
    function angleOfLineDeg(p1, p2) {
      if (!p1 || !p2) return null;
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const raw = rad2deg(Math.atan2(dy, dx));
      return normalizeAngle90(raw);
    }

    // angolo TESTA rispetto alla VERTICALE (±90° con 0° = testa dritta)
    function headTiltRelativeVerticalDeg(head, neck) {
      if (!head || !neck) return null;
      const vx = head.x - neck.x;
      const vy = head.y - neck.y;
      const norm = Math.hypot(vx, vy) || 1;

      const ux = 0;
      const uy = -1;

      let cos = (vx * ux + vy * uy) / norm;
      cos = Math.min(1, Math.max(-1, cos));

      let angle = rad2deg(Math.acos(cos));
      if (angle > 90) angle = 180 - angle;

      const sign = vx >= 0 ? 1 : -1;
      return normalizeAngle90(angle * sign);
    }

    function angleBetweenVectorsDeg(v1, v2) {
      const dot = v1.x * v2.x + v1.y * v2.y;
      const n1 = Math.hypot(v1.x, v1.y);
      const n2 = Math.hypot(v2.x, v2.y);
      if (n1 === 0 || n2 === 0) return 0;
      let cos = dot / (n1 * n2);
      cos = Math.min(1, Math.max(-1, cos));
      return rad2deg(Math.acos(cos));
    }

    function computeAlignmentTransform(kp, img) {
      const pelvis = kp.pelvisCenter;
      const top = kp.headCenter || kp.neckBase || kp.shoulderMid;
      if (!pelvis || !top) {
        return {
          pelvis: { x: img.naturalWidth / 2, y: img.naturalHeight * 0.8 },
          rotation: 0,
          scale: 1,
          tx: mainCanvas.width / 2,
          ty: mainCanvas.height * 0.8
        };
      }

      const dx = top.x - pelvis.x;
      const dy = top.y - pelvis.y;
      const currentAngle = Math.atan2(dy, dx);
      const desiredAngle = -Math.PI / 2;
      const rotation = desiredAngle - currentAngle;

      const torsoLen = Math.max(distance(top, pelvis), 1);
      const desiredTorsoLen = mainCanvas.height * 0.5;
      const scale = desiredTorsoLen / torsoLen;

      const tx = mainCanvas.width / 2;
      const ty = mainCanvas.height * 0.8;

      return { pelvis, rotation, scale, tx, ty };
    }

    function transformPoint(p, transform) {
      const { pelvis, rotation, scale, tx, ty } = transform;
      const x0 = p.x - pelvis.x;
      const y0 = p.y - pelvis.y;
      const x1 = x0 * scale;
      const y1 = y0 * scale;
      const cosA = Math.cos(rotation);
      const sinA = Math.sin(rotation);
      const x2 = x1 * cosA - y1 * sinA;
      const y2 = x1 * sinA + y1 * cosA;
      return { x: x2 + tx, y: y2 + ty };
    }

    function drawImageWithTransform(ctx, image, transform) {
      const { pelvis, rotation, scale, tx, ty } = transform;
      ctx.save();
      ctx.translate(tx, ty);
      ctx.rotate(rotation);
      ctx.scale(scale, scale);
      ctx.translate(-pelvis.x, -pelvis.y);
      ctx.drawImage(image, 0, 0);
      ctx.restore();
    }

    function extractKeypoints(landmarks, width, height) {
      const p = (idx) => {
        const lm = landmarks[idx];
        if (!lm) return null;
        return {
          x: lm.x * width,
          y: lm.y * height,
          z: lm.z || 0,
          visibility: lm.visibility ?? 1
        };
      };

      const leftShoulder = p(PoseIdx.LEFT_SHOULDER);
      const rightShoulder = p(PoseIdx.RIGHT_SHOULDER);
      const leftHip = p(PoseIdx.LEFT_HIP);
      const rightHip = p(PoseIdx.RIGHT_HIP);
      const pelvisCenter = midpoint(leftHip, rightHip);
      const shoulderMid = midpoint(leftShoulder, rightShoulder);

      const leftEar = p(PoseIdx.LEFT_EAR);
      const rightEar = p(PoseIdx.RIGHT_EAR);
      const nose = p(PoseIdx.NOSE);
      const leftEye = p(PoseIdx.LEFT_EYE);
      const rightEye = p(PoseIdx.RIGHT_EYE);
      const mouthLeft = p(PoseIdx.MOUTH_LEFT);
      const mouthRight = p(PoseIdx.MOUTH_RIGHT);

      const headCenter = averagePoints([leftEar, rightEar, nose, leftEye, rightEye]);
      const neckBase = midpoint(shoulderMid, headCenter || shoulderMid);
      const midTorso = midpoint(shoulderMid, pelvisCenter);

      return {
        nose,
        leftEye,
        rightEye,
        mouthLeft,
        mouthRight,
        leftShoulder,
        rightShoulder,
        leftHip,
        rightHip,
        pelvisCenter,
        shoulderMid,
        headCenter,
        neckBase,
        midTorso,
        leftEar,
        rightEar
      };
    }

    // Riconoscimento vista: frontale / posteriore / laterale
    function detectPoseOrientation(landmarks, kp) {
      const ls = kp.leftShoulder;
      const rs = kp.rightShoulder;
      const pelvis = kp.pelvisCenter;
      const neck = kp.neckBase || kp.shoulderMid;
      if (!ls || !rs || !pelvis || !neck) return "non determinata";

      const torsoLen = distance(neck, pelvis) || 1;
      const shoulderWidth = Math.abs(ls.x - rs.x);
      const shoulderWidthNorm = shoulderWidth / torsoLen;

      if (shoulderWidthNorm < 0.25) {
        return "laterale";
      }

      const nose = landmarks[PoseIdx.NOSE];
      const le = landmarks[PoseIdx.LEFT_EYE];
      const re = landmarks[PoseIdx.RIGHT_EYE];
      const ml = landmarks[PoseIdx.MOUTH_LEFT];
      const mr = landmarks[PoseIdx.MOUTH_RIGHT];

      const faceVisible = [nose, le, re, ml, mr].filter(
        (l) => l && typeof l.visibility === "number"
      );
      let score = 0;
      if (faceVisible.length) {
        score =
          faceVisible.reduce((s, l) => s + l.visibility, 0) /
          faceVisible.length;
      }

      if (score > 0.35) {
        return "frontale";
      } else {
        return "posteriore";
      }
    }

    function computeDetailedCanonicalRepere(kpC) {
      const ribsLeft = [];
      const ribsRight = [];
      const ribsMid = [];
      const ribFracs = [0.15, 0.3, 0.45, 0.6, 0.75, 0.9];

      if (kpC.leftShoulder && kpC.leftHip && kpC.rightShoulder && kpC.rightHip) {
        for (const f of ribFracs) {
          const L = {
            x: kpC.leftShoulder.x + f * (kpC.leftHip.x - kpC.leftShoulder.x),
            y: kpC.leftShoulder.y + f * (kpC.leftHip.y - kpC.leftShoulder.y),
            z: 0
          };
          const R = {
            x: kpC.rightShoulder.x + f * (kpC.rightHip.x - kpC.rightShoulder.x),
            y: kpC.rightShoulder.y + f * (kpC.rightHip.y - kpC.rightShoulder.y),
            z: 0
          };
          ribsLeft.push(L);
          ribsRight.push(R);
          ribsMid.push(midpoint(L, R));
        }
      }

      let sternum = null;
      if (ribsMid.length) {
        sternum = ribsMid[0];
      } else if (kpC.shoulderMid && kpC.midTorso) {
        sternum = midpoint(kpC.shoulderMid, kpC.midTorso);
      } else {
        sternum = kpC.shoulderMid || kpC.neckBase || null;
      }

      const clavSegments = [];
      if (kpC.neckBase) {
        if (kpC.leftShoulder)
          clavSegments.push({ start: kpC.neckBase, end: kpC.leftShoulder });
        if (kpC.rightShoulder)
          clavSegments.push({ start: kpC.neckBase, end: kpC.rightShoulder });
      }

      const scmSegments = [];
      const leftMastoid = kpC.leftEar || kpC.headCenter;
      const rightMastoid = kpC.rightEar || kpC.headCenter;
      if (leftMastoid && sternum)
        scmSegments.push({ start: leftMastoid, end: sternum });
      if (rightMastoid && sternum)
        scmSegments.push({ start: rightMastoid, end: sternum });

      return { ribsLeft, ribsRight, ribsMid, sternum, clavSegments, scmSegments };
    }

    // Stima della colonna in base alla vista
    function estimateSpineCanonical(kpC, viewType) {
      const points = [];
      const vt = viewType || "non determinata";

      if (vt === "laterale") {
        if (kpC.pelvisCenter) points.push(kpC.pelvisCenter);
        if (kpC.midTorso) points.push(kpC.midTorso);
        if (kpC.neckBase || kpC.shoulderMid)
          points.push(kpC.neckBase || kpC.shoulderMid);
        if (kpC.headCenter) points.push(kpC.headCenter);
      } else if (vt === "posteriore") {
        if (kpC.pelvisCenter) points.push(kpC.pelvisCenter);
        if (kpC.ribsMid && kpC.ribsMid.length) {
          const sortedRibs = [...kpC.ribsMid].sort((a, b) => b.y - a.y);
          sortedRibs.forEach((p) => points.push(p));
        } else if (kpC.midTorso) {
          points.push(kpC.midTorso);
        }
        if (kpC.neckBase || kpC.shoulderMid)
          points.push(kpC.neckBase || kpC.shoulderMid);
        if (kpC.headCenter) points.push(kpC.headCenter);
      } else {
        // frontale o non determinata: bacino → costato → sterno → collo → testa
        if (kpC.pelvisCenter) points.push(kpC.pelvisCenter);
        if (kpC.ribsMid && kpC.ribsMid.length) {
          const sortedRibs = [...kpC.ribsMid].sort((a, b) => b.y - a.y);
          sortedRibs.forEach((p) => points.push(p));
        } else if (kpC.midTorso) {
          points.push(kpC.midTorso);
        }
        if (kpC.sternum) points.push(kpC.sternum);
        if (kpC.neckBase || kpC.shoulderMid)
          points.push(kpC.neckBase || kpC.shoulderMid);
        if (kpC.headCenter) points.push(kpC.headCenter);
      }

      if (points.length < 2) return null;

      const anglesLocal = [];
      for (let i = 1; i < points.length - 1; i++) {
        const v1 = {
          x: points[i].x - points[i - 1].x,
          y: points[i].y - points[i - 1].y
        };
        const v2 = {
          x: points[i + 1].x - points[i].x,
          y: points[i + 1].y - points[i].y
        };
        anglesLocal.push(angleBetweenVectorsDeg(v1, v2));
      }
      const maxAngle = anglesLocal.reduce(
        (acc, v) => Math.max(acc, Math.abs(v)),
        0
      );

      return { basePoints: points, maxAngleLocal: maxAngle };
    }

    function computeSpineSpline(basePoints, samples = SPINE_SAMPLES) {
      if (!basePoints || basePoints.length < 2) {
        return { points: null };
      }

      const n = basePoints.length;
      const pts = [];

      for (let i = 0; i < samples; i++) {
        const tGlobal = (i / (samples - 1)) * (n - 1);
        const i0 = Math.floor(tGlobal);
        const i1 = Math.min(n - 1, i0 + 1);
        const localT = tGlobal - i0;

        const p0 = basePoints[i0];
        const p1 = basePoints[i1];

        const x = p0.x + (p1.x - p0.x) * localT;
        const y = p0.y + (p1.y - p0.y) * localT;
        pts.push({ x, y });
      }

      const smoothed = pts.map((p, idx) => {
        const window = [];
        if (idx > 0) window.push(pts[idx - 1]);
        window.push(p);
        if (idx < pts.length - 1) window.push(pts[idx + 1]);
        const sx = window.reduce((s, q) => s + q.x, 0) / window.length;
        const sy = window.reduce((s, q) => s + q.y, 0) / window.length;
        return { x: sx, y: sy };
      });

      return { points: smoothed };
    }

    function estimateCobbAngle(pelvisTiltDeg, headAxisDeg, splinePoints) {
      let bottomSplineA = null;
      let topSplineA = null;
      if (splinePoints && splinePoints.length >= 6) {
        const k = 2;
        bottomSplineA = angleOfLineDeg(splinePoints[0], splinePoints[k]);
        topSplineA = angleOfLineDeg(
          splinePoints[splinePoints.length - 1 - k],
          splinePoints[splinePoints.length - 1]
        );
      }

      let bottomA = bottomSplineA;
      let topA = topSplineA;

      const hasPelvis =
        pelvisTiltDeg !== null &&
        pelvisTiltDeg !== undefined &&
        Number.isFinite(pelvisTiltDeg);
      const hasHeadAxis =
        headAxisDeg !== null &&
        headAxisDeg !== undefined &&
        Number.isFinite(headAxisDeg);

      if (hasPelvis) {
        const axisInf = normalizeAngle90(pelvisTiltDeg + 90);
        bottomA = bottomA == null ? axisInf : 0.5 * bottomA + 0.5 * axisInf;
      }

      if (hasHeadAxis) {
        const axisSup = normalizeAngle90(headAxisDeg);
        topA = topA == null ? axisSup : 0.5 * topA + 0.5 * axisSup;
      }

      if (bottomA == null || topA == null) return null;

      const aTopNorm = normalizeAngle90(topA);
      const aBottomNorm = normalizeAngle90(bottomA);
      let diff = Math.abs(aTopNorm - aBottomNorm);
      if (diff > 90) diff = 180 - diff;
      return diff;
    }
function analyzeSpineDeviation(spinePoints, kpC) {
  // Calcola quanto la curva si allontana dall’asse testa–bacino
  if (!spinePoints || spinePoints.length < 2 || !kpC || !kpC.pelvisCenter) {
    return null;
  }
  const pelvisC = kpC.pelvisCenter;
  const headC = kpC.headCenter || kpC.neckBase || kpC.shoulderMid;
  if (!headC) return null;

  const vx = headC.x - pelvisC.x;
  const vy = headC.y - pelvisC.y;
  const len = Math.hypot(vx, vy) || 1;

  // normale alla colonna (direzione della deviazione laterale)
  const nx = -vy / len;
  const ny = vx / len;

  let maxAbsOff = 0;
  let sumAbsOff = 0;
  let midOffset = 0;
  const n = spinePoints.length;
  const offsetsNorm = [];

  for (let i = 0; i < n; i++) {
    const p = spinePoints[i];
    if (!p) continue;
    const wx = p.x - pelvisC.x;
    const wy = p.y - pelvisC.y;
    const off = wx * nx + wy * ny; // deviazione laterale firmata
    const absOff = Math.abs(off);
    if (absOff > maxAbsOff) maxAbsOff = absOff;
    sumAbsOff += absOff;
    if (i === Math.floor(n / 2)) midOffset = off;
    offsetsNorm.push(off / len);
  }

  const meanAbsOff = n ? sumAbsOff / n : 0;
  const maxDevNorm = maxAbsOff / len;
  const meanDevNorm = meanAbsOff / len;

  const curveIsNoise = maxDevNorm < CURVE_NOISE_DEV_NORM;
  const curveIsBorder =
    maxDevNorm >= CURVE_NOISE_DEV_NORM &&
    maxDevNorm < CURVE_SUSPECT_DEV_NORM;
  const curveIsSignificant = maxDevNorm >= CURVE_SUSPECT_DEV_NORM;

  return {
    maxDeviationPx: maxAbsOff,
    maxDeviationNorm: maxDevNorm,
    meanDeviationNorm: meanDevNorm,
    midOffsetNorm: midOffset / len,
    curveIsNoise,
    curveIsBorder,
    curveIsSignificant,
    offsetsNorm
  };
}

function computeCurveCategory(absCobb, analysis, viewType) {
  if (viewType === "laterale") {
    return "vista laterale (curva sagittale approssimata; Cobb non applicabile)";
  }
  if (!analysis) return "non valutabile";

  const dev = analysis.maxDeviationNorm ?? 0;

  // entro rumore sia come ampiezza che come angolo
  if (dev < CURVE_NOISE_DEV_NORM && absCobb < COBB_NOISE_FLOOR_DEG) {
    return "schiena pressoché dritta (entro rumore fotogrammetrico)";
  }

  // asimmetria lieve, non scoliosi vera (Cobb < 10°)
  if (dev < CURVE_SUSPECT_DEV_NORM && absCobb < COBB_SUSPECT_DEG) {
    return "asimmetria lieve / non specifica (non scoliosi vera)";
  }

  // curva significativa sia come ampiezza che come angolo
  if (analysis.curveIsSignificant && absCobb >= COBB_SUSPECT_DEG) {
    return "curva potenzialmente scoliotica (da confermare con radiografia)";
  }

  return "asimmetria moderata";
}

// normalizza Cobb stimato considerando soglia di rumore
function postProcessCurveMetrics(session) {
  if (!session || !session.metrics || !session.spineSpline || !session.keypointsCanonical) {
    session.curveAnalysis = null;
    return;
  }

  const vType = getEffectiveViewType(session);
  const analysis = analyzeSpineDeviation(session.spineSpline, session.keypointsCanonical);
  session.curveAnalysis = analysis;

  if (!analysis) {
    session.metrics.curveMaxDeviationNorm = null;
    session.metrics.curveCategory = "non valutabile";
    return;
  }

  // Vista laterale: non ha senso parlare di Cobb frontale
  if (vType === "laterale") {
    session.metrics.cobbAngleDeg = null;
    session.metrics.curveMaxDeviationNorm = analysis.maxDeviationNorm;
    session.metrics.curveCategory = computeCurveCategory(0, analysis, vType);
    return;
  }

  let cobb = session.metrics.cobbAngleDeg;
  if (cobb == null || !Number.isFinite(cobb)) cobb = 0;
  let absCobb = Math.abs(cobb);

  // qualunque Cobb < 5° è trattato come 0°
  if (absCobb < COBB_NOISE_FLOOR_DEG) {
    cobb = 0;
    absCobb = 0;
  }

  session.metrics.cobbAngleDeg = cobb;
  session.metrics.curveMaxDeviationNorm = analysis.maxDeviationNorm;
  session.metrics.curveCategory = computeCurveCategory(absCobb, analysis, vType);
}

    function drawSkeleton(ctx, kpC, viewType) {
      if (!toggleSkeleton.checked || !kpC) return;
      ctx.save();

      function drawSegment(a, b, color, width = 3) {
        if (!a || !b) return;
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }

      const vt = viewType || "non determinata";
      const shoulderColor =
        vt === "posteriore" ? "rgba(248,113,113,0.95)" : "rgba(148,163,184,0.95)";
      const ribColor =
        vt === "posteriore" ? "rgba(248,250,252,0.9)" : "rgba(59,130,246,0.9)";

      drawSegment(kpC.leftShoulder, kpC.rightShoulder, shoulderColor);
      drawSegment(kpC.leftHip, kpC.rightHip, "rgba(248,113,113,0.9)");
      drawSegment(kpC.leftShoulder, kpC.leftHip, "rgba(148,163,184,0.7)", 2);
      drawSegment(kpC.rightShoulder, kpC.rightHip, "rgba(148,163,184,0.7)", 2);
      drawSegment(
        kpC.shoulderMid,
        kpC.pelvisCenter,
        "rgba(148,163,184,0.6)",
        2
      );
      drawSegment(kpC.headCenter, kpC.neckBase, "rgba(148,163,184,0.9)", 2);

      if (kpC.ribsLeft && kpC.ribsRight) {
        ctx.strokeStyle = ribColor;
        ctx.lineWidth = 2;
        ctx.fillStyle = ribColor;
        for (let i = 0; i < kpC.ribsLeft.length; i++) {
          const L = kpC.ribsLeft[i];
          const R = kpC.ribsRight[i];
          if (!L || !R) continue;
          ctx.beginPath();
          ctx.moveTo(L.x, L.y);
          ctx.lineTo(R.x, R.y);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(L.x, L.y, 3, 0, Math.PI * 2);
          ctx.arc(R.x, R.y, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      if (kpC.sternum) {
        ctx.fillStyle = "rgba(56,189,248,0.95)";
        ctx.beginPath();
        ctx.arc(kpC.sternum.x, kpC.sternum.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      if (kpC.clavSegments) {
        ctx.strokeStyle = "rgba(56,189,248,0.9)";
        ctx.lineWidth = 3;
        for (const seg of kpC.clavSegments) {
          drawSegment(seg.start, seg.end, "rgba(56,189,248,0.9)", 3);
        }
      }

      if (kpC.scmSegments) {
        ctx.strokeStyle = "rgba(251,191,36,0.9)";
        ctx.lineWidth = 2;
        for (const seg of kpC.scmSegments) {
          drawSegment(seg.start, seg.end, "rgba(251,191,36,0.9)", 2);
        }
      }

      ctx.fillStyle = "rgba(56,189,248,0.95)";
      const pts = [
        kpC.headCenter,
        kpC.neckBase,
        kpC.shoulderMid,
        kpC.leftShoulder,
        kpC.rightShoulder,
        kpC.leftHip,
        kpC.rightHip,
        kpC.pelvisCenter
      ];
      for (const p of pts) {
        if (!p) continue;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function emphasizedSpinePoints(session) {
      const pts = session.spineSpline;
      if (!pts || !pts.length) return null;
      const lambda = curveLambda;
      let sumX = 0;
      pts.forEach((p) => (sumX += p.x));
      const cx = sumX / pts.length;
      return pts.map((p) => ({
        x: cx + lambda * (p.x - cx),
        y: p.y
      }));
    }

    function drawManualPointOverlay(ctx, session) {
      if (!session.manualPoints || session.manualPoints.length === 0) return;
      ctx.save();
      ctx.strokeStyle = "rgba(251,191,36,0.9)";
      ctx.lineWidth = 2;
      ctx.fillStyle = "rgba(251,191,36,0.95)";

      const pts = session.manualPoints;
      if (pts.length >= 2) {
        ctx.beginPath();
        pts.forEach((p, idx) => {
          if (idx === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        });
        ctx.stroke();
      }

      for (const p of pts) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawSpineAndHeadCentering(ctx, session) {
  if (!toggleSpine.checked) {
    drawManualPointOverlay(ctx, session);
    return;
  }
  const spine = session.spineCanonical;
  const kp = session.keypointsCanonical;
  if (!spine || !kp) {
    drawManualPointOverlay(ctx, session);
    return;
  }

  ctx.save();

  const emphasised = emphasizedSpinePoints(session);
  const ca = session.curveAnalysis;
  const isNoise = ca && ca.curveIsNoise;

  if (emphasised && emphasised.length >= 2) {
    ctx.lineWidth = 3;
    if (isNoise) {
      // curva quasi dritta: tratteggiata e più grigia
      ctx.strokeStyle = "rgba(148,163,184,0.6)";
      ctx.setLineDash([5, 4]);
    } else {
      ctx.strokeStyle = "rgba(56,189,248,0.95)";
      ctx.setLineDash([]);
    }
    ctx.beginPath();
    emphasised.forEach((p, idx) => {
      if (idx === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    });
    ctx.stroke();

    ctx.setLineDash([]);
    ctx.fillStyle = isNoise
      ? "rgba(148,163,184,0.7)"
      : "rgba(56,189,248,0.85)";
    for (let i = 0; i < emphasised.length; i += 3) {
      const p = emphasised[i];
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  const pelvis = kp.pelvisCenter;
  const head = kp.headCenter;

  if (pelvis) {
    ctx.setLineDash([6, 4]);
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = "rgba(148,163,184,0.7)";
    ctx.beginPath();
    ctx.moveTo(pelvis.x, pelvis.y - 350);
    ctx.lineTo(pelvis.x, pelvis.y + 30);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  if (head && kp.sternum) {
    ctx.strokeStyle = "rgba(248,250,252,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(head.x, head.y);
    ctx.lineTo(kp.sternum.x, kp.sternum.y);
    ctx.stroke();
  }

  if (pelvis && head) {
    const dx = head.x - pelvis.x;
    ctx.fillStyle = "rgba(248,250,252,0.95)";
    ctx.font = "11px system-ui";
    ctx.fillText(
      `offset testa/bacino ≈ ${dx.toFixed(1)} px`,
      pelvis.x + 12,
      pelvis.y - 12
    );
  }

  ctx.restore();

  drawManualPointOverlay(ctx, session);
}

    function drawVectorField(ctx, baseline, current) {
      if (!toggleVectors.checked) return;
      if (!baseline || !current) return;

      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(52,211,153,0.95)";
      ctx.fillStyle = "rgba(52,211,153,0.95)";

      const keys = [
        "headCenter",
        "neckBase",
        "shoulderMid",
        "leftShoulder",
        "rightShoulder",
        "leftHip",
        "rightHip",
        "pelvisCenter"
      ];

      const scale = 1.0;

      for (const k of keys) {
        const b = baseline[k];
        const c = current[k];
        if (!b || !c) continue;
        const dx = (c.x - b.x) * scale;
        const dy = (c.y - b.y) * scale;
        const len = Math.hypot(dx, dy);
        if (len < 1) continue;

        const x0 = b.x;
        const y0 = b.y;
        const x1 = x0 + dx;
        const y1 = y0 + dy;

        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.stroke();

        const angle = Math.atan2(dy, dx);
        const ah = 7;
        const leftX = x1 - ah * Math.cos(angle - Math.PI / 6);
        const leftY = y1 - ah * Math.sin(angle - Math.PI / 6);
        const rightX = x1 - ah * Math.cos(angle + Math.PI / 6);
        const rightY = y1 - ah * Math.sin(angle + Math.PI / 6);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(leftX, leftY);
        ctx.lineTo(rightX, rightY);
        ctx.closePath();
        ctx.fill();
      }

      ctx.restore();
    }

    function updateMetricRow(session) {
      if (!session || !session.metrics) {
        metricRow.innerHTML = "";
        return;
      }
      const m = session.metrics;
      const fmt = (v) =>
        v === null || v === undefined || Number.isNaN(v) ? "—" : v.toFixed(2);

      const vType = getEffectiveViewType(session);
      let viewLabel = "non determinata";
      if (vType === "frontale") viewLabel = "frontale";
      else if (vType === "posteriore") viewLabel = "posteriore";
      else if (vType === "laterale") viewLabel = "laterale";

      const sourceLabel =
        session.spineSource === "manual"
          ? "manuale"
          : session.spineSource === "learned"
          ? "appresa"
          : "automatica";

      metricRow.innerHTML = `
  <div><strong>Vista:</strong> ${viewLabel}</div>
  <div><strong>Sorgente colonna:</strong> ${sourceLabel}</div>
  <div><strong>Categoria curva:</strong> ${m.curveCategory || "—"}</div>
  <div><strong>Dev. max curva (norm.):</strong> ${fmt(m.curveMaxDeviationNorm)} u.n.</div>
  <div><strong>Tilt spalle:</strong> ${fmt(m.shoulderTiltDeg)}°</div>
  <div><strong>Tilt bacino:</strong> ${fmt(m.pelvisTiltDeg)}°</div>
  <div><strong>Tilt testa (vs verticale):</strong> ${fmt(m.headAxisDeg)}°</div>
  <div><strong>Angolo di Cobb:</strong> ${fmt(m.cobbAngleDeg)}°</div>
  <div><strong>Offset testa/bacino:</strong> ${fmt(m.headPelvisOffsetNorm)} u.n.</div>
  <div><strong>Offset testa/sterno:</strong> ${fmt(m.headSternumOffsetNorm)} u.n.</div>
  <div><strong>Rot. bacino (depth):</strong> ${fmt(m.pelvisDepthRotDiff)} Δu</div>
  <div><strong>Lunghezza tronco:</strong> ${fmt(m.torsoLengthPx)} px</div>
`;

    }

    function renderSession(index) {
      const session = sessions[index];
      if (!session || !session.keypointsCanonical || !session.transform) return;

      if (manualMode && session.keypointsCanonical) {
        ensureManualControlPoints(session);
      }

      mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
      drawImageWithTransform(mainCtx, session.img, session.transform);

      const vType = getEffectiveViewType(session);
      drawSkeleton(mainCtx, session.keypointsCanonical, vType);
      drawSpineAndHeadCentering(mainCtx, session);

      const baseline = sessions[0];
      if (baseline && baseline.keypointsCanonical && index > 0) {
        drawVectorField(
          mainCtx,
          baseline.keypointsCanonical,
          session.keypointsCanonical
        );
      }

      updateMetricRow(session);
      highlightFileItem(index);
    }

    function highlightFileItem(index) {
      const items = fileListEl.querySelectorAll(".file-item");
      items.forEach((el) => el.classList.remove("active"));
      const active = fileListEl.querySelector(`.file-item[data-idx="${index}"]`);
      if (active) active.classList.add("active");
    }

    function updateCharts() {
      if (!sessions.length) return;
      const labels = sessions.map((s, i) => `${i + 1}`);

      const shoulders = sessions.map((s) => s.metrics?.shoulderTiltDeg ?? null);
      const pelvis = sessions.map((s) => s.metrics?.pelvisTiltDeg ?? null);
      const headAxis = sessions.map((s) => s.metrics?.headAxisDeg ?? null);
      const cobb = sessions.map((s) => s.metrics?.cobbAngleDeg ?? null);

      const headPelvis = sessions.map(
        (s) => s.metrics?.headPelvisOffsetNorm ?? null
      );
      const headSternum = sessions.map(
        (s) => s.metrics?.headSternumOffsetNorm ?? null
      );

      const anglesCtx = document
        .getElementById("chartAngles")
        .getContext("2d");
      if (!anglesChart) {
        anglesChart = new Chart(anglesCtx, {
          type: "line",
          data: {
            labels,
            datasets: [
              {
                label: "Tilt spalle (°)",
                data: shoulders,
                tension: 0.3
              },
              {
                label: "Tilt bacino (°)",
                data: pelvis,
                tension: 0.3
              },
              {
                label: "Tilt testa vs verticale (°)",
                data: headAxis,
                tension: 0.3
              },
              {
                label: "Cobb (°)",
                data: cobb,
                tension: 0.3
              }
            ]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                labels: { color: "#e5e7eb", font: { size: 10 } }
              }
            },
            scales: {
              x: {
                ticks: { color: "#9ca3af", font: { size: 9 } },
                grid: { color: "rgba(148,163,184,0.25)" }
              },
              y: {
                ticks: { color: "#9ca3af", font: { size: 9 } },
                grid: { color: "rgba(148,163,184,0.18)" }
              }
            }
          }
        });
      } else {
        anglesChart.data.labels = labels;
        anglesChart.data.datasets[0].data = shoulders;
        anglesChart.data.datasets[1].data = pelvis;
        anglesChart.data.datasets[2].data = headAxis;
        anglesChart.data.datasets[3].data = cobb;
        anglesChart.update();
      }

      const offsetsCtx = document
        .getElementById("chartOffsets")
        .getContext("2d");
      if (!offsetsChart) {
        offsetsChart = new Chart(offsetsCtx, {
          type: "line",
          data: {
            labels,
            datasets: [
              {
                label: "Offset testa/bacino (norm.)",
                data: headPelvis,
                tension: 0.3
              },
              {
                label: "Offset testa/sterno (norm.)",
                data: headSternum,
                tension: 0.3
              }
            ]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                labels: { color: "#e5e7eb", font: { size: 10 } }
              }
            },
            scales: {
              x: {
                ticks: { color: "#9ca3af", font: { size: 9 } },
                grid: { color: "rgba(148,163,184,0.25)" }
              },
              y: {
                ticks: { color: "#9ca3af", font: { size: 9 } },
                grid: { color: "rgba(148,163,184,0.18)" }
              }
            }
          }
        });
      } else {
        offsetsChart.data.labels = labels;
        offsetsChart.data.datasets[0].data = headPelvis;
        offsetsChart.data.datasets[1].data = headSternum;
        offsetsChart.update();
      }
    }

    function updateModelChart() {
      const canvas = document.getElementById("chartModel");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const labels = modelErrorHistory.map((_, i) => `${i + 1}`);
      const data = modelErrorHistory;

      if (!modelChart) {
        modelChart = new Chart(ctx, {
          type: "line",
          data: {
            labels,
            datasets: [
              {
                label: "Errore medio offset (RMSE)",
                data,
                tension: 0.3
              }
            ]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                labels: { color: "#e5e7eb", font: { size: 10 } }
              }
            },
            scales: {
              x: {
                ticks: { color: "#9ca3af", font: { size: 9 } },
                grid: { color: "rgba(148,163,184,0.25)" }
              },
              y: {
                ticks: { color: "#9ca3af", font: { size: 9 } },
                grid: { color: "rgba(148,163,184,0.18)" }
              }
            }
          }
        });
      } else {
        modelChart.data.labels = labels;
        modelChart.data.datasets[0].data = data;
        modelChart.update();
      }
    }

    function evaluateModelOnce(examples) {
      if (examples.length < 2) return 0;
      const errors = [];
      const kBase = 3;

      for (let i = 0; i < examples.length; i++) {
        const ex = examples[i];
        const feat = ex.features;
        const trueOffsets = ex.offsets;
        const distArr = [];

        for (let j = 0; j < examples.length; j++) {
          if (j === i) continue;
          const ex2 = examples[j];
          const f2 = ex2.features;
          let s = 0;
          const len = Math.min(feat.length, f2.length);
          for (let t = 0; t < len; t++) {
            const d = (feat[t] || 0) - (f2[t] || 0);
            s += d * d;
          }
          distArr.push({ idx: j, dist: Math.sqrt(s) });
        }

        if (!distArr.length) continue;
        distArr.sort((a, b) => a.dist - b.dist);
        const k = Math.min(kBase, distArr.length);
        const neighbors = distArr.slice(0, k);
        const weights = neighbors.map((n) => 1 / (n.dist + 1e-6));
        const sumW = weights.reduce((s, w) => s + w, 0) || 1;

        const predOffsets = new Array(SPINE_SAMPLES).fill(0);
        for (let j = 0; j < SPINE_SAMPLES; j++) {
          let num = 0;
          for (let t = 0; t < k; t++) {
            const ex2 = examples[neighbors[t].idx];
            const w = weights[t];
            num += (ex2.offsets[j] || 0) * w;
          }
          predOffsets[j] = num / sumW;
        }

        let seSum = 0;
        let count = 0;
        for (let j = 0; j < SPINE_SAMPLES; j++) {
          const diff = (predOffsets[j] || 0) - (trueOffsets[j] || 0);
          seSum += diff * diff;
          count++;
        }
        if (count > 0) errors.push(Math.sqrt(seSum / count));
      }

      if (!errors.length) return 0;
      return errors.reduce((s, e) => s + e, 0) / errors.length;
    }

    function recomputeModelErrorHistory() {
      modelErrorHistory = [];
      for (let n = 1; n <= trainingExamples.length; n++) {
        const subset = trainingExamples.slice(0, n);
        const err = evaluateModelOnce(subset);
        modelErrorHistory.push(err);
      }
      updateModelChart();
    }

    function describeTowardZero(name, baseline, last, unit, threshold) {
      if (
        baseline === null ||
        baseline === undefined ||
        last === null ||
        last === undefined ||
        !Number.isFinite(baseline) ||
        !Number.isFinite(last)
      )
        return null;
      const abs0 = Math.abs(baseline);
      const abs1 = Math.abs(last);
      const deltaAbs = abs1 - abs0;

      if (Math.abs(deltaAbs) < threshold) {
        return `• ${name}: variazione minima (quasi invariato, da ${baseline.toFixed(
          2
        )}${unit} a ${last.toFixed(2)}${unit}).`;
      } else if (deltaAbs < 0) {
        return `• ${name}: <strong>miglioramento</strong> (più vicino alla neutralità, da ${baseline.toFixed(
          2
        )}${unit} a ${last.toFixed(2)}${unit}).`;
      } else {
        return `• ${name}: <strong>peggioramento</strong> (più lontano dalla neutralità, da ${baseline.toFixed(
          2
        )}${unit} a ${last.toFixed(2)}${unit}).`;
      }
    }

    function buildTechnicalReport() {
      if (!sessions.length || !sessions[0].metrics) {
        reportPanel.innerHTML =
          "<h3>Report tecnico automatico</h3><p>Analizza le immagini per generare il report.</p>";
        return;
      }
      if (sessions.length < 2) {
        reportPanel.innerHTML =
          "<h3>Report tecnico automatico</h3><p>Servono almeno due sessioni per confrontare l’evoluzione.</p>";
        return;
      }

      const first = sessions[0];
      const last = sessions[sessions.length - 1];
      const m0 = first.metrics;
      const m1 = last.metrics;


      const items = [];
const cat0 = m0.curveCategory || "non valutabile";
const cat1 = m1.curveCategory || "non valutabile";

const sCat = `• Classificazione curva (inizio → fine): <strong>${cat0}</strong> → <strong>${cat1}</strong>.`;
if(sCat) items.push(sCat);
      const sShoulders = describeTowardZero(
        "Inclinazione delle spalle",
        m0.shoulderTiltDeg,
        m1.shoulderTiltDeg,
        "°",
        1
      );
      if (sShoulders) items.push(sShoulders);

      const sPelvis = describeTowardZero(
        "Inclinazione del bacino",
        m0.pelvisTiltDeg,
        m1.pelvisTiltDeg,
        "°",
        1
      );
      if (sPelvis) items.push(sPelvis);

      const sHead = describeTowardZero(
        "Inclinazione della testa rispetto alla verticale",
        m0.headAxisDeg,
        m1.headAxisDeg,
        "°",
        1
      );
      if (sHead) items.push(sHead);

      const sCobb = describeTowardZero(
        "Angolo di Cobb (spline + bacino + testa)",
        m0.cobbAngleDeg,
        m1.cobbAngleDeg,
        "°",
        1
      );
      if (sCobb) items.push(sCobb);

      const sHeadPelvis = describeTowardZero(
        "Centratura testa rispetto al bacino",
        m0.headPelvisOffsetNorm,
        m1.headPelvisOffsetNorm,
        "",
        0.02
      );
      if (sHeadPelvis) items.push(sHeadPelvis);

      const sHeadSternum = describeTowardZero(
        "Centratura testa rispetto alla colonna sterneale",
        m0.headSternumOffsetNorm,
        m1.headSternumOffsetNorm,
        "",
        0.02
      );
      if (sHeadSternum) items.push(sHeadSternum);

      const sPelvisRot = describeTowardZero(
        "Rotazione del bacino in profondità (anca dx - anca sx)",
        m0.pelvisDepthRotDiff,
        m1.pelvisDepthRotDiff,
        "",
        0.02
      );
      if (sPelvisRot) items.push(sPelvisRot);

      const hasLateral = sessions.some(
        (s) => getEffectiveViewType(s) === "laterale"
      );
      const hasPosterior = sessions.some(
        (s) => getEffectiveViewType(s) === "posteriore"
      );
      const hasFrontal = sessions.some(
        (s) => getEffectiveViewType(s) === "frontale"
      );

      const vistaNoteParts = [];
      if (hasFrontal)
        vistaNoteParts.push("frontali (costato, sterno, clavicole)");
      if (hasPosterior)
        vistaNoteParts.push("posteriori (scapole, costato, fluttuanti, bacino)");
      if (hasLateral) vistaNoteParts.push("laterali (profilo sagittale)");

      const vistaNote =
        vistaNoteParts.length > 0
          ? `<p>Le immagini analizzate includono viste: ${vistaNoteParts.join(
              ", "
            )}. Il sistema adatta i punti di repere in base alla vista, ma è sempre possibile forzare Frontale/Posteriore/Laterale dal menu vicino a ciascuna foto per correggere eventuali errori di riconoscimento.</p>`
          : "";

      const html = `
        <h3>Report tecnico automatico</h3>
        <p><strong>Baseline:</strong> ${first.fileName} &nbsp;&nbsp; <strong>Ultima:</strong> ${last.fileName}</p>
        <ul>
          ${items.map((t) => `<li>${t}</li>`).join("")}
        </ul>
        ${vistaNote}
        ${
          hasLateral
            ? "<p>In alcune immagini è presente una vista laterale: l’algoritmo la riconosce come tale e usa bacino–mid-torace–collo–testa per descrivere in modo qualitativo la curva sagittale (cifosi/lordosi), pur mantenendo il focus sugli angoli sul piano frontale.</p>"
            : ""
        }
        <p><em>Nota clinica:</em> tutti gli angoli sono in ±90° con periodicità 180° (180° ≡ 0°). Il Cobb è stimato a partire dalla spline della schiena su asse testa–bacino, vincolando in basso l’orientamento alle linee del bacino (prime vertebre lombari) e in alto all’asse testa–collo (allineamento cervico–cranico). I controlli manuali tra bacino e testa permettono di correggere le imprecisioni fotogrammetriche e, con il training, guidano il modello nel riconoscimento di curve simili. Il grafico “Apprendimento modello” mostra la riduzione dell’errore medio (RMSE sugli offset della curva) all’aumentare degli esempi.</p>
      `;

      reportPanel.innerHTML = html;
    }

    async function estimateDepthMap(session) {
      if (!depthEstimator || !depthReady) return null;
      try {
        const depthNS = globalThis.depthEstimation || window.depthEstimation;
        if (!depthNS) {
          console.warn("depthEstimation non disponibile.");
          return null;
        }
        const estimationConfig = {
          minDepth: 0.2,
          maxDepth: 0.9,
          flipHorizontal: false
        };
        const depthMap = await depthEstimator.estimateDepth(
          session.img,
          estimationConfig
        );
        const depthArray = await depthMap.toArray();
        return depthArray;
      } catch (err) {
        console.warn("Errore depth estimation", err);
        return null;
      }
    }

    function sampleDepthAtImagePoint(depthMap, img, pt, radius = 2) {
      if (!depthMap || !pt) return null;
      const h = depthMap.length;
      const w = depthMap[0].length;
      const xNorm = pt.x / img.naturalWidth;
      const yNorm = pt.y / img.naturalHeight;
      const cx = Math.round(xNorm * (w - 1));
      const cy = Math.round(yNorm * (h - 1));
      let sum = 0;
      let count = 0;
      for (let j = -radius; j <= radius; j++) {
        for (let i = -radius; i <= radius; i++) {
          const xx = cx + i;
          const yy = cy + j;
          if (xx < 0 || xx >= w || yy < 0 || yy >= h) continue;
          sum += depthMap[yy][xx];
          count++;
        }
      }
      if (!count) return null;
      return sum / count;
    }

    function computePelvisDepthRotationDiff(session) {
      if (!session.depthMap || !session.keypoints2D) return null;
      const depthMap = session.depthMap;
      const img = session.img;
      const kp = session.keypoints2D;

      const dL = sampleDepthAtImagePoint(depthMap, img, kp.leftHip, 3);
      const dR = sampleDepthAtImagePoint(depthMap, img, kp.rightHip, 3);
      if (dL === null || dR === null) return null;
      return dR - dL;
    }

    function computeFeatureVector(session) {
      const m = session.metrics || {};
      const v = [
        m.shoulderTiltDeg || 0,
        m.pelvisTiltDeg || 0,
        m.headAxisDeg || 0,
        m.headPelvisOffsetNorm || 0,
        m.headSternumOffsetNorm || 0,
        m.pelvisDepthRotDiff || 0
      ];
      return v.map((x) =>
        x === null || x === undefined || Number.isNaN(x) ? 0 : x
      );
    }

    function saveTrainingExamples() {
      try {
        localStorage.setItem(
          "scoliosisTraining_v1",
          JSON.stringify(trainingExamples)
        );
      } catch (e) {
        console.warn("Impossibile salvare in localStorage", e);
      }
    }

    function loadTrainingExamples() {
      try {
        const raw = localStorage.getItem("scoliosisTraining_v1");
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          trainingExamples = arr.filter(
            (ex) =>
              Array.isArray(ex.features) &&
              Array.isArray(ex.offsets) &&
              ex.offsets.length === SPINE_SAMPLES
          );
          if (trainingExamples.length) {
            console.log(
              "Training examples caricati:",
              trainingExamples.length
            );
            recomputeModelErrorHistory();
          }
        }
      } catch (e) {
        console.warn("Errore caricando training examples", e);
      }
    }

    function predictOffsetsFromModel(session) {
      if (!trainingExamples.length) return null;

      const feat = computeFeatureVector(session);
      const k = Math.min(3, trainingExamples.length);

      const distArr = trainingExamples.map((ex, idx) => {
        const f = ex.features || [];
        const len = Math.min(f.length, feat.length);
        let s = 0;
        for (let i = 0; i < len; i++) {
          const d = (feat[i] || 0) - (f[i] || 0);
          s += d * d;
        }
        return { idx, dist: Math.sqrt(s) };
      });

      distArr.sort((a, b) => a.dist - b.dist);
      const neighbors = distArr.slice(0, k);
      const weights = neighbors.map((n) => 1 / (n.dist + 1e-6));
      const sumW = weights.reduce((s, w) => s + w, 0) || 1;

      const offsets = new Array(SPINE_SAMPLES).fill(0);
      for (let j = 0; j < SPINE_SAMPLES; j++) {
        let num = 0;
        for (let t = 0; t < neighbors.length; t++) {
          const ex = trainingExamples[neighbors[t].idx];
          const w = weights[t];
          num += (ex.offsets[j] || 0) * w;
        }
        offsets[j] = num / sumW;
      }
      return offsets;
    }

    function applyOffsetsToSessionSpine(session, offsets) {
      const kpC = session.keypointsCanonical;
      if (!kpC || !kpC.pelvisCenter) return;

      const pelvisC = kpC.pelvisCenter;
      const headC = kpC.headCenter || kpC.neckBase || kpC.shoulderMid || pelvisC;

      const torsoVec = {
        x: headC.x - pelvisC.x,
        y: headC.y - pelvisC.y
      };
      const torsoLenC = Math.hypot(torsoVec.x, torsoVec.y) || 1;

      const nx = -torsoVec.y / torsoLenC;
      const ny = torsoVec.x / torsoLenC;

      const pts = [];
      for (let i = 0; i < SPINE_SAMPLES; i++) {
        const hi = i / (SPINE_SAMPLES - 1);
        const off = offsets[i] || 0;

        const baseX = pelvisC.x + torsoVec.x * hi;
        const baseY = pelvisC.y + torsoVec.y * hi;

        const x = baseX + nx * off * torsoLenC;
        const y = baseY + ny * off * torsoLenC;

        pts.push({ x, y });
      }

      session.spineSpline = pts;
      session.spineSource = "learned";
    }

    function rebuildSpineFromControlPoints(session) {
      if (!session.manualPoints || session.manualPoints.length === 0) return;

      const kpC = session.keypointsCanonical;
      if (!kpC || !kpC.pelvisCenter) return;

      const pelvisC = kpC.pelvisCenter;
      const headC = kpC.headCenter || kpC.neckBase || kpC.shoulderMid || pelvisC;

      const torsoVec = {
        x: headC.x - pelvisC.x,
        y: headC.y - pelvisC.y
      };
      const torsoLenC = Math.hypot(torsoVec.x, torsoVec.y) || 1;

      const nx = -torsoVec.y / torsoLenC;
      const ny = torsoVec.x / torsoLenC;

      const ctrlSamples = [];
      const nCtrl = session.manualPoints.length;

      for (let i = 0; i < nCtrl; i++) {
        const hi = i / (nCtrl - 1);
        const baseX = pelvisC.x + torsoVec.x * hi;
        const baseY = pelvisC.y + torsoVec.y * hi;
        const p = session.manualPoints[i];
        const off = (p.x - baseX) / torsoLenC;
        ctrlSamples.push({ hi, off });
      }

      ctrlSamples.sort((a, b) => a.hi - b.hi);

      const hiGrid = [];
      for (let i = 0; i < SPINE_SAMPLES; i++) {
        hiGrid.push(i / (SPINE_SAMPLES - 1));
      }

      const offsets = [];
      let idx = 0;
      for (const hg of hiGrid) {
        while (idx < ctrlSamples.length - 1 && ctrlSamples[idx + 1].hi < hg) idx++;
        if (idx === ctrlSamples.length - 1) {
          offsets.push(ctrlSamples[ctrlSamples.length - 1].off);
        } else {
          const d0 = ctrlSamples[idx];
          const d1 = ctrlSamples[idx + 1];
          const t = d1.hi === d0.hi ? 0 : (hg - d0.hi) / (d1.hi - d0.hi);
          const off = d0.off + (d1.off - d0.off) * t;
          offsets.push(off);
        }
      }

      const spinePts = [];
      for (let i = 0; i < SPINE_SAMPLES; i++) {
        const hi = hiGrid[i];
        const off = offsets[i];

        const baseX = pelvisC.x + torsoVec.x * hi;
        const baseY = pelvisC.y + torsoVec.y * hi;

        const x = baseX + nx * off * torsoLenC;
        const y = baseY + ny * off * torsoLenC;

        spinePts.push({ x, y });
      }

      session.spineSpline = spinePts;
      session.manualOffsets = offsets;
      session.spineSource = "manual";
if (session.metrics) {
  postProcessCurveMetrics(session);
}

      session.manualPoints = session.manualPoints.map((p, i) => {
        const hi = i / (nCtrl - 1);
        const baseX = pelvisC.x + torsoVec.x * hi;
        const baseY = pelvisC.y + torsoVec.y * hi;
        const off = ctrlSamples[i].off;
        const x = baseX + nx * off * torsoLenC;
        const y = baseY + ny * off * torsoLenC;
        return { x, y };
      });
    }

    function ensureManualControlPoints(session) {
      if (!session.keypointsCanonical || !session.keypointsCanonical.pelvisCenter)
        return;

      if (session.manualPoints && session.manualPoints.length === CONTROL_POINTS)
        return;

      const kpC = session.keypointsCanonical;
      const pelvisC = kpC.pelvisCenter;
      const headC = kpC.headCenter || kpC.neckBase || kpC.shoulderMid || pelvisC;

      const torsoVec = {
        x: headC.x - pelvisC.x,
        y: headC.y - pelvisC.y
      };

      const spine = session.spineSpline;
      session.manualPoints = [];

      for (let i = 0; i < CONTROL_POINTS; i++) {
        const hi = i / (CONTROL_POINTS - 1);
        let pInit = null;

        if (spine && spine.length >= 2) {
          const idx = Math.round(hi * (spine.length - 1));
          pInit = spine[idx];
        }

        if (!pInit) {
          const baseX = pelvisC.x + torsoVec.x * hi;
          const baseY = pelvisC.y + torsoVec.y * hi;
          pInit = { x: baseX, y: baseY };
        }

        session.manualPoints.push({ x: pInit.x, y: pInit.y });
      }

      rebuildSpineFromControlPoints(session);
    }

    function saveManualExampleCurrentSession() {
      const s = sessions[currentIndex];
      if (!s || !s.manualOffsets || !s.metrics) {
        statusEl.classList.add("error");
        statusEl.textContent =
          "Per salvare un esempio, attiva i punti manuali e modifica almeno un punto.";
        return;
      }
      const features = computeFeatureVector(s);
      const offsets = s.manualOffsets.slice();
      trainingExamples.push({ features, offsets });
      saveTrainingExamples();
      recomputeModelErrorHistory();
      statusEl.classList.remove("error");
      statusEl.textContent =
        `Esempio manuale salvato. Totale esempi: ${trainingExamples.length}.`;

      reapplyLearnedModelToAllSessions();
    }

    function reapplyLearnedModelToAllSessions() {
      if (!sessions.length) return;
      if (!enableLearning.checked || trainingExamples.length < 3) return;

      for (const s of sessions) {
        if (!s.metrics || !s.keypointsCanonical) continue;
        if (s.spineSource === "manual") continue;

        const offsets = predictOffsetsFromModel(s);
        if (!offsets) continue;
        applyOffsetsToSessionSpine(s, offsets);

        const pelvisTilt = s.metrics.pelvisTiltDeg;
        const headAxisDeg = s.metrics.headAxisDeg;
        const cobbAngle = estimateCobbAngle(
  pelvisTilt,
  headAxisDeg,
  s.spineSpline
);
s.metrics.cobbAngleDeg = cobbAngle ?? null;
postProcessCurveMetrics(s);

      }

      updateCharts();
      buildTechnicalReport();
      renderSession(currentIndex);
      statusEl.textContent += " Modello riapplicato a tutte le immagini.";
    }

    function recomputeSpineForSession(session) {
      if (!session || !session.keypointsCanonical) return;
      if (!session.metrics) return;

      if (session.spineSource === "manual") {
        renderSession(currentIndex);
        return;
      }

      const vType = getEffectiveViewType(session);
      const spineC = estimateSpineCanonical(session.keypointsCanonical, vType);
      session.spineCanonical = spineC;
      session.spineSource = "auto";

      if (spineC) {
        const autoSpline = computeSpineSpline(spineC.basePoints, SPINE_SAMPLES);
        session.spineSpline = autoSpline.points;
      } else {
        session.spineSpline = null;
      }

      const pelvisTilt = session.metrics.pelvisTiltDeg;
      const headAxisDeg = session.metrics.headAxisDeg;
      const cobbAngle = estimateCobbAngle(
        pelvisTilt,
        headAxisDeg,
        session.spineSpline
      );
      session.metrics.cobbAngleDeg = cobbAngle ?? null;
      if (session.metrics) {
  postProcessCurveMetrics(session);
}

    }

    async function analyzeAllSessions() {
      if (!poseLandmarker || !sessions.length) return;
      analyzeBtn.disabled = true;
      statusEl.classList.remove("error");
      statusEl.textContent = "Analisi in corso...";
      showBusy("Analisi immagini in corso...", 0);

      for (let i = 0; i < sessions.length; i++) {
        const s = sessions[i];
        try {
          const result = poseLandmarker.detect(s.img);
          if (!result || !result.landmarks || !result.landmarks.length) {
            console.warn("Nessun pose trovato per", s.fileName);
            continue;
          }
          const landmarks = result.landmarks[0];
          s.landmarks = landmarks;

          const kp = extractKeypoints(
            landmarks,
            s.img.naturalWidth,
            s.img.naturalHeight
          );
          s.keypoints2D = kp;

          s.viewTypeAuto = detectPoseOrientation(landmarks, kp);
          s.viewType = s.viewTypeAuto;

          const transform = computeAlignmentTransform(kp, s.img);
          s.transform = transform;

          const kpC = {};
          Object.keys(kp).forEach((k) => {
            if (!kp[k]) return;
            kpC[k] = transformPoint(kp[k], transform);
          });

          const repere = computeDetailedCanonicalRepere(kpC);
          kpC.ribsLeft = repere.ribsLeft;
          kpC.ribsRight = repere.ribsRight;
          kpC.ribsMid = repere.ribsMid;
          kpC.sternum = repere.sternum;
          kpC.clavSegments = repere.clavSegments;
          kpC.scmSegments = repere.scmSegments;

          s.keypointsCanonical = kpC;

          const spineC = estimateSpineCanonical(kpC, s.viewTypeAuto);
          s.spineCanonical = spineC;

          s.spineSource = "auto";
          if (spineC) {
            const autoSpline = computeSpineSpline(
              spineC.basePoints,
              SPINE_SAMPLES
            );
            s.spineSpline = autoSpline.points;
          } else {
            s.spineSpline = null;
          }

          s.depthMap = await estimateDepthMap(s);

          const shoulderTilt = angleOfLineDeg(
            kp.leftShoulder,
            kp.rightShoulder
          );
          const pelvisTilt = angleOfLineDeg(kp.leftHip, kp.rightHip);

          let headAxisDeg = null;
          if (kp.headCenter && (kp.neckBase || kp.shoulderMid)) {
            headAxisDeg = headTiltRelativeVerticalDeg(
              kp.headCenter,
              kp.neckBase || kp.shoulderMid
            );
          }

          const torsoLength = distance(
            kp.neckBase || kp.shoulderMid,
            kp.pelvisCenter
          );
          const headPelvisOffset =
            kp.headCenter && kp.pelvisCenter
              ? kp.headCenter.x - kp.pelvisCenter.x
              : null;
          const headSternumOffset =
            kp.headCenter && kp.shoulderMid
              ? kp.headCenter.x - kp.shoulderMid.x
              : null;

          const pelvisDepthRotDiff = computePelvisDepthRotationDiff(s);

          if (s.manualPoints && s.manualPoints.length === CONTROL_POINTS) {
            rebuildSpineFromControlPoints(s);
          } else if (enableLearning.checked && trainingExamples.length >= 3) {
            const learnedOffsets = predictOffsetsFromModel(s);
            if (learnedOffsets) {
              applyOffsetsToSessionSpine(s, learnedOffsets);
            }
          }

          const cobbAngle = estimateCobbAngle(
  pelvisTilt,
  headAxisDeg,
  s.spineSpline
);

s.metrics = {
  shoulderTiltDeg: shoulderTilt,
  pelvisTiltDeg: pelvisTilt,
  headAxisDeg: headAxisDeg,
  cobbAngleDeg: cobbAngle ?? null,
  maxSpineAngleDeg: spineC?.maxAngleLocal ?? null,
  torsoLengthPx: torsoLength || 0,
  headPelvisOffsetNorm:
    torsoLength && headPelvisOffset !== null
      ? headPelvisOffset / torsoLength
      : null,
  headSternumOffsetNorm:
    torsoLength && headSternumOffset !== null
      ? headSternumOffset / torsoLength
      : null,
  pelvisDepthRotDiff: pelvisDepthRotDiff,
  curveMaxDeviationNorm: null,
  curveCategory: "non valutabile"
};

// QUI: normalizzazione in base a soglie (rumore / asimmetria / scoliosi-like)
postProcessCurveMetrics(s);


          statusEl.textContent = `Analisi foto ${i + 1}/${sessions.length} completata...`;
          updateBusy(
            `Analisi foto ${i + 1}/${sessions.length}...`,
            (i + 1) / sessions.length
          );
        } catch (err) {
          console.error("Errore durante l'analisi", s.fileName, err);
          statusEl.classList.add("error");
          statusEl.textContent =
            "Errore durante l'analisi di una o più immagini.";
        }
      }

      if (sessions[0] && !sessions[0].metrics) {
        statusEl.classList.add("error");
        statusEl.textContent =
          "Nessun scheletro rilevato. Controlla le foto e riprova.";
      } else {
        statusEl.classList.remove("error");
        statusEl.textContent = "Analisi completata.";
      }

      updateCharts();
      currentIndex = 0;
      rebuildFileList(); // per aggiornare i menu vista (Auto(frontale/posteriore/laterale))
      renderSession(currentIndex);
      analyzeBtn.disabled = false;
      buildTechnicalReport();
      setTimeout(hideBusy, 300);
    }

    function loadImageFile(file) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve({ file, img });
        img.onerror = (e) => reject(e);
        img.src = URL.createObjectURL(file);
      });
    }

    function rebuildFileList() {
      fileListEl.innerHTML = "";
      sessions.forEach((s, idx) => {
        const div = document.createElement("div");
        div.className = "file-item";
        div.dataset.idx = String(idx);
        div.innerHTML = `
          <span class="index">${idx + 1}</span>
          <span class="name">${s.fileName}</span>
          <div class="reorder-controls">
            <button class="reorder-btn up" data-dir="-1" title="Sposta su">↑</button>
            <button class="reorder-btn down" data-dir="1" title="Sposta giù">↓</button>
          </div>
          <select class="view-select">
            <option value="auto">Auto</option>
            <option value="frontale">Frontale</option>
            <option value="posteriore">Posteriore</option>
            <option value="laterale">Laterale</option>
          </select>
          <button class="delete-btn" title="Rimuovi questa foto">✕</button>
        `;
        div.addEventListener("click", (ev) => {
          if (
            ev.target.classList.contains("reorder-btn") ||
            ev.target.classList.contains("delete-btn") ||
            ev.target.classList.contains("view-select")
          ) return;
          currentIndex = idx;
          renderSession(currentIndex);
        });
        fileListEl.appendChild(div);

        const upBtn = div.querySelector(".reorder-btn.up");
        const downBtn = div.querySelector(".reorder-btn.down");
        const delBtn = div.querySelector(".delete-btn");
        const viewSelect = div.querySelector(".view-select");

        const autoLabel =
          s.viewTypeAuto && s.viewTypeAuto !== "non determinata"
            ? `Auto (${s.viewTypeAuto})`
            : "Auto (?)";
        viewSelect.options[0].textContent = autoLabel;
        if (s.viewTypeOverride) {
          viewSelect.value = s.viewTypeOverride;
        } else {
          viewSelect.value = "auto";
        }
        viewSelect.title = `Vista riconosciuta: ${s.viewTypeAuto || "non determinata"}`;

        upBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          moveSession(idx, -1);
        });
        downBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          moveSession(idx, 1);
        });
        delBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          removeSession(idx);
        });

        viewSelect.addEventListener("click", (e) => e.stopPropagation());
        viewSelect.addEventListener("change", (e) => {
          const val = e.target.value;
          if (val === "auto") {
            s.viewTypeOverride = null;
          } else {
            s.viewTypeOverride = val;
          }
          statusEl.textContent = `Vista per ${s.fileName}: ${getEffectiveViewType(
            s
          )} (override ${val === "auto" ? "disattivato" : "attivo"}).`;

          if (s.keypointsCanonical && s.metrics) {
            recomputeSpineForSession(s);
            updateCharts();
            buildTechnicalReport();
            renderSession(currentIndex);
          }
        });
      });
      highlightFileItem(currentIndex);
    }

    function moveSession(oldIndex, delta) {
      const newIndex = oldIndex + delta;
      if (newIndex < 0 || newIndex >= sessions.length) return;
      const [item] = sessions.splice(oldIndex, 1);
      sessions.splice(newIndex, 0, item);
      sessions.forEach((s, i) => (s.index = i));
      currentIndex = newIndex;
      rebuildFileList();
      updateCharts();
      renderSession(currentIndex);
    }

    function removeSession(idx) {
      if (idx < 0 || idx >= sessions.length) return;
      sessions.splice(idx, 1);
      if (!sessions.length) {
        currentIndex = 0;
        mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
        metricRow.innerHTML = "";
        reportPanel.innerHTML =
          "<h3>Report tecnico automatico</h3><p>Analizza le immagini per generare il report.</p>";
      } else {
        if (currentIndex >= sessions.length) currentIndex = sessions.length - 1;
      }
      sessions.forEach((s, i) => (s.index = i));
      rebuildFileList();
      updateCharts();
      buildTechnicalReport();
      if (sessions.length) {
        renderSession(currentIndex);
      }
      updateAnalyzeButton();
      statusEl.classList.remove("error");
      statusEl.textContent = sessions.length
        ? "Foto rimossa. Puoi ri-eseguire l’analisi se necessario."
        : "Tutte le foto rimosse. Carica altre immagini per ricominciare.";
    }

    function updateAnalyzeButton() {
      analyzeBtn.disabled = !(modelReady && imagesReady && sessions.length > 0);
    }

    async function initPoseLandmarker() {
      try {
        statusEl.textContent =
          "Carico modello MediaPipe Pose (può richiedere qualche secondo)...";

        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );

        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task"
          },
          runningMode: "IMAGE",
          numPoses: 1
        });

        modelReady = true;
        statusEl.classList.remove("error");
        statusEl.textContent =
          "Modello pose caricato. Carica le foto e premi Analizza.";
        updateAnalyzeButton();
      } catch (err) {
        console.error("Errore caricando MediaPipe Pose", err);
        statusEl.classList.add("error");
        statusEl.textContent =
          "Errore nel caricare il modello MediaPipe Pose.";
      }
    }

    async function initDepthEstimator() {
      try {
        const depthNS = globalThis.depthEstimation || window.depthEstimation;
        if (!depthNS) {
          console.warn("Libreria depthEstimation non trovata.");
          return;
        }
        const modelType = depthNS.SupportedModels.ARPortraitDepth;
        depthEstimator = await depthNS.createEstimator(modelType);
        depthReady = true;
        console.log("Depth estimator (ARPortraitDepth) pronto.");
      } catch (err) {
        console.error("Errore caricando depth estimator", err);
      }
    }

    fileInput.addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      sessions = [];
      reportPanel.innerHTML =
        "<h3>Report tecnico automatico</h3><p>Analizza le immagini per generare il report.</p>";

      if (!files.length) {
        imagesReady = false;
        updateAnalyzeButton();
        fileListEl.innerHTML = "";
        mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
        statusEl.textContent = "Nessun file selezionato.";
        return;
      }

      files.sort((a, b) =>
        a.name.localeCompare(b.name, "it", { numeric: true })
      );

      statusEl.textContent = "Carico immagini...";
      try {
        const loaded = await Promise.all(files.map(loadImageFile));

        sessions = loaded.map((obj, idx) => ({
          index: idx,
          fileName: obj.file.name,
          img: obj.img,
          landmarks: null,
          keypoints2D: null,
          keypointsCanonical: null,
          spineCanonical: null,
          spineSpline: null,
          transform: null,
          depthMap: null,
          metrics: null,
          viewTypeAuto: "non determinata",
          viewTypeOverride: null,
          viewType: "non determinata",
          manualPoints: null,
          manualOffsets: null,
          spineSource: "auto"
        }));

        imagesReady = true;
        rebuildFileList();
        updateAnalyzeButton();
        statusEl.textContent =
          "Immagini caricate. Premi Analizza per procedere.";
      } catch (err) {
        console.error("Errore caricando le immagini", err);
        statusEl.classList.add("error");
        statusEl.textContent = "Errore nel caricamento immagini.";
        imagesReady = false;
        updateAnalyzeButton();
      }
    });

    clearBtn.addEventListener("click", () => {
      fileInput.value = "";
      sessions = [];
      imagesReady = false;
      updateAnalyzeButton();
      fileListEl.innerHTML = "";
      mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
      statusEl.classList.remove("error");
      statusEl.textContent = "Pulito. Carica nuove foto per iniziare.";
      reportPanel.innerHTML =
        "<h3>Report tecnico automatico</h3><p>Analizza le immagini per generare il report.</p>";
    });

    analyzeBtn.addEventListener("click", () => {
      analyzeAllSessions();
    });

    [toggleSkeleton, toggleSpine, toggleVectors].forEach((el) =>
      el.addEventListener("change", () => renderSession(currentIndex))
    );

    lambdaSlider.addEventListener("input", () => {
      curveLambda = parseFloat(lambdaSlider.value);
      lambdaValue.textContent = curveLambda.toFixed(1);
      renderSession(currentIndex);
    });

    toggleManualBtn.addEventListener("click", () => {
      manualMode = !manualMode;
      if (manualMode) {
        lambdaBackup = curveLambda;
        curveLambda = 1;
        lambdaSlider.value = "1";
        lambdaValue.textContent = "1.0";
        lambdaSlider.disabled = true;

        toggleManualBtn.textContent = "Punti manuali: ON";
        toggleManualBtn.classList.add("active-manual");
        const s = sessions[currentIndex];
        if (s && s.keypointsCanonical) ensureManualControlPoints(s);
        statusEl.textContent =
          "Modalità punti manuali: λ fissato a 1. Trascina i marcatori tra bacino e testa.";
      } else {
        toggleManualBtn.textContent = "Punti manuali: OFF";
        toggleManualBtn.classList.remove("active-manual");
        lambdaSlider.disabled = false;
        curveLambda = parseFloat(lambdaBackup) || 2.5;
        lambdaSlider.value = String(curveLambda);
        lambdaValue.textContent = curveLambda.toFixed(1);
        statusEl.textContent = "Modalità punti manuali disattivata.";
      }
      renderSession(currentIndex);
    });

    undoPointBtn.addEventListener("click", () => {
      const s = sessions[currentIndex];
      if (!s || !s.manualPoints || s.manualPoints.length === 0) return;
      if (lastDraggedIndex < 0 || lastDraggedIndex >= s.manualPoints.length)
        return;
      const kpC = s.keypointsCanonical;
      if (!kpC || !kpC.pelvisCenter) return;

      const pelvisC = kpC.pelvisCenter;
      const headC = kpC.headCenter || kpC.neckBase || kpC.shoulderMid || pelvisC;
      const torsoVec = {
        x: headC.x - pelvisC.x,
        y: headC.y - pelvisC.y
      };

      const idx = lastDraggedIndex;
      const hi = idx / (s.manualPoints.length - 1);
      const baseX = pelvisC.x + torsoVec.x * hi;
      const baseY = pelvisC.y + torsoVec.y * hi;
      s.manualPoints[idx] = { x: baseX, y: baseY };
      rebuildSpineFromControlPoints(s);
      renderSession(currentIndex);
    });

    clearManualBtn.addEventListener("click", () => {
      const s = sessions[currentIndex];
      if (!s || !s.keypointsCanonical) return;
      s.manualPoints = null;
      s.manualOffsets = null;
      s.spineSource = "auto";
      if (s.spineCanonical) {
        const autoSpline = computeSpineSpline(
          s.spineCanonical.basePoints,
          SPINE_SAMPLES
        );
        s.spineSpline = autoSpline.points;
      } else {
        s.spineSpline = null;
      }
      lastDraggedIndex = -1;
      renderSession(currentIndex);
    });

    saveExampleBtn.addEventListener("click", () => {
      saveManualExampleCurrentSession();
    });

    enableLearning.addEventListener("change", () => {
      if (enableLearning.checked) {
        reapplyLearnedModelToAllSessions();
      } else {
        for (const s of sessions) {
          if (s.spineSource === "learned") {
            s.spineSource = "auto";
            if (s.spineCanonical) {
              const autoSpline = computeSpineSpline(
                s.spineCanonical.basePoints,
                SPINE_SAMPLES
              );
              s.spineSpline = autoSpline.points;
            }
          }
        }
        updateCharts();
        buildTechnicalReport();
        renderSession(currentIndex);
        statusEl.textContent =
          "Uso del modello appreso disattivato (solo stima automatica + curve manuali).";
      }
    });

    function endDrag() {
      if (isDraggingControl) {
        isDraggingControl = false;
        draggingControlIndex = -1;
      }
    }

    function pointerToCanvasCoords(evt) {
      const rect = mainCanvas.getBoundingClientRect();
      const scaleX = mainCanvas.width / rect.width;
      const scaleY = mainCanvas.height / rect.height;
      const x = (evt.clientX - rect.left) * scaleX;
      const y = (evt.clientY - rect.top) * scaleY;
      return { x, y };
    }

    mainCanvas.addEventListener("pointerdown", (e) => {
      if (!manualMode || !sessions.length) return;
      const s = sessions[currentIndex];
      if (!s || !s.manualPoints || !s.manualPoints.length) return;

      const { x, y } = pointerToCanvasCoords(e);

      const pts = s.manualPoints;
      let bestIdx = -1;
      let bestDist = Infinity;
      for (let i = 0; i < pts.length; i++) {
        const dx = pts[i].x - x;
        const dy = pts[i].y - y;
        const dist = Math.hypot(dx, dy);
        if (dist < bestDist) {
          bestDist = dist;
          bestIdx = i;
        }
      }

      if (bestIdx !== -1 && bestDist < 18) {
        isDraggingControl = true;
        draggingControlIndex = bestIdx;
        lastDraggedIndex = bestIdx;
        e.preventDefault();
      }
    });

    mainCanvas.addEventListener("pointermove", (e) => {
      if (!isDraggingControl || !sessions.length) return;
      const s = sessions[currentIndex];
      if (!s || !s.manualPoints || !s.manualPoints.length) return;

      const { x, y } = pointerToCanvasCoords(e);

      const kpC = s.keypointsCanonical;
      if (!kpC || !kpC.pelvisCenter) return;

      const pelvisC = kpC.pelvisCenter;
      const headC = kpC.headCenter || kpC.neckBase || kpC.shoulderMid || pelvisC;
      const torsoVec = {
        x: headC.x - pelvisC.x,
        y: headC.y - pelvisC.y
      };

      const idx = draggingControlIndex;
      const hi = idx / (s.manualPoints.length - 1);
      const baseX = pelvisC.x + torsoVec.x * hi;
      const baseY = pelvisC.y + torsoVec.y * hi;

      const newX = x;
      const newY = baseY;

      s.manualPoints[idx] = { x: newX, y: newY };
      rebuildSpineFromControlPoints(s);
      renderSession(currentIndex);
      e.preventDefault();
    });

    mainCanvas.addEventListener("pointerup", endDrag);
    mainCanvas.addEventListener("pointercancel", endDrag);
    mainCanvas.addEventListener("pointerleave", endDrag);

    if (downloadModelBtn) {
      downloadModelBtn.addEventListener("click", () => {
        try {
          const blob = new Blob(
            [JSON.stringify(trainingExamples, null, 2)],
            { type: "text/plain;charset=utf-8" }
          );
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "scoliosis_model.txt";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (err) {
          console.error("Errore esportando il modello", err);
          statusEl.classList.add("error");
          statusEl.textContent = "Errore durante l'esportazione del modello in txt.";
        }
      });
    }

    if (modelFileInput) {
      modelFileInput.addEventListener("change", (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const txt = ev.target.result;
            const arr = JSON.parse(txt);
            if (!Array.isArray(arr)) throw new Error("Formato non valido");
            trainingExamples = arr.filter(
              (ex) =>
                Array.isArray(ex.features) &&
                Array.isArray(ex.offsets) &&
                ex.offsets.length === SPINE_SAMPLES
            );
            saveTrainingExamples();
            recomputeModelErrorHistory();
            statusEl.classList.remove("error");
            statusEl.textContent = `Modello caricato da file. Esempi: ${trainingExamples.length}.`;
            reapplyLearnedModelToAllSessions();
          } catch (err) {
            console.error("Errore nel leggere il modello", err);
            statusEl.classList.add("error");
            statusEl.textContent = "Errore nel formato del modello (txt/json).";
          }
        };
        reader.readAsText(file);
      });
    }

    loadTrainingExamples();
    initPoseLandmarker();
    initDepthEstimator();
  </script>
</body>
</html>
