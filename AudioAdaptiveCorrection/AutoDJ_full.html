<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phantom DJ - Hive Mind Edition</title>
    <script src="https://unpkg.com/meyda/dist/web/meyda.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, enableIndexedDbPersistence } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

        // --- 1. REPLACE THIS WITH YOUR FIREBASE CONFIG ---
        const firebaseConfig = {
          apiKey: "AIzaSyDJIzSP6ci_3djwGgwqnBlBGbcqTQLOcRQ",
          authDomain: "autodj-b79f7.firebaseapp.com",
          projectId: "autodj-b79f7",
          storageBucket: "autodj-b79f7.firebasestorage.app",
          messagingSenderId: "125149780002",
          appId: "1:125149780002:web:951a3acb1c6e648dd2127b",
          measurementId: "G-Y5648S9L7Q"
        };

        // --- 2. INITIALIZE FIREBASE ---
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Global references for the window object to access
        window.db = db;
        window.auth = auth;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.signInAnonymously = signInAnonymously;

        // Enable Offline Persistence (Firestore caches data automatically)
        enableIndexedDbPersistence(db).catch((err) => {
            console.log("Persistence disabled:", err.code);
        });

        console.log("Firebase initialized.");
    </script>

    <style>
        /* [KEEPING YOUR ORIGINAL STYLES - NO CHANGES HERE] */
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --accent-color: #00ffcc;
            --dislike-color: #ff3366;
            --like-color: #33ff99;
            --text-color: #e0e0e0;
            --warn-color: #ffaa00;
            --active-btn-bg: #00ffcc;
            --active-btn-text: #000;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        header {
            width: 100%;
            padding: 1rem;
            background-color: var(--panel-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.5rem; color: var(--accent-color); text-transform: uppercase; letter-spacing: 2px; }

        .controls { display: flex; gap: 10px; align-items: center; }

        button, select {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            font-family: inherit;
        }

        button:hover, select:hover { background-color: #444; border-color: var(--accent-color); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        button.active { background-color: var(--active-btn-bg); color: var(--active-btn-text); border-color: var(--active-btn-bg); }
        button.toggle-on { background-color: var(--accent-color); color: #000; }
        button.toggle-off { background-color: #333; color: #888; }

        select { padding-right: 25px; }

        #fileInput { display: none; }
        .file-label {
            background-color: var(--accent-color);
            color: #000;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #main-container {
            position: relative;
            width: 100%;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: radial-gradient(circle at center, #2a2a2a 0%, #000000 100%);
            box-shadow: inset 0 0 50px #000;
            cursor: crosshair;
        }

        #voting-panel {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #voting-panel.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .vote-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid #fff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: rgba(0,0,0,0.6);
            transition: transform 0.2s, background 0.2s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        .vote-btn:hover { transform: scale(1.1); }
        .vote-like:hover { background-color: var(--like-color); border-color: var(--like-color); color: #000; }
        .vote-dislike:hover { background-color: var(--dislike-color); border-color: var(--dislike-color); color: white; }

        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
            font-size: 0.9rem;
            border: 1px solid #444;
            transition: opacity 0.3s;
        }

        #harmonic-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            font-family: monospace;
            color: var(--accent-color);
            max-width: 300px;
        }

        #dev-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 340px;
            background-color: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            padding: 15px;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
            font-size: 0.85rem;
        }

        #dev-panel.visible { display: block; }

        .dev-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .dev-header h3 { margin: 0; color: var(--accent-color); font-size: 1rem; }
        .close-dev { cursor: pointer; color: #888; }

        .kernel-viz {
            display: flex;
            gap: 2px;
            margin-bottom: 15px;
            height: 40px;
            align-items: center;
            justify-content: center;
        }
        .kernel-cell {
            flex: 1;
            height: 100%;
            background: #333;
            border: 1px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: #fff;
            transition: background 0.3s;
        }

        .param-row { display: flex; justify-content: space-between; margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .param-name { color: #aaa; }
        .param-val { color: #fff; font-weight: bold; }

        .sub-header { color: #888; font-size: 0.75rem; margin: 10px 0 5px; text-transform: uppercase; border-bottom: 1px dashed #444; }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            max-height: 80vh;
            overflow-y: auto;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 0.8rem; }
        .color-dot { width: 10px; height: 10px; border-radius: 50%; }

        #training-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #training-overlay.active { display: flex; }

        .progress-container {
            width: 60%;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            margin-top: 20px;
            overflow: hidden;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.1s linear;
        }

        .training-text {
            color: white;
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
        }
        #overlay h2 { color: var(--accent-color); margin-bottom: 20px; }
        #overlay p { max-width: 600px; margin-bottom: 30px; line-height: 1.6; }

        /* Status Indicator for Sync */
        #sync-status {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: #555;
            z-index: 999;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #sync-status.online { background-color: var(--like-color); box-shadow: 0 0 10px var(--like-color); }
        #sync-status.offline { background-color: var(--dislike-color); }
        #sync-status.syncing { background-color: var(--warn-color); animation: blink 1s infinite; }

        @keyframes blink { 50% { opacity: 0.5; } }

    </style>
</head>
<body>

    <div id="sync-status" title="Connection Status"></div>

    <header>
        <h1>Phantom DJ <span style="font-size:0.8rem; color:#888;">// Hive Mind</span></h1>
        <div class="controls">
            <button id="btn-aug" class="toggle-on">Aug: ON</button>
            <select id="beatSelect">
                <option value="4.0" selected>4 Beats</option>
                <option value="8.0">8 Beats</option>
                <option value="16.0">16 Beats</option>
            </select>
            <button id="btn-dev">üß† Neural View</button>
            <button id="btn-play" disabled>‚ñ∂ PLAY / AUTO</button>
            <button id="btn-stop" disabled>‚ñ† STOP</button>
            <label for="fileInput" class="file-label">+ Tracks</label>
            <input type="file" id="fileInput" accept="audio/*" multiple>
        </div>
    </header>

    <div id="main-container">
        <canvas id="djCanvas"></canvas>
        <div id="harmonic-info">Mix Info: In attesa...</div>

        <div id="training-overlay">
            <div class="training-text">Addestramento Rete Neurale...</div>
            <div id="training-detail" style="color:#888; margin-bottom:10px;">Analisi sequenze</div>
            <div class="progress-container">
                <div id="train-progress" class="progress-bar"></div>
            </div>
        </div>

        <div id="voting-panel">
            <button class="vote-btn vote-dislike" onclick="voteTransition(false)" title="Transizione pessima">üëé</button>
            <button class="vote-btn vote-like" onclick="voteTransition(true)" title="Ottima transizione!">üëç</button>
        </div>

        <div id="dev-panel">
            <div class="dev-header">
                <h3>Global Neural Layer</h3>
                <span class="close-dev" onclick="toggleDevPanel()">‚úï</span>
            </div>

            <p style="margin:0 0 5px 0; color:#888; font-size:0.7rem;">Shared CNN Kernel</p>
            <div class="kernel-viz" id="cnn-viz"></div>

            <div class="sub-header">Weights</div>
            <div class="param-row"><span class="param-name">Vs. Current</span><span class="param-val" id="val-current">--</span></div>
            <div class="param-row"><span class="param-name">Vs. Next Natural</span><span class="param-val" id="val-nextnat">--</span></div>
            <div class="param-row"><span class="param-name">Harmonic</span><span class="param-val" id="val-harmony">--</span></div>
            <div class="param-row"><span class="param-name">BPM</span><span class="param-val" id="val-bpm">--</span></div>

            <div style="text-align: center; margin-top: 15px;">
                <button onclick="forceSync()" style="width: 100%; font-size: 0.8rem;">Force Cloud Sync</button>
                <div style="font-size:0.7rem; color:#666; margin-top:5px;" id="db-status-text">Using Local Brain</div>
            </div>
        </div>

        <div class="legend" id="trackLegend"></div>
        <div id="status">Connecting to Hive Mind...</div>

        <div id="overlay">
            <h2>Phantom DJ: Hive Mind</h2>
            <p>
                1. Carica file audio.<br>
                2. <strong>AI Condivisa</strong>: Il modello impara dai voti di TUTTI gli utenti.<br>
                3. Funziona offline e sincronizza quando torni online.
            </p>
            <label for="fileInput" class="file-label" style="font-size: 1.2rem; padding: 15px 30px;">CARICA AUDIO</label>
        </div>
    </div>

<script>
// --- FIREBASE LOGIC HELPERS ---
const COLLECTION_NAME = "phantom_brains";
const DOC_ID = "global_v1"; // Single document for the shared mind
let isOnline = navigator.onLine;
let pendingChanges = false;

function updateSyncStatus(status) {
    const el = document.getElementById('sync-status');
    if(status === 'online') { el.className = 'online'; el.title="Online & Synced"; }
    else if(status === 'offline') { el.className = 'offline'; el.title="Offline (Local Mode)"; }
    else if(status === 'syncing') { el.className = 'syncing'; el.title="Syncing to Cloud..."; }
}

window.addEventListener('online', () => { isOnline = true; updateSyncStatus('online'); syncBrainToCloud(); });
window.addEventListener('offline', () => { isOnline = false; updateSyncStatus('offline'); });

// --- CONFIGURATION ---
const CONFIG = {
    defaultBpm: 120, beatsPerSegment: 4, crossfade: 0.05, maxSamples: 1500,
    silenceThreshold: 0.01, enablePitchAug: true, semitoneShifts: [-1, 0, 1],
    bufferSize: 4096, mixThreshold: 8.0,
    learningRate: 0.05, momentum: 0.9, batchSize: 16, memorySize: 200
};

const FADE_RES = 100;
const FADE_IN_CURVE = new Float32Array(FADE_RES);
const FADE_OUT_CURVE = new Float32Array(FADE_RES);
for (let i = 0; i < FADE_RES; i++) {
    const x = i / (FADE_RES - 1);
    FADE_IN_CURVE[i] = Math.sin(x * Math.PI / 2);
    FADE_OUT_CURVE[i] = Math.cos(x * Math.PI / 2);
}

// --- NEURAL MODEL DEFINITION ---
let AI_MODEL = {
    cnnKernel: new Array(13).fill(0.5),
    contextWeights: { wCurrent: 2.0, wNextNat: 4.0, wPrev1: 1.0, wPrev2: 0.5 },
    denseWeights: { posFlow: 3.0, harmony: 2.0, bpm: 3.5, rmsDelta: 1.5, flatnessDelta: 2.5 }
};

let MODEL_MOMENTUM = {
    cnnKernel: new Array(13).fill(0),
    contextWeights: { wCurrent:0, wNextNat:0, wPrev1:0, wPrev2:0 },
    denseWeights: { posFlow:0, harmony:0, bpm:0, rmsDelta:0, flatnessDelta:0 }
};

let replayMemory = [];
const DEFAULT_MODEL = JSON.parse(JSON.stringify(AI_MODEL));
const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

// --- GLOBAL STATE ---
let audioCtx;
let loadedTracks = [];
let sampleLibrary = [];
let trailHistory = [];
let playQueue = [];
let isPlaying = false;
let nextStartTime = 0;
let currentSampleIndex = -1;
let prevSampleIndex = -1;
let userNextSelection = -1;
let playLoopId;
let canvas, ctx;
let currentBpm = 120;
let lastEffectiveKeyIndex = -1;
let contextHistory = [];
let lastInputVector = null;

// --- SHARED BRAIN LOGIC ---

// 1. Initialize: Try Cloud -> Fail -> LocalStorage -> Fail -> Create New
async function initBrain() {
    updateSyncStatus('syncing');
    updateStatus("Logging in anonymously...");

    try {
        // Wait for Firebase to load modules
        if(!window.auth) throw new Error("Firebase not loaded yet");

        await window.signInAnonymously(window.auth);
        updateStatus("Checking Hive Mind...");

        const docRef = window.doc(window.db, COLLECTION_NAME, DOC_ID);
        const docSnap = await window.getDoc(docRef);

        if (docSnap.exists()) {
            console.log("Found Global Brain!");
            const data = docSnap.data();
            applyModelData(data);
            document.getElementById('db-status-text').innerText = "Using Global Brain";
            localStorage.setItem('phantom_dj_brain', JSON.stringify(AI_MODEL)); // Cache it
        } else {
            console.log("No Global Brain found. Creating Genesis Block...");
            await window.setDoc(docRef, AI_MODEL);
            document.getElementById('db-status-text').innerText = "Genesis Brain Created";
        }
        updateSyncStatus('online');
    } catch (e) {
        console.warn("Offline or Error:", e);
        updateSyncStatus('offline');
        // Fallback to local
        const saved = localStorage.getItem('phantom_dj_brain');
        if (saved) {
            applyModelData(JSON.parse(saved));
            document.getElementById('db-status-text').innerText = "Using Local Backup";
        }
    }
    updateNeuralUI();
    updateStatus("Ready.");
}

function applyModelData(parsed) {
    if(parsed.cnnKernel) AI_MODEL.cnnKernel = parsed.cnnKernel;
    if(parsed.contextWeights) Object.assign(AI_MODEL.contextWeights, parsed.contextWeights);
    if(parsed.denseWeights) Object.assign(AI_MODEL.denseWeights, parsed.denseWeights);
}

// 2. Save: Local (Fast) -> Cloud (Async)
async function saveBrain() {
    // 1. Local Persistence (Instant)
    localStorage.setItem('phantom_dj_brain', JSON.stringify(AI_MODEL));

    // 2. Cloud Persistence
    if (isOnline && window.db) {
        updateSyncStatus('syncing');
        try {
            const docRef = window.doc(window.db, COLLECTION_NAME, DOC_ID);
            // We use setDoc with merge:true, though strictly we are overwriting the weights
            await window.setDoc(docRef, AI_MODEL);
            updateSyncStatus('online');
            pendingChanges = false;
            console.log("Brain synced to cloud.");
        } catch (e) {
            console.error("Sync failed:", e);
            updateSyncStatus('offline');
            pendingChanges = true;
        }
    } else {
        pendingChanges = true;
        updateSyncStatus('offline');
    }
}

async function forceSync() {
    await saveBrain();
}

async function syncBrainToCloud() {
    if(pendingChanges) {
        console.log("Back online. Syncing pending changes...");
        await saveBrain();
    }
}

// --- STANDARD APP LOGIC (Unchanged mostly) ---

function startPreTraining() {
    const sequences = sampleLibrary.filter(s => s.semitone === 0);
    const trainingPairs = [];
    for(let i=0; i<sequences.length-1; i++) {
        const u = sequences[i]; const v = sequences[i+1];
        if(u.trackIndex === v.trackIndex && v.id === u.id + 1) trainingPairs.push({ u: u.id, v: v.id });
    }
    if(trainingPairs.length === 0) { finishPreTraining(); return; }
    document.getElementById('training-overlay').classList.add('active');
    const progressBar = document.getElementById('train-progress');
    const detailText = document.getElementById('training-detail');
    let processed = 0; const total = trainingPairs.length; const batchSize = 10;
    trainingPairs.sort(() => Math.random() - 0.5);

    function processBatch() {
        const end = Math.min(processed + batchSize, total);
        for(let i=processed; i<end; i++) {
            const pair = trainingPairs[i];
            const vec = extractTransitionVector(pair.u, pair.v, true);
            replayMemory.push({ input: vec, label: -1 });
            if(replayMemory.length > CONFIG.memorySize) replayMemory.shift();
        }
        trainFromBuffer(false); // Don't sync during pre-training loop
        processed = end;
        progressBar.style.width = (processed / total) * 100 + '%';
        detailText.innerText = `Appreso ${processed} di ${total}...`;
        if(processed < total) requestAnimationFrame(processBatch);
        else setTimeout(finishPreTraining, 500);
    }
    requestAnimationFrame(processBatch);
}

function finishPreTraining() {
    document.getElementById('training-overlay').classList.remove('active');
    updateStatus(`Training Locale Completato.`);
    saveBrain(); // Sync once at end
    updateNeuralUI();
    document.getElementById('btn-play').disabled = false;
}

function voteTransition(isPositive) {
    if (!lastInputVector) return;
    const label = isPositive ? -1 : 1;
    replayMemory.push({ input: lastInputVector, label: label });
    if (replayMemory.length > CONFIG.memorySize) replayMemory.shift();
    trainFromBuffer(true); // Sync after vote
    updateStatus(isPositive ? "Appreso (üëç) & Syncing..." : "Appreso (üëé) & Syncing...");
    document.getElementById('voting-panel').classList.remove('visible');
    lastInputVector = null;
}

function trainFromBuffer(shouldSync = false) {
    if (replayMemory.length === 0) return;
    const batch = [];
    const size = Math.min(replayMemory.length, CONFIG.batchSize);
    const indices = [];
    while(indices.length < size) {
        const r = Math.floor(Math.random() * replayMemory.length);
        if(!indices.includes(r)) indices.push(r);
    }
    indices.forEach(i => batch.push(replayMemory[i]));

    let gradCNN = new Array(13).fill(0);
    let gradCtx = { wCurrent:0, wNextNat:0, wPrev1:0, wPrev2:0 };
    let gradDense = { posFlow:0, harmony:0, bpm:0, rmsDelta:0, flatnessDelta:0 };

    batch.forEach(exp => {
        const dir = exp.label; const vec = exp.input;
        for(let i=0; i<13; i++) gradCNN[i] += dir * vec.mfccDiff[i];
        if(vec.distCurrent !== undefined) gradCtx.wCurrent += dir * vec.distCurrent;
        if(vec.distNextNat !== undefined) gradCtx.wNextNat += dir * vec.distNextNat;
        if(vec.distPrev1 !== undefined) gradCtx.wPrev1 += dir * vec.distPrev1;
        if(vec.distPrev2 !== undefined) gradCtx.wPrev2 += dir * vec.distPrev2;
        gradDense.posFlow += dir * vec.posFlow;
        gradDense.harmony += dir * (vec.harmony / 6.0);
        gradDense.bpm += dir * vec.bpm;
        gradDense.rmsDelta += dir * vec.rmsDelta;
        gradDense.flatnessDelta += dir * vec.flatnessDelta;
    });

    for(let i=0; i<13; i++) gradCNN[i] /= size;
    for(let k in gradCtx) gradCtx[k] /= size;
    for(let k in gradDense) gradDense[k] /= size;
    applyGradients(gradCNN, gradCtx, gradDense, shouldSync);
}

function applyGradients(gradCNN, gradCtx, gradDense, shouldSync) {
    const lr = CONFIG.learningRate;
    const alpha = CONFIG.momentum;
    for(let i=0; i<13; i++) {
        MODEL_MOMENTUM.cnnKernel[i] = alpha * MODEL_MOMENTUM.cnnKernel[i] + (1-alpha) * gradCNN[i];
        AI_MODEL.cnnKernel[i] += lr * MODEL_MOMENTUM.cnnKernel[i];
        AI_MODEL.cnnKernel[i] = Math.max(0, Math.min(10, AI_MODEL.cnnKernel[i]));
    }
    for(let k in AI_MODEL.contextWeights) {
        MODEL_MOMENTUM.contextWeights[k] = alpha * MODEL_MOMENTUM.contextWeights[k] + (1-alpha) * gradCtx[k];
        AI_MODEL.contextWeights[k] += lr * MODEL_MOMENTUM.contextWeights[k];
        AI_MODEL.contextWeights[k] = Math.max(0, Math.min(10, AI_MODEL.contextWeights[k]));
    }
    for(let k in AI_MODEL.denseWeights) {
        MODEL_MOMENTUM.denseWeights[k] = alpha * MODEL_MOMENTUM.denseWeights[k] + (1-alpha) * gradDense[k];
        AI_MODEL.denseWeights[k] += lr * MODEL_MOMENTUM.denseWeights[k];
        AI_MODEL.denseWeights[k] = Math.max(0, Math.min(10, AI_MODEL.denseWeights[k]));
    }
    updateNeuralUI();
    if(shouldSync) saveBrain();
}

function updateNeuralUI() {
    const container = document.getElementById('cnn-viz');
    if(container) {
        container.innerHTML = '';
        AI_MODEL.cnnKernel.forEach(w => {
            const cell = document.createElement('div');
            cell.className = 'kernel-cell';
            const intensity = Math.min(1, w / 5);
            const r = Math.floor(intensity * 255);
            const b = Math.floor((1-intensity) * 255);
            cell.style.backgroundColor = `rgb(${r}, 0, ${b})`;
            cell.innerText = w.toFixed(1);
            container.appendChild(cell);
        });
    }
    const setVal = (id, val) => { const el = document.getElementById(id); if(el) el.innerText = val.toFixed(2); };
    setVal('val-current', AI_MODEL.contextWeights.wCurrent);
    setVal('val-nextnat', AI_MODEL.contextWeights.wNextNat);
    setVal('val-harmony', AI_MODEL.denseWeights.harmony);
    setVal('val-bpm', AI_MODEL.denseWeights.bpm);
}

function toggleDevPanel() {
    const panel = document.getElementById('dev-panel');
    panel.classList.toggle('visible');
    const btn = document.getElementById('btn-dev');
    if (panel.classList.contains('visible')) {
        btn.classList.add('active');
        updateNeuralUI();
    } else {
        btn.classList.remove('active');
    }
}

// --- AUDIO ENGINE ---
function initAudioContext() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

async function handleFiles(files) {
    initAudioContext();
    document.getElementById('overlay').style.display = 'none';
    const colors = ['#00ffcc', '#ff0055', '#ffff00', '#0099ff', '#ff9900', '#cc00ff'];
    if (typeof Meyda === 'undefined') { alert("Errore: Libreria Meyda non caricata."); return; }

    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        updateStatus(`Decodifica: ${file.name}...`);
        try {
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            const detectedBpm = detectBPM(audioBuffer);
            loadedTracks.push({
                buffer: audioBuffer, name: file.name, color: colors[loadedTracks.length % colors.length],
                bpm: detectedBpm || CONFIG.defaultBpm, totalDuration: audioBuffer.duration
            });
            updateLegend();
        } catch (e) { console.error("Errore:", e); updateStatus(`Errore lettura ${file.name}`); }
    }
    if (loadedTracks.length > 0) resegmentAll();
}

function detectBPM(buffer) {
    try {
        const data = buffer.getChannelData(0);
        const sr = buffer.sampleRate;
        const max = Math.min(data.length, sr * 30);
        let peaks = [];
        for (let i = 0; i < max; i += 4000) {
            let m = 0; for(let j=0; j<4000; j++) if(Math.abs(data[i+j]) > m) m = Math.abs(data[i+j]);
            if(m > 0.3) peaks.push(i);
        }
        if(peaks.length < 5) return 120;
        let intervals = {};
        for(let i=1; i<peaks.length; i++) {
            let inv = peaks[i] - peaks[i-1];
            if(inv > sr*0.3 && inv < sr*1.5) {
                let q = Math.round(inv/1000)*1000; intervals[q] = (intervals[q]||0)+1;
            }
        }
        let best = sr; let maxC = 0;
        for(let k in intervals) if(intervals[k]>maxC) { maxC=intervals[k]; best=parseInt(k); }
        let bpm = 60 / (best/sr);
        while(bpm<75) bpm*=2; while(bpm>160) bpm/=2;
        return Math.round(bpm);
    } catch(e) { return 120; }
}

function getSegmentDuration(bpm) { return (60 / bpm) * CONFIG.beatsPerSegment; }

function resegmentAll() {
    sampleLibrary = []; currentSampleIndex = -1; stopDJ(); playQueue = [];
    updateStatus(`Neural Analysis (${CONFIG.beatsPerSegment} beats)...`);
    setTimeout(() => {
        loadedTracks.forEach((track, idx) => {
            processAudioBuffer(track.buffer, idx, track.bpm, track.totalDuration);
        });
        if (sampleLibrary.length > 0) {
            calculateSpace();
            startPreTraining();
            drawCanvas();
        }
    }, 100);
}

function processAudioBuffer(buffer, trackIndex, bpm, totalDuration) {
    const rawData = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;
    const duration = getSegmentDuration(bpm);
    const samplesPerSegment = Math.floor(duration * sampleRate);
    const variants = [];
    if (CONFIG.enablePitchAug) CONFIG.semitoneShifts.forEach(st => variants.push({ type: 'pitch', val: st }));
    else variants.push({ type: 'pitch', val: 0 });

    const trackSegments = [];
    for (let i = 0; i < rawData.length; i += samplesPerSegment) {
        if (sampleLibrary.length >= CONFIG.maxSamples) break;
        if (i + samplesPerSegment > rawData.length) break;
        const segmentRaw = rawData.slice(i, i + samplesPerSegment);
        const baseFeats = extractFeaturesWithMeyda(segmentRaw, CONFIG.bufferSize);
        if (baseFeats.rms < CONFIG.silenceThreshold) continue;
        const relPos = (i / sampleRate) / totalDuration;
        const timeSegmentVariants = [];
        variants.forEach(variant => {
            const semitone = variant.val;
            const rate = Math.pow(2, semitone / 12);
            let newKey = (baseFeats.keyIndex + semitone);
            newKey = ((newKey % 12) + 12) % 12;
            timeSegmentVariants.push({
                buffer: buffer, startFn: i / sampleRate, duration: duration,
                bpm: bpm * rate, baseRate: rate, semitone: semitone, features: baseFeats,
                trackIndex: trackIndex, relPos: relPos, key: newKey, type: 'body'
            });
        });
        trackSegments.push(timeSegmentVariants);
    }
    if (trackSegments.length > 0) {
        trackSegments[0].forEach(s => s.type = 'start');
        trackSegments[trackSegments.length - 1].forEach(s => s.type = 'end');
    }
    trackSegments.forEach(batch => batch.forEach(s => { s.id = sampleLibrary.length; sampleLibrary.push(s); }));
}

function extractFeaturesWithMeyda(signal, bufferSize) {
    let totalRms=0, frames=0, totalMfcc=new Array(13).fill(0), totalChroma=new Array(12).fill(0), totalFlatness=0;
    const hops = 6; const step = Math.floor((signal.length - bufferSize) / hops);
    if(step<1) return { rms:0, mfcc:new Array(13).fill(0), keyIndex:0, flatness:0 };
    for(let j=0; j<hops; j++) {
        const start = j*step; const chunk = signal.slice(start, start+bufferSize);
        if(chunk.length<bufferSize) break;
        try {
            const f = Meyda.extract(['rms', 'mfcc', 'chroma', 'spectralFlatness'], chunk);
            if(f) {
                totalRms+=f.rms; totalFlatness+=f.spectralFlatness;
                for(let k=0; k<13; k++) totalMfcc[k]+=f.mfcc[k];
                for(let k=0; k<12; k++) totalChroma[k]+=f.chroma[k];
                frames++;
            }
        } catch(e){}
    }
    if(frames===0) frames=1;
    const avgChroma = totalChroma.map(v=>v/frames);
    let maxK=-1, maxV=-1; for(let k=0; k<12; k++) if(avgChroma[k]>maxV){ maxV=avgChroma[k]; maxK=k; }
    return { rms: totalRms/frames, mfcc: totalMfcc.map(v=>v/frames), flatness: totalFlatness/frames, keyIndex: maxK };
}

function calculateSpace() {
    if (sampleLibrary.length === 0) return;
    const xVals = sampleLibrary.map(s => s.features.mfcc[1]);
    const yVals = sampleLibrary.map(s => s.features.mfcc[2]);
    const minX = Math.min(...xVals), maxX = Math.max(...xVals);
    const minY = Math.min(...yVals), maxY = Math.max(...yVals);
    const norm = (v, min, max) => (v - min) / (max - min || 1);
    sampleLibrary.forEach(s => {
        s.x = norm(s.features.mfcc[1], minX, maxX); s.y = norm(s.features.mfcc[2], minY, maxY);
        if(s.semitone !== 0) { s.x += s.semitone*0.015; s.y += s.semitone*0.015; }
        s.x += (Math.random()-0.5)*0.005; s.y += (Math.random()-0.5)*0.005;
    });
}

function startDJ() {
    if (isPlaying || sampleLibrary.length === 0) return;
    initAudioContext(); isPlaying = true;
    document.getElementById('btn-play').classList.add('active'); document.getElementById('btn-play').textContent = "ON AIR";
    document.getElementById('btn-stop').disabled = false; document.getElementById('beatSelect').disabled = true;
    nextStartTime = audioCtx.currentTime + 0.1;
    if (currentSampleIndex === -1) {
        const starts = sampleLibrary.filter(s => s.type === 'start');
        currentSampleIndex = starts.length > 0 ? starts[Math.floor(Math.random() * starts.length)].id : Math.floor(Math.random() * sampleLibrary.length);
    }
    prevSampleIndex = -1; userNextSelection = -1; trailHistory = []; contextHistory = [];
    currentBpm = sampleLibrary[currentSampleIndex].bpm; lastEffectiveKeyIndex = sampleLibrary[currentSampleIndex].key;
    scheduleNextSegment(); loop();
}

function stopDJ() {
    isPlaying = false; clearTimeout(playLoopId);
    document.getElementById('btn-play').classList.remove('active'); document.getElementById('btn-play').textContent = "‚ñ∂ PLAY / AUTO";
    document.getElementById('btn-stop').disabled = true; document.getElementById('beatSelect').disabled = false;
    document.getElementById('voting-panel').classList.remove('visible'); updateStatus("Stopped.");
}

function scheduleNextSegment() {
    if (!isPlaying) return;
    if (currentSampleIndex !== -1) { contextHistory.push(currentSampleIndex); if (contextHistory.length > 3) contextHistory.shift(); }
    if (playQueue.length > 0) { currentSampleIndex = playQueue.shift(); userNextSelection = -1; }
    else if (userNextSelection !== -1) { currentSampleIndex = userNextSelection; userNextSelection = -1; }
    else { currentSampleIndex = neuralPathfinder(currentSampleIndex); }

    const currentSample = sampleLibrary[currentSampleIndex];
    if (prevSampleIndex !== -1) {
        addTrail(prevSampleIndex, currentSampleIndex);
        document.getElementById('voting-panel').classList.add('visible');
        lastInputVector = extractTransitionVector(prevSampleIndex, currentSampleIndex);
    }

    let finalRate = currentSample.baseRate; let effectiveKey = currentSample.key;
    if (prevSampleIndex !== -1) {
        const syncFactor = currentBpm / currentSample.bpm;
        let safeSync = Math.max(0.8, Math.min(1.2, syncFactor));
        finalRate = currentSample.baseRate * safeSync;
        const syncShift = 12 * Math.log2(safeSync);
        effectiveKey = (currentSample.key + Math.round(syncShift)) % 12; if(effectiveKey < 0) effectiveKey += 12;
        currentBpm = currentBpm * 0.9 + currentSample.bpm * 0.1;
    } else { currentBpm = currentSample.bpm; }

    lastEffectiveKeyIndex = effectiveKey;
    playSegment(currentSample, nextStartTime, finalRate);

    const keyName = NOTES[effectiveKey];
    document.getElementById('harmonic-info').innerHTML = `Key: <strong>${keyName}</strong><br>BPM: ${Math.round(currentBpm)}<br>${playQueue.length > 0 ? '[Path]' : '[Auto]'}`;
    updateStatus(`Now: ${loadedTracks[currentSample.trackIndex].name} [${currentSample.type}]`);

    const effectiveDuration = currentSample.duration / finalRate;
    const overlap = CONFIG.crossfade;
    nextStartTime += (effectiveDuration - overlap);
    prevSampleIndex = currentSampleIndex;
    playLoopId = setTimeout(() => { scheduleNextSegment(); }, (effectiveDuration - overlap) * 1000);
}

function playSegment(sample, time, rate) {
    const source = audioCtx.createBufferSource(); source.buffer = sample.buffer; source.playbackRate.value = rate;
    const gainNode = audioCtx.createGain(); const filter = audioCtx.createBiquadFilter(); filter.type = "lowpass";
    source.connect(filter); filter.connect(gainNode); gainNode.connect(audioCtx.destination);
    source.start(time, sample.startFn, sample.duration);

    const fade = CONFIG.crossfade;
    gainNode.gain.setValueCurveAtTime(FADE_IN_CURVE, time, fade);
    filter.frequency.setValueAtTime(300, time); filter.frequency.exponentialRampToValueAtTime(20000, time + fade * 1.5);
    const effDur = sample.duration / rate; const end = time + effDur; const fadeOut = end - fade;
    if(effDur > fade*2) { filter.frequency.setValueAtTime(20000, fadeOut); filter.frequency.exponentialRampToValueAtTime(300, end); }
    gainNode.gain.setValueCurveAtTime(FADE_OUT_CURVE, fadeOut, fade);
}

// --- NEURAL MATH ---
function getFeaturesDist(s1, s2) {
    let sum = 0; for(let i=0; i<13; i++) sum += (s1.features.mfcc[i] - s2.features.mfcc[i])**2;
    return Math.sqrt(sum);
}

function extractTransitionVector(uIndex, vIndex, trainingMode = false) {
    const u = sampleLibrary[uIndex]; const v = sampleLibrary[vIndex];
    const mfccDiff = u.features.mfcc.map((val, k) => Math.abs(val - v.features.mfcc[k]));
    const rmsDelta = Math.abs(u.features.rms - v.features.rms);
    const flatnessDelta = Math.abs(u.features.flatness - v.features.flatness);
    const posFlow = (v.relPos < u.relPos) ? 1.0 : 0.0;
    const diffCircle = Math.abs((v.key - u.key) * 7) % 12;
    const harmony = Math.min(diffCircle, 12 - diffCircle);
    const bpmCost = Math.abs(u.bpm - v.bpm) / 10;
    const distCurrent = getFeaturesDist(u, v);
    let distNextNat = distCurrent;
    const nextNatIdx = uIndex + CONFIG.semitoneShifts.length;
    if (nextNatIdx < sampleLibrary.length && sampleLibrary[nextNatIdx].trackIndex === u.trackIndex) distNextNat = getFeaturesDist(sampleLibrary[nextNatIdx], v);
    let distPrev1 = distCurrent, distPrev2 = distCurrent;
    if(!trainingMode && contextHistory.length >= 2) distPrev1 = getFeaturesDist(sampleLibrary[contextHistory[contextHistory.length - 2]], v);
    if(!trainingMode && contextHistory.length >= 3) distPrev2 = getFeaturesDist(sampleLibrary[contextHistory[contextHistory.length - 3]], v);
    return { mfccDiff, rmsDelta, flatnessDelta, posFlow, harmony, bpm: bpmCost, distCurrent, distNextNat, distPrev1, distPrev2 };
}

function calculateNeuralCost(uIndex, vIndex) {
    const vec = extractTransitionVector(uIndex, vIndex);
    let cnn = 0; for(let i=0; i<13; i++) cnn += vec.mfccDiff[i] * AI_MODEL.cnnKernel[i];
    const cw = AI_MODEL.contextWeights;
    const ctx = (vec.distCurrent * cw.wCurrent) + (vec.distNextNat * cw.wNextNat) + (vec.distPrev1 * cw.wPrev1) + (vec.distPrev2 * cw.wPrev2);
    const w = AI_MODEL.denseWeights;
    const dense = (vec.rmsDelta * w.rmsDelta) + (vec.flatnessDelta * w.flatnessDelta) + (vec.posFlow * w.posFlow) + (vec.harmony * w.harmony) + (vec.bpm * w.bpm);
    return cnn + ctx + dense;
}

function neuralPathfinder(currentIndex) {
    const N = sampleLibrary.length; let candidates = []; const current = sampleLibrary[currentIndex];
    if (current.type === 'end') {
        const starts = sampleLibrary.filter(s => s.type === 'start' && s.trackIndex !== current.trackIndex);
        if (starts.length > 0) {
            starts.forEach(s => candidates.push({ idx: s.id, cost: calculateNeuralCost(currentIndex, s.id) }));
            candidates.sort((a,b) => a.cost - b.cost); return candidates[0].idx;
        } else return sampleLibrary.filter(s => s.type === 'start' && s.trackIndex === current.trackIndex)[0].id;
    }
    for(let i=0; i<60; i++) {
        const rnd = Math.floor(Math.random() * N); const cand = sampleLibrary[rnd];
        if(rnd === currentIndex || (cand.type === 'start' && cand.trackIndex !== current.trackIndex)) continue;
        candidates.push({ idx: rnd, cost: calculateNeuralCost(currentIndex, rnd) });
    }
    candidates.sort((a,b) => a.cost - b.cost);
    const best = candidates[0];
    const nextNatIdx = current.id + 1;
    let hasNat = (nextNatIdx < N && sampleLibrary[nextNatIdx].trackIndex === current.trackIndex && sampleLibrary[nextNatIdx].semitone === current.semitone);
    if (hasNat && best.cost > CONFIG.mixThreshold) return nextNatIdx;

    const topK = candidates.slice(0, 4); const r = Math.random();
    let selected = topK[0];
    if (topK.length > 1 && r > 0.5) selected = topK[1];
    if (topK.length > 2 && r > 0.8) selected = topK[2];
    if (topK.length > 3 && r > 0.95) selected = topK[3];
    return selected.idx;
}

function findPath(startIdx, endIdx) {
    const N = sampleLibrary.length; const dist = new Array(N).fill(Infinity); const prev = new Array(N).fill(null);
    const vis = new Array(N).fill(false); dist[startIdx] = 0; const q = [startIdx]; let iter = 0;
    while(q.length > 0 && iter++ < 1500) {
        let u = -1, min = Infinity, uIdx = -1;
        for(let i=0; i<q.length; i++) if(dist[q[i]] < min) { min=dist[q[i]]; u=q[i]; uIdx=i; }
        if(u===-1 || u===endIdx) break;
        q.splice(uIdx, 1); vis[u] = true;
        for(let v=0; v<N; v++) {
            if(!vis[v]) {
                if(Math.abs(sampleLibrary[u].x - sampleLibrary[v].x) > 0.4) continue;
                const alt = dist[u] + calculateNeuralCost(u, v);
                if(alt < dist[v]) { dist[v] = alt; prev[v] = u; if(!q.includes(v)) q.push(v); }
            }
        }
    }
    const path = []; let curr = endIdx;
    if(prev[curr] !== null || curr === startIdx) { while(curr !== null) { path.unshift(curr); curr = prev[curr]; } }
    if(path.length>0 && path[0]===startIdx) path.shift();
    return path;
}

// --- VISUALIZATION ---
function initCanvas() {
    canvas = document.getElementById('djCanvas'); ctx = canvas.getContext('2d');
    resizeCanvas(); window.addEventListener('resize', resizeCanvas); canvas.addEventListener('mousedown', handleCanvasClick);
    initBrain(); // Start the sync process
    animate();
}
function resizeCanvas() { canvas.width = document.getElementById('main-container').offsetWidth; canvas.height = document.getElementById('main-container').offsetHeight; }
function handleCanvasClick(e) {
    const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
    let closestIdx = -1; let minVisualDist = 30;
    sampleLibrary.forEach((s, idx) => {
        const sx = s.x * canvas.width * 0.8 + canvas.width * 0.1; const sy = s.y * canvas.height * 0.8 + canvas.height * 0.1;
        const dist = Math.sqrt((x - sx)**2 + (y - sy)**2);
        if (dist < minVisualDist) { minVisualDist = dist; closestIdx = idx; }
    });
    if (closestIdx !== -1) {
        if (!isPlaying) { userNextSelection = closestIdx; startDJ(); }
        else {
            updateStatus("Calculating Neural Path...");
            const startNode = playQueue.length > 0 ? playQueue[playQueue.length - 1] : currentSampleIndex;
            setTimeout(() => {
                const path = findPath(startNode, closestIdx);
                if (path.length > 0) { playQueue.push(...path); updateStatus(`Path added (+${path.length} steps).`); }
                else updateStatus("Cannot connect.");
            }, 10);
        }
    }
}
function addTrail(idxA, idxB) {
    const sA = sampleLibrary[idxA]; const sB = sampleLibrary[idxB];
    trailHistory.push({ x1: sA.x, y1: sA.y, x2: sB.x, y2: sB.y, life: 180, maxLife: 180 });
}
function animate() {
    requestAnimationFrame(animate); ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    const w = canvas.width; const h = canvas.height; const margin = 0.1; const scale = 0.8;
    if (trailHistory.length > 0) {
        ctx.lineWidth = 2;
        for (let i = trailHistory.length - 1; i >= 0; i--) {
            const t = trailHistory[i]; const opacity = t.life / t.maxLife;
            const sx1 = t.x1 * w * scale + w * margin; const sy1 = t.y1 * h * scale + h * margin;
            const sx2 = t.x2 * w * scale + w * margin; const sy2 = t.y2 * h * scale + h * margin;
            ctx.beginPath(); ctx.moveTo(sx1, sy1); ctx.lineTo(sx2, sy2);
            ctx.strokeStyle = `rgba(0, 255, 204, ${opacity})`; ctx.stroke();
            t.life--; if (t.life <= 0) trailHistory.splice(i, 1);
        }
    }
    if (playQueue.length > 0 && currentSampleIndex !== -1) {
        let prevIdx = currentSampleIndex; ctx.lineWidth = 1; ctx.setLineDash([5, 5]); ctx.strokeStyle = '#ffffff';
        for (let nextIdx of playQueue) {
            const s = sampleLibrary[prevIdx]; const n = sampleLibrary[nextIdx];
            const sx = s.x * w * scale + w * margin; const sy = s.y * h * scale + h * margin;
            const nx = n.x * w * scale + w * margin; const ny = n.y * h * scale + h * margin;
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(nx, ny); ctx.stroke(); prevIdx = nextIdx;
        }
        ctx.setLineDash([]);
    }
    sampleLibrary.forEach((s, idx) => {
        const x = s.x * w * scale + w * margin; const y = s.y * h * scale + h * margin;
        const color = loadedTracks[s.trackIndex].color;
        ctx.beginPath();
        if (idx === currentSampleIndex) {
            const pulse = 10 + Math.sin(Date.now() / 100) * 5;
            if (s.type === 'start') drawTriangle(ctx, x, y, pulse); else if (s.type === 'end') drawSquare(ctx, x, y, pulse); else ctx.arc(x, y, pulse, 0, Math.PI * 2);
            ctx.fillStyle = 'white'; ctx.fill(); ctx.strokeStyle = color; ctx.stroke();
            ctx.fillStyle = '#fff'; ctx.font = '12px Arial';
            ctx.fillText(NOTES[(idx===currentSampleIndex&&lastEffectiveKeyIndex!==-1)?lastEffectiveKeyIndex:s.key], x + 15, y + 4);
        } else {
            let radius = s.semitone === 0 ? 3 : 1; if (playQueue.includes(idx)) radius = 4;
            ctx.globalAlpha = s.semitone === 0 ? 1.0 : 0.7;
            if (s.type === 'start') drawTriangle(ctx, x, y, radius + 2); else if (s.type === 'end') drawSquare(ctx, x, y, radius + 1); else ctx.arc(x, y, radius, 0, Math.PI * 2);
            if (playQueue.includes(idx)) { ctx.fillStyle = 'white'; ctx.fill(); ctx.strokeStyle = color; ctx.stroke(); } else { ctx.fillStyle = color; ctx.fill(); }
            ctx.globalAlpha = 1.0;
        }
        ctx.closePath();
    });
}
function drawTriangle(ctx, x, y, size) { ctx.moveTo(x, y - size); ctx.lineTo(x + size, y + size); ctx.lineTo(x - size, y + size); ctx.lineTo(x, y - size); }
function drawSquare(ctx, x, y, size) { ctx.rect(x - size, y - size, size * 2, size * 2); }
function updateStatus(msg) { document.getElementById('status').innerText = msg; document.getElementById('status').style.opacity = 1; }
function updateLegend() {
    const legend = document.getElementById('trackLegend'); legend.innerHTML = '';
    loadedTracks.forEach(t => {
        const div = document.createElement('div'); div.className = 'legend-item';
        div.innerHTML = `<div class="color-dot" style="background-color:${t.color}"></div><span>${t.name} <small>(${t.bpm} BPM)</small></span>`;
        legend.appendChild(div);
    });
}
document.getElementById('beatSelect').addEventListener('change', (e) => { CONFIG.beatsPerSegment = parseFloat(e.target.value); if (loadedTracks.length > 0) resegmentAll(); });
document.getElementById('btn-dev').addEventListener('click', toggleDevPanel);
document.getElementById('btn-aug').addEventListener('click', () => { CONFIG.enablePitchAug = !CONFIG.enablePitchAug; document.getElementById('btn-aug').innerText = CONFIG.enablePitchAug ? "Aug: ON" : "Aug: OFF"; if (loadedTracks.length > 0) resegmentAll(); });
window.onload = () => { initCanvas(); document.getElementById('fileInput').addEventListener('change', (e) => handleFiles(e.target.files)); document.getElementById('btn-play').addEventListener('click', startDJ); document.getElementById('btn-stop').addEventListener('click', stopDJ); };
</script>
</body>
</html>