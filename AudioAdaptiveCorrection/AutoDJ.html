<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phantom DJ - Generalized Learning AI</title>
    <!-- Importazione Meyda per Feature Extraction Professionale -->
    <script src="https://unpkg.com/meyda/dist/web/meyda.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --accent-color: #00ffcc;
            --dislike-color: #ff3366;
            --like-color: #33ff99;
            --text-color: #e0e0e0;
            --warn-color: #ffaa00;
            --active-btn-bg: #00ffcc;
            --active-btn-text: #000;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        header {
            width: 100%;
            padding: 1rem;
            background-color: var(--panel-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.5rem; color: var(--accent-color); text-transform: uppercase; letter-spacing: 2px; }

        .controls { display: flex; gap: 10px; align-items: center; }

        button, select {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            font-family: inherit;
        }

        button:hover, select:hover { background-color: #444; border-color: var(--accent-color); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        button.active { background-color: var(--active-btn-bg); color: var(--active-btn-text); border-color: var(--active-btn-bg); }
        button.toggle-on { background-color: var(--accent-color); color: #000; }
        button.toggle-off { background-color: #333; color: #888; }

        select { padding-right: 25px; }

        #fileInput { display: none; }
        .file-label {
            background-color: var(--accent-color);
            color: #000;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #main-container {
            position: relative;
            width: 100%;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: radial-gradient(circle at center, #2a2a2a 0%, #000000 100%);
            box-shadow: inset 0 0 50px #000;
            cursor: crosshair;
        }

        #voting-panel {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #voting-panel.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .vote-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid #fff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: rgba(0,0,0,0.6);
            transition: transform 0.2s, background 0.2s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        .vote-btn:hover { transform: scale(1.1); }
        .vote-like:hover { background-color: var(--like-color); border-color: var(--like-color); color: #000; }
        .vote-dislike:hover { background-color: var(--dislike-color); border-color: var(--dislike-color); color: white; }

        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
            font-size: 0.9rem;
            border: 1px solid #444;
            transition: opacity 0.3s;
        }

        #harmonic-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            font-family: monospace;
            color: var(--accent-color);
            max-width: 300px;
        }

        /* Developer Tools Panel */
        #dev-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 340px;
            background-color: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            padding: 15px;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
            font-size: 0.85rem;
        }

        #dev-panel.visible { display: block; }

        .dev-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .dev-header h3 { margin: 0; color: var(--accent-color); font-size: 1rem; }
        .close-dev { cursor: pointer; color: #888; }

        /* CNN Kernel Visualizer */
        .kernel-viz {
            display: flex;
            gap: 2px;
            margin-bottom: 15px;
            height: 40px;
            align-items: center;
            justify-content: center;
        }
        .kernel-cell {
            flex: 1;
            height: 100%;
            background: #333;
            border: 1px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: #fff;
            transition: background 0.3s;
        }

        .param-row { display: flex; justify-content: space-between; margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .param-name { color: #aaa; }
        .param-val { color: #fff; font-weight: bold; }

        .sub-header { color: #888; font-size: 0.75rem; margin: 10px 0 5px; text-transform: uppercase; border-bottom: 1px dashed #444; }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            max-height: 80vh;
            overflow-y: auto;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 0.8rem; }
        .color-dot { width: 10px; height: 10px; border-radius: 50%; }

        /* Overlay iniziale */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            text-align: center;
        }
        #overlay h2 { color: var(--accent-color); margin-bottom: 20px; }
        #overlay p { max-width: 600px; margin-bottom: 30px; line-height: 1.6; }

    </style>
</head>
<body>

    <header>
        <h1>Phantom DJ <span style="font-size:0.8rem; color:#888;">// Generalized AI</span></h1>
        <div class="controls">
            <button id="btn-aug" class="toggle-on" title="Genera varianti di intonazione">Augmentation: ON</button>
            <select id="beatSelect">
                <option value="4.0" selected>4 Beats (1 Bar)</option>
                <option value="8.0">8 Beats (2 Bars)</option>
                <option value="16.0">16 Beats (4 Bars)</option>
                <option value="32.0">32 Beats (8 Bars)</option>
            </select>
            <button id="btn-dev">üß† Neural View</button>
            <button id="btn-play" disabled>‚ñ∂ PLAY / AUTO</button>
            <button id="btn-stop" disabled>‚ñ† STOP</button>
            <label for="fileInput" class="file-label">+ Aggiungi Tracce</label>
            <input type="file" id="fileInput" accept="audio/*" multiple>
        </div>
    </header>

    <div id="main-container">
        <canvas id="djCanvas"></canvas>
        <div id="harmonic-info">Mix Info: In attesa...</div>

        <!-- VOTING PANEL -->
        <div id="voting-panel">
            <button class="vote-btn vote-dislike" onclick="voteTransition(false)" title="Transizione pessima">üëé</button>
            <button class="vote-btn vote-like" onclick="voteTransition(true)" title="Ottima transizione!">üëç</button>
        </div>

        <!-- NEURAL VISUALIZER PANEL -->
        <div id="dev-panel">
            <div class="dev-header">
                <h3>Generalized Neural Decision</h3>
                <span class="close-dev" onclick="toggleDevPanel()">‚úï</span>
            </div>

            <p style="margin:0 0 5px 0; color:#888; font-size:0.7rem;">CNN Kernel (Learned Timbre)</p>
            <div class="kernel-viz" id="cnn-viz">
                <!-- Filled by JS -->
            </div>

            <div class="sub-header">History & Context Weights (Learned)</div>

            <div class="param-row">
                <span class="param-name">Vs. Current (T)</span>
                <span class="param-val" id="val-current">--</span>
            </div>
            <div class="param-row">
                <span class="param-name">Vs. Next Natural (T+1)</span>
                <span class="param-val" id="val-nextnat">--</span>
            </div>
            <div class="param-row">
                <span class="param-name">Vs. Previous (T-1)</span>
                <span class="param-val" id="val-prev1">--</span>
            </div>
            <div class="param-row">
                <span class="param-name">Vs. Pre-Previous (T-2)</span>
                <span class="param-val" id="val-prev2">--</span>
            </div>

            <div class="sub-header">Structural Constraints</div>

            <div class="param-row"><span class="param-name">Positional Flow</span><span class="param-val" id="val-flow">--</span></div>
            <div class="param-row"><span class="param-name">Harmonic Dist</span><span class="param-val" id="val-harmony">--</span></div>
            <div class="param-row"><span class="param-name">Rhythmic Imp.</span><span class="param-val" id="val-bpm">--</span></div>

            <div style="text-align: center; margin-top: 15px;">
                <button onclick="resetBrain()" style="width: 100%; font-size: 0.8rem;">Reset Neural Net</button>
                <div style="font-size:0.7rem; color:#666; margin-top:5px;">Brain persisted in LocalStorage</div>
            </div>
        </div>

        <div class="legend" id="trackLegend"></div>
        <div id="status">In attesa di file audio...</div>

        <div id="overlay">
            <h2>Benvenuto in Phantom DJ</h2>
            <p>
                1. Carica file audio (MP3, WAV).<br>
                2. <strong>Experience Replay</strong>: L'IA impara dai voti passati per generalizzare.<br>
                3. <strong>Visual cues</strong>: ‚ñ≤ Inizio, ‚ñ† Fine, ‚óè Corpo.<br>
                4. Vota per addestrare i pesi temporali.
            </p>
            <label for="fileInput" class="file-label" style="font-size: 1.2rem; padding: 15px 30px;">CARICA AUDIO</label>
        </div>
    </div>

<script>
/**
 * PHANTOM DJ WEB ENGINE - GENERALIZED LEARNING EDITION
 * Features:
 * - Experience Replay Buffer (Generalization)
 * - Batch Training (Stability)
 * - LocalStorage Persistence
 * - Input Normalization
 * - Visual indicators for Start (Triangle), End (Square) and Body (Circle)
 */

// --- CONFIGURAZIONE ---
const CONFIG = {
    defaultBpm: 120,
    beatsPerSegment: 4,
    crossfade: 0.15,
    maxSamples: 1500,
    silenceThreshold: 0.01,
    enablePitchAug: true,
    semitoneShifts: [-1, 0, 1],
    bufferSize: 4096,

    // Hyperparameters
    learningRate: 0.05,
    momentum: 0.9,
    batchSize: 8,
    memorySize: 50
};

// --- NEURAL MODEL DEFINITION ---
let AI_MODEL = {
    cnnKernel: new Array(13).fill(0.5),
    contextWeights: {
        wCurrent: 2.0, wNextNat: 4.0, wPrev1: 1.0, wPrev2: 0.5
    },
    denseWeights: {
        posFlow: 3.0, harmony: 2.0, bpm: 3.5, rmsDelta: 1.5, flatnessDelta: 2.5
    }
};

// Momentum Buffers
let MODEL_MOMENTUM = {
    cnnKernel: new Array(13).fill(0),
    contextWeights: { wCurrent:0, wNextNat:0, wPrev1:0, wPrev2:0 },
    denseWeights: { posFlow:0, harmony:0, bpm:0, rmsDelta:0, flatnessDelta:0 }
};

// Experience Replay Buffer
let replayMemory = [];

const DEFAULT_MODEL = JSON.parse(JSON.stringify(AI_MODEL));
const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

// --- GLOBAL STATE ---
let audioCtx;
let loadedTracks = [];
let sampleLibrary = [];
let trailHistory = [];
let playQueue = [];
let isPlaying = false;
let nextStartTime = 0;
let currentSampleIndex = -1;
let prevSampleIndex = -1;
let userNextSelection = -1;
let playLoopId;
let canvas, ctx;
let currentBpm = 120;
let lastEffectiveKeyIndex = -1;
let contextHistory = [];
let lastInputVector = null;

// --- INITIALIZATION ---
function initBrain() {
    const saved = localStorage.getItem('phantom_dj_brain');
    if (saved) {
        try {
            const parsed = JSON.parse(saved);
            // Merge safe
            if(parsed.cnnKernel) AI_MODEL.cnnKernel = parsed.cnnKernel;
            if(parsed.contextWeights) Object.assign(AI_MODEL.contextWeights, parsed.contextWeights);
            if(parsed.denseWeights) Object.assign(AI_MODEL.denseWeights, parsed.denseWeights);
            console.log("Brain loaded from storage.");
        } catch(e) { console.warn("Invalid brain storage, using default."); }
    }
    updateNeuralUI();
}

function saveBrain() {
    localStorage.setItem('phantom_dj_brain', JSON.stringify(AI_MODEL));
}

function resetBrain() {
    AI_MODEL = JSON.parse(JSON.stringify(DEFAULT_MODEL));
    // Reset momentum
    MODEL_MOMENTUM.cnnKernel.fill(0);
    for(let k in MODEL_MOMENTUM.denseWeights) MODEL_MOMENTUM.denseWeights[k] = 0;
    for(let k in MODEL_MOMENTUM.contextWeights) MODEL_MOMENTUM.contextWeights[k] = 0;

    replayMemory = []; // Clear memory on reset
    saveBrain();
    updateNeuralUI();
}

// --- AI TRAINING FUNCTIONS (BATCH) ---

function voteTransition(isPositive) {
    if (!lastInputVector) return;

    const label = isPositive ? -1 : 1;
    replayMemory.push({ input: lastInputVector, label: label });

    if (replayMemory.length > CONFIG.memorySize) replayMemory.shift();

    trainFromBuffer();

    updateStatus(isPositive ? "Appreso (üëç)." : "Appreso (üëé).");
    document.getElementById('voting-panel').classList.remove('visible');
    lastInputVector = null;

    saveBrain();
}

function trainFromBuffer() {
    if (replayMemory.length === 0) return;

    const batch = [];
    const size = Math.min(replayMemory.length, CONFIG.batchSize);

    const indices = [];
    while(indices.length < size) {
        const r = Math.floor(Math.random() * replayMemory.length);
        if(!indices.includes(r)) indices.push(r);
    }

    indices.forEach(i => batch.push(replayMemory[i]));

    let gradCNN = new Array(13).fill(0);
    let gradCtx = { wCurrent:0, wNextNat:0, wPrev1:0, wPrev2:0 };
    let gradDense = { posFlow:0, harmony:0, bpm:0, rmsDelta:0, flatnessDelta:0 };

    batch.forEach(exp => {
        const dir = exp.label;
        const vec = exp.input;

        for(let i=0; i<13; i++) gradCNN[i] += dir * vec.mfccDiff[i];

        if(vec.distCurrent !== undefined) gradCtx.wCurrent += dir * vec.distCurrent;
        if(vec.distNextNat !== undefined) gradCtx.wNextNat += dir * vec.distNextNat;
        if(vec.distPrev1 !== undefined) gradCtx.wPrev1 += dir * vec.distPrev1;
        if(vec.distPrev2 !== undefined) gradCtx.wPrev2 += dir * vec.distPrev2;

        gradDense.posFlow += dir * vec.posFlow;
        gradDense.harmony += dir * (vec.harmony / 6.0);
        gradDense.bpm += dir * vec.bpm;
        gradDense.rmsDelta += dir * vec.rmsDelta;
        gradDense.flatnessDelta += dir * vec.flatnessDelta;
    });

    for(let i=0; i<13; i++) gradCNN[i] /= size;
    for(let k in gradCtx) gradCtx[k] /= size;
    for(let k in gradDense) gradDense[k] /= size;

    applyGradients(gradCNN, gradCtx, gradDense);
}

function applyGradients(gradCNN, gradCtx, gradDense) {
    const lr = CONFIG.learningRate;
    const alpha = CONFIG.momentum;

    for(let i=0; i<13; i++) {
        MODEL_MOMENTUM.cnnKernel[i] = alpha * MODEL_MOMENTUM.cnnKernel[i] + (1-alpha) * gradCNN[i];
        AI_MODEL.cnnKernel[i] += lr * MODEL_MOMENTUM.cnnKernel[i];
        AI_MODEL.cnnKernel[i] = Math.max(0, Math.min(10, AI_MODEL.cnnKernel[i]));
    }

    for(let k in AI_MODEL.contextWeights) {
        MODEL_MOMENTUM.contextWeights[k] = alpha * MODEL_MOMENTUM.contextWeights[k] + (1-alpha) * gradCtx[k];
        AI_MODEL.contextWeights[k] += lr * MODEL_MOMENTUM.contextWeights[k];
        AI_MODEL.contextWeights[k] = Math.max(0, Math.min(10, AI_MODEL.contextWeights[k]));
    }

    for(let k in AI_MODEL.denseWeights) {
        MODEL_MOMENTUM.denseWeights[k] = alpha * MODEL_MOMENTUM.denseWeights[k] + (1-alpha) * gradDense[k];
        AI_MODEL.denseWeights[k] += lr * MODEL_MOMENTUM.denseWeights[k];
        AI_MODEL.denseWeights[k] = Math.max(0, Math.min(10, AI_MODEL.denseWeights[k]));
    }

    updateNeuralUI();
}

function updateNeuralUI() {
    const container = document.getElementById('cnn-viz');
    if(container) {
        container.innerHTML = '';
        AI_MODEL.cnnKernel.forEach(w => {
            const cell = document.createElement('div');
            cell.className = 'kernel-cell';
            const intensity = Math.min(1, w / 5);
            const r = Math.floor(intensity * 255);
            const b = Math.floor((1-intensity) * 255);
            cell.style.backgroundColor = `rgb(${r}, 0, ${b})`;
            cell.innerText = w.toFixed(1);
            container.appendChild(cell);
        });
    }

    const setVal = (id, val) => {
        const el = document.getElementById(id);
        if(el) el.innerText = val.toFixed(2);
    };

    setVal('val-current', AI_MODEL.contextWeights.wCurrent);
    setVal('val-nextnat', AI_MODEL.contextWeights.wNextNat);
    setVal('val-prev1', AI_MODEL.contextWeights.wPrev1);
    setVal('val-prev2', AI_MODEL.contextWeights.wPrev2);

    setVal('val-flow', AI_MODEL.denseWeights.posFlow);
    setVal('val-harmony', AI_MODEL.denseWeights.harmony);
    setVal('val-bpm', AI_MODEL.denseWeights.bpm);
}

function toggleDevPanel() {
    const panel = document.getElementById('dev-panel');
    panel.classList.toggle('visible');
    const btn = document.getElementById('btn-dev');
    if (panel.classList.contains('visible')) {
        btn.classList.add('active');
        updateNeuralUI();
    } else {
        btn.classList.remove('active');
    }
}

function toggleAugmentation() {
    CONFIG.enablePitchAug = !CONFIG.enablePitchAug;
    const btn = document.getElementById('btn-aug');
    if (CONFIG.enablePitchAug) {
        btn.textContent = "Augmentation: ON";
        btn.className = "toggle-on";
    } else {
        btn.textContent = "Augmentation: OFF";
        btn.className = "toggle-off";
    }
    if (loadedTracks.length > 0) resegmentAll();
}

// --- AUDIO ENGINE ---

function initAudioContext() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
}

async function handleFiles(files) {
    initAudioContext();
    document.getElementById('overlay').style.display = 'none';

    const colors = ['#00ffcc', '#ff0055', '#ffff00', '#0099ff', '#ff9900', '#cc00ff'];

    if (typeof Meyda === 'undefined') {
        alert("Errore: Libreria Meyda non caricata.");
        return;
    }

    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        updateStatus(`Decodifica: ${file.name}...`);

        try {
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

            const detectedBpm = detectBPM(audioBuffer);
            const trackColor = colors[loadedTracks.length % colors.length];

            loadedTracks.push({
                buffer: audioBuffer,
                name: file.name,
                color: trackColor,
                bpm: detectedBpm || CONFIG.defaultBpm,
                totalDuration: audioBuffer.duration
            });

            updateLegend();
        } catch (e) {
            console.error("Errore:", e);
            updateStatus(`Errore lettura ${file.name}`);
        }
    }

    if (loadedTracks.length > 0) {
        resegmentAll();
        document.getElementById('btn-play').disabled = false;
    }
}

// --- ANALYSIS UTILS ---

function detectBPM(buffer) {
    try {
        const data = buffer.getChannelData(0);
        const sampleRate = buffer.sampleRate;
        const maxSamples = Math.min(data.length, sampleRate * 30);
        let peaks = [];
        for (let i = 0; i < maxSamples; i += 4000) {
            let max = 0;
            for(let j=0; j<4000; j++) if(Math.abs(data[i+j]) > max) max = Math.abs(data[i+j]);
            if(max > 0.3) peaks.push(i);
        }
        if(peaks.length < 5) return 120;

        let intervals = {};
        for(let i=1; i<peaks.length; i++) {
            let inv = peaks[i] - peaks[i-1];
            if(inv > sampleRate*0.3 && inv < sampleRate*1.5) {
                let q = Math.round(inv/1000)*1000;
                intervals[q] = (intervals[q]||0)+1;
            }
        }
        let bestInv = sampleRate;
        let maxCount = 0;
        for(let k in intervals) if(intervals[k]>maxCount) { maxCount=intervals[k]; bestInv=parseInt(k); }

        let bpm = 60 / (bestInv/sampleRate);
        while(bpm<75) bpm*=2;
        while(bpm>160) bpm/=2;
        return Math.round(bpm);
    } catch(e) { return 120; }
}

function getSegmentDuration(bpm) {
    return (60 / bpm) * CONFIG.beatsPerSegment;
}

function resegmentAll() {
    sampleLibrary = [];
    currentSampleIndex = -1;
    stopDJ();
    playQueue = [];
    const augStatus = CONFIG.enablePitchAug ? "ON" : "OFF";
    updateStatus(`Neural Analysis (${CONFIG.beatsPerSegment} beats)...`);

    setTimeout(() => {
        loadedTracks.forEach((track, idx) => {
            processAudioBuffer(track.buffer, idx, track.bpm, track.totalDuration);
        });

        if (sampleLibrary.length > 0) {
            calculateSpace();
            updateStatus(`Pronto! ${sampleLibrary.length} campioni.`);
            drawCanvas();
        }
    }, 100);
}

function processAudioBuffer(buffer, trackIndex, bpm, totalDuration) {
    const rawData = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;
    const duration = getSegmentDuration(bpm);
    const samplesPerSegment = Math.floor(duration * sampleRate);
    const meydaBufferSize = CONFIG.bufferSize;

    const variants = [];
    if (CONFIG.enablePitchAug) {
        CONFIG.semitoneShifts.forEach(st => variants.push({ type: 'pitch', val: st }));
    } else {
        variants.push({ type: 'pitch', val: 0 });
    }

    // Temporary storage to identify start/end of track
    const trackSegments = [];

    for (let i = 0; i < rawData.length; i += samplesPerSegment) {
        if (sampleLibrary.length >= CONFIG.maxSamples) break;
        if (i + samplesPerSegment > rawData.length) break;

        const segmentRaw = rawData.slice(i, i + samplesPerSegment);
        const baseFeats = extractFeaturesWithMeyda(segmentRaw, meydaBufferSize);
        if (baseFeats.rms < CONFIG.silenceThreshold) continue;

        const relPos = (i / sampleRate) / totalDuration;

        // Group variants for this specific time segment
        const timeSegmentVariants = [];

        variants.forEach(variant => {
            const semitone = variant.val;
            const rate = Math.pow(2, semitone / 12);
            const newBpm = bpm * rate;
            let newKey = (baseFeats.keyIndex + semitone);
            newKey = ((newKey % 12) + 12) % 12;

            const sampleObj = {
                buffer: buffer,
                startFn: i / sampleRate,
                duration: duration,
                bpm: newBpm,
                baseRate: rate,
                semitone: semitone,
                features: baseFeats,
                trackIndex: trackIndex,
                relPos: relPos,
                key: newKey,
                type: 'body' // Default
            };
            timeSegmentVariants.push(sampleObj);
        });

        trackSegments.push(timeSegmentVariants);
    }

    // Mark First and Last
    if (trackSegments.length > 0) {
        // First batch
        trackSegments[0].forEach(s => s.type = 'start');
        // Last batch
        trackSegments[trackSegments.length - 1].forEach(s => s.type = 'end');
    }

    // Push all to main library and assign IDs
    trackSegments.forEach(batch => {
        batch.forEach(s => {
            s.id = sampleLibrary.length;
            sampleLibrary.push(s);
        });
    });
}

function extractFeaturesWithMeyda(signal, bufferSize) {
    let totalRms=0, frames=0;
    let totalMfcc = new Array(13).fill(0);
    let totalChroma = new Array(12).fill(0);
    let totalCentroid=0, totalFlatness=0;

    const hops = 6;
    const step = Math.floor((signal.length - bufferSize) / hops);
    if(step<1) return { rms:0, mfcc:new Array(13).fill(0), keyIndex:0, centroid:0, flatness:0 };

    for(let j=0; j<hops; j++) {
        const start = j*step;
        const chunk = signal.slice(start, start+bufferSize);
        if(chunk.length<bufferSize) break;
        try {
            const f = Meyda.extract(['rms', 'mfcc', 'chroma', 'spectralCentroid', 'spectralFlatness'], chunk);
            if(f) {
                totalRms += f.rms;
                totalCentroid += f.spectralCentroid;
                totalFlatness += f.spectralFlatness;
                for(let k=0; k<13; k++) totalMfcc[k] += f.mfcc[k];
                for(let k=0; k<12; k++) totalChroma[k] += f.chroma[k];
                frames++;
            }
        } catch(e){}
    }
    if(frames===0) frames=1;

    const avgChroma = totalChroma.map(v=>v/frames);
    let maxK=-1, maxV=-1;
    for(let k=0; k<12; k++) if(avgChroma[k]>maxV){ maxV=avgChroma[k]; maxK=k; }

    return {
        rms: totalRms/frames,
        mfcc: totalMfcc.map(v=>v/frames),
        centroid: totalCentroid/frames,
        flatness: totalFlatness/frames,
        keyIndex: maxK
    };
}

// --- DIMENSIONALITY REDUCTION ---
function calculateSpace() {
    if (sampleLibrary.length === 0) return;
    const xVals = sampleLibrary.map(s => s.features.mfcc[1]);
    const yVals = sampleLibrary.map(s => s.features.mfcc[2]);
    const minX = Math.min(...xVals), maxX = Math.max(...xVals);
    const minY = Math.min(...yVals), maxY = Math.max(...yVals);
    const norm = (v, min, max) => (v - min) / (max - min || 1);

    sampleLibrary.forEach(s => {
        s.x = norm(s.features.mfcc[1], minX, maxX);
        s.y = norm(s.features.mfcc[2], minY, maxY);
        if(s.semitone !== 0) { s.x += s.semitone*0.015; s.y += s.semitone*0.015; }
        s.x += (Math.random()-0.5)*0.005; s.y += (Math.random()-0.5)*0.005;
    });
}

// --- PLAYBACK ENGINE ---

function startDJ() {
    if (isPlaying) return;
    if (sampleLibrary.length === 0) return;
    initAudioContext();
    isPlaying = true;
    document.getElementById('btn-play').classList.add('active');
    document.getElementById('btn-play').textContent = "IN ONDA...";
    document.getElementById('btn-stop').disabled = false;
    document.getElementById('beatSelect').disabled = true;
    document.getElementById('btn-aug').disabled = true;

    nextStartTime = audioCtx.currentTime + 0.1;
    if (currentSampleIndex === -1) {
        currentSampleIndex = userNextSelection !== -1 ? userNextSelection : Math.floor(Math.random() * sampleLibrary.length);
    }
    prevSampleIndex = -1; userNextSelection = -1; trailHistory = [];
    contextHistory = []; // Reset History

    currentBpm = sampleLibrary[currentSampleIndex].bpm;
    lastEffectiveKeyIndex = sampleLibrary[currentSampleIndex].key;
    scheduleNextSegment();
    loop();
}

function stopDJ() {
    isPlaying = false;
    clearTimeout(playLoopId);
    document.getElementById('btn-play').classList.remove('active');
    document.getElementById('btn-play').textContent = "‚ñ∂ PLAY / AUTO";
    document.getElementById('btn-stop').disabled = true;
    document.getElementById('beatSelect').disabled = false;
    document.getElementById('btn-aug').disabled = false;
    document.getElementById('voting-panel').classList.remove('visible');
    updateStatus("DJ Fermo.");
}

function scheduleNextSegment() {
    if (!isPlaying) return;

    // Update History before choosing new
    if (currentSampleIndex !== -1) {
        contextHistory.push(currentSampleIndex);
        if (contextHistory.length > 3) contextHistory.shift();
    }

    if (playQueue.length > 0) {
        currentSampleIndex = playQueue.shift();
        userNextSelection = -1;
    } else if (userNextSelection !== -1) {
        currentSampleIndex = userNextSelection;
        userNextSelection = -1;
    } else {
        currentSampleIndex = neuralPathfinder(currentSampleIndex);
    }

    const currentSample = sampleLibrary[currentSampleIndex];

    if (prevSampleIndex !== -1) {
        addTrail(prevSampleIndex, currentSampleIndex);
        document.getElementById('voting-panel').classList.add('visible');
        lastInputVector = extractTransitionVector(prevSampleIndex, currentSampleIndex);
    }

    let playbackRate = 1.0;
    let finalRate = currentSample.baseRate;
    let effectiveKey = currentSample.key;

    if (prevSampleIndex !== -1) {
        const nativeBpm = currentSample.bpm;
        const syncFactor = currentBpm / nativeBpm;
        let safeSync = Math.max(0.8, Math.min(1.2, syncFactor));

        finalRate = currentSample.baseRate * safeSync;

        const syncShift = 12 * Math.log2(safeSync);
        effectiveKey = (currentSample.key + Math.round(syncShift)) % 12;
        if(effectiveKey < 0) effectiveKey += 12;

        currentBpm = currentBpm * 0.9 + nativeBpm * 0.1;
    } else {
        currentBpm = currentSample.bpm;
        finalRate = currentSample.baseRate;
        effectiveKey = currentSample.key;
    }

    lastEffectiveKeyIndex = effectiveKey;

    playSegment(currentSample, nextStartTime, finalRate);

    const track = loadedTracks[currentSample.trackIndex];
    const keyName = NOTES[effectiveKey];
    const bpmDisplay = Math.round(currentBpm);

    const remainingSteps = playQueue.length > 0 ? `[Path: ${playQueue.length}]` : "[Neural Auto]";
    document.getElementById('harmonic-info').innerHTML =
        `Key: <strong>${keyName}</strong><br>BPM: ${bpmDisplay} <small>(${finalRate.toFixed(2)}x)</small><br>` +
        `<span style="font-size:0.8em; color:var(--accent-color);">${remainingSteps}</span>`;

    updateStatus(`Playing: ${track.name} (Pos: ${(currentSample.relPos*100).toFixed(0)}%)`);

    const effectiveDuration = currentSample.duration / finalRate;
    const overlap = CONFIG.crossfade;
    nextStartTime += (effectiveDuration - overlap);

    const timeUntilDecision = (effectiveDuration - overlap) * 1000;
    prevSampleIndex = currentSampleIndex;

    playLoopId = setTimeout(() => {
        scheduleNextSegment();
    }, timeUntilDecision);
}

function playSegment(sample, time, rate) {
    const source = audioCtx.createBufferSource();
    source.buffer = sample.buffer;
    source.playbackRate.value = rate;
    const gainNode = audioCtx.createGain();
    const sweepFilter = audioCtx.createBiquadFilter();
    sweepFilter.type = "lowpass";
    source.connect(sweepFilter);
    sweepFilter.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    source.start(time, sample.startFn, sample.duration);

    sweepFilter.frequency.setValueAtTime(400, time);
    sweepFilter.frequency.exponentialRampToValueAtTime(20000, time + (CONFIG.crossfade * 1.5));
    gainNode.gain.setValueAtTime(0, time);
    gainNode.gain.linearRampToValueAtTime(1, time + CONFIG.crossfade);
    const effectiveDuration = sample.duration / rate;
    const endTime = time + effectiveDuration;
    gainNode.gain.setValueAtTime(1, endTime - CONFIG.crossfade);
    gainNode.gain.linearRampToValueAtTime(0, endTime);
}

// --- NEURAL PATHFINDING (TEMPORAL) ---

function getFeaturesDist(s1, s2) {
    let sum = 0;
    for(let i=0; i<13; i++) sum += (s1.features.mfcc[i] - s2.features.mfcc[i])**2;
    return Math.sqrt(sum);
}

// Generate Feature Vector for the Transition (Input to NN)
function extractTransitionVector(uIndex, vIndex) {
    const u = sampleLibrary[uIndex];
    const v = sampleLibrary[vIndex];

    // 1. MFCC Diff Vector
    const mfccDiff = u.features.mfcc.map((val, k) => Math.abs(val - v.features.mfcc[k]));

    // 2. Spectral & Struct
    const rmsDelta = Math.abs(u.features.rms - v.features.rms);
    const flatnessDelta = Math.abs(u.features.flatness - v.features.flatness);

    const posFlow = (v.relPos < u.relPos) ? 1.0 : 0.0;

    const diffCircle = Math.abs((v.key - u.key) * 7) % 12;
    const harmony = Math.min(diffCircle, 12 - diffCircle);
    const bpmDiff = Math.abs(u.bpm - v.bpm);
    const bpmCost = bpmDiff / 10;

    // 3. TEMPORAL CONTEXT
    const distCurrent = getFeaturesDist(u, v);

    let distNextNat = 0;
    const numVariants = CONFIG.enablePitchAug ? CONFIG.semitoneShifts.length : 1;
    const nextNatIdx = uIndex + numVariants;
    if (nextNatIdx < sampleLibrary.length &&
        sampleLibrary[nextNatIdx].trackIndex === u.trackIndex &&
        sampleLibrary[nextNatIdx].semitone === u.semitone) {
        distNextNat = getFeaturesDist(sampleLibrary[nextNatIdx], v);
    } else {
        distNextNat = distCurrent;
    }

    let distPrev1 = 0;
    if(contextHistory.length >= 2) {
        const idxPrev1 = contextHistory[contextHistory.length - 2];
        distPrev1 = getFeaturesDist(sampleLibrary[idxPrev1], v);
    } else distPrev1 = distCurrent;

    let distPrev2 = 0;
    if(contextHistory.length >= 3) {
        const idxPrev2 = contextHistory[contextHistory.length - 3];
        distPrev2 = getFeaturesDist(sampleLibrary[idxPrev2], v);
    } else distPrev2 = distCurrent;

    return {
        mfccDiff, rmsDelta, flatnessDelta, posFlow, harmony, bpm: bpmCost,
        distCurrent, distNextNat, distPrev1, distPrev2
    };
}

// Forward Pass
function calculateNeuralCost(uIndex, vIndex) {
    const vec = extractTransitionVector(uIndex, vIndex);

    // CNN Kernel (Timbre)
    let cnnOutput = 0;
    for(let i=0; i<13; i++) cnnOutput += vec.mfccDiff[i] * AI_MODEL.cnnKernel[i];

    // Context Layer
    const cw = AI_MODEL.contextWeights;
    const ctxOutput =
        (vec.distCurrent * cw.wCurrent) +
        (vec.distNextNat * cw.wNextNat) +
        (vec.distPrev1 * cw.wPrev1) +
        (vec.distPrev2 * cw.wPrev2);

    // Dense Layer (Struct)
    const w = AI_MODEL.denseWeights;
    const denseOutput =
        (vec.rmsDelta * w.rmsDelta) +
        (vec.flatnessDelta * w.flatnessDelta) +
        (vec.posFlow * w.posFlow) +
        (vec.harmony * w.harmony) +
        (vec.bpm * w.bpm);

    return cnnOutput + ctxOutput + denseOutput;
}

function neuralPathfinder(currentIndex) {
    const N = sampleLibrary.length;
    let candidates = [];
    for(let i=0; i<40; i++) {
        const rnd = Math.floor(Math.random() * N);
        if(rnd !== currentIndex) candidates.push({ idx: rnd, cost: calculateNeuralCost(currentIndex, rnd) });
    }
    const nextIdx = currentIndex + 1;
    if(nextIdx < N) candidates.push({ idx: nextIdx, cost: calculateNeuralCost(currentIndex, nextIdx) });

    candidates.sort((a,b) => a.cost - b.cost);
    return candidates[0].idx;
}

// Dijkstra
function findPath(startIdx, endIdx) {
    const N = sampleLibrary.length;
    const distances = new Array(N).fill(Infinity);
    const previous = new Array(N).fill(null);
    const visited = new Array(N).fill(false);
    distances[startIdx] = 0;
    const queue = [startIdx];
    let iter = 0;

    while(queue.length > 0 && iter++ < 1500) {
        let u = -1, min = Infinity, uIdx = -1;
        for(let i=0; i<queue.length; i++) {
            if(distances[queue[i]] < min) { min=distances[queue[i]]; u=queue[i]; uIdx=i; }
        }
        if(u===-1 || u===endIdx) break;
        queue.splice(uIdx, 1);
        visited[u] = true;

        for(let v=0; v<N; v++) {
            if(!visited[v]) {
                if(Math.abs(sampleLibrary[u].x - sampleLibrary[v].x) > 0.4) continue;
                const alt = distances[u] + calculateNeuralCost(u, v);
                if(alt < distances[v]) {
                    distances[v] = alt;
                    previous[v] = u;
                    if(!queue.includes(v)) queue.push(v);
                }
            }
        }
    }

    const path = [];
    let curr = endIdx;
    if(previous[curr] !== null || curr === startIdx) {
        while(curr !== null) { path.unshift(curr); curr = previous[curr]; }
    }
    if(path.length>0 && path[0]===startIdx) path.shift();
    return path;
}

// --- VISUALIZATION ---

function initCanvas() {
    initBrain(); // Load brain first
    canvas = document.getElementById('djCanvas');
    ctx = canvas.getContext('2d');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    canvas.addEventListener('mousedown', handleCanvasClick);
    animate();
    updateNeuralUI();
}

function resizeCanvas() {
    canvas.width = document.getElementById('main-container').offsetWidth;
    canvas.height = document.getElementById('main-container').offsetHeight;
}

function handleCanvasClick(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    let closestIdx = -1;
    let minVisualDist = 30;

    sampleLibrary.forEach((s, idx) => {
        const sx = s.x * canvas.width * 0.8 + canvas.width * 0.1;
        const sy = s.y * canvas.height * 0.8 + canvas.height * 0.1;
        const dist = Math.sqrt((x - sx)**2 + (y - sy)**2);
        if (dist < minVisualDist) {
            minVisualDist = dist;
            closestIdx = idx;
        }
    });

    if (closestIdx !== -1) {
        if (!isPlaying) {
            userNextSelection = closestIdx;
            startDJ();
        } else {
            updateStatus("Neural Pathfinding...");
            const startNode = playQueue.length > 0 ? playQueue[playQueue.length - 1] : currentSampleIndex;
            setTimeout(() => {
                const path = findPath(startNode, closestIdx);
                if (path.length > 0) {
                    playQueue.push(...path);
                    updateStatus(`Percorso neurale aggiunto (+${path.length} steps).`);
                } else updateStatus("Impossibile connettere.");
            }, 10);
        }
    }
}

function addTrail(idxA, idxB) {
    const sA = sampleLibrary[idxA];
    const sB = sampleLibrary[idxB];
    trailHistory.push({ x1: sA.x, y1: sA.y, x2: sB.x, y2: sB.y, life: 180, maxLife: 180 });
}

function animate() {
    requestAnimationFrame(animate);
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const w = canvas.width;
    const h = canvas.height;
    const margin = 0.1;
    const scale = 0.8;

    // Trails
    if (trailHistory.length > 0) {
        ctx.lineWidth = 2;
        for (let i = trailHistory.length - 1; i >= 0; i--) {
            const t = trailHistory[i];
            const sx1 = t.x1 * w * scale + w * margin;
            const sy1 = t.y1 * h * scale + h * margin;
            const sx2 = t.x2 * w * scale + w * margin;
            const sy2 = t.y2 * h * scale + h * margin;
            const opacity = t.life / t.maxLife;
            ctx.beginPath();
            ctx.moveTo(sx1, sy1);
            ctx.lineTo(sx2, sy2);
            ctx.strokeStyle = `rgba(0, 255, 204, ${opacity})`;
            ctx.stroke();
            t.life--;
            if (t.life <= 0) trailHistory.splice(i, 1);
        }
    }

    // Queue
    if (playQueue.length > 0 && currentSampleIndex !== -1) {
        let prevIdx = currentSampleIndex;
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = '#ffffff';
        for (let nextIdx of playQueue) {
            const s = sampleLibrary[prevIdx];
            const n = sampleLibrary[nextIdx];
            const sx = s.x * w * scale + w * margin;
            const sy = s.y * h * scale + h * margin;
            const nx = n.x * w * scale + w * margin;
            const ny = n.y * h * scale + h * margin;
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(nx, ny); ctx.stroke();
            prevIdx = nextIdx;
        }
        ctx.setLineDash([]);
    }

    // Dots
    sampleLibrary.forEach((s, idx) => {
        const x = s.x * w * scale + w * margin;
        const y = s.y * h * scale + h * margin;
        const color = loadedTracks[s.trackIndex].color;

        ctx.beginPath();
        // Disegno speciale basato sul tipo (start/end/body) e stato (current/queued/other)
        if (idx === currentSampleIndex) {
            const pulse = 10 + Math.sin(Date.now() / 100) * 5;
            // Forma pulsante per il sample corrente
            if (s.type === 'start') drawTriangle(ctx, x, y, pulse);
            else if (s.type === 'end') drawSquare(ctx, x, y, pulse);
            else ctx.arc(x, y, pulse, 0, Math.PI * 2);

            ctx.fillStyle = 'white'; ctx.fill();

            // Outer stroke
            ctx.beginPath();
            if (s.type === 'start') drawTriangle(ctx, x, y, pulse + 5);
            else if (s.type === 'end') drawSquare(ctx, x, y, pulse + 5);
            else ctx.arc(x, y, pulse + 5, 0, Math.PI * 2);

            ctx.strokeStyle = color; ctx.stroke();

            ctx.fillStyle = '#fff'; ctx.font = '12px Arial';
            const dispKey = (idx === currentSampleIndex && lastEffectiveKeyIndex !== -1) ? lastEffectiveKeyIndex : s.key;
            ctx.fillText(NOTES[dispKey], x + 15, y + 4);
        } else {
            let radius = s.semitone === 0 ? 3 : 1;
            if (playQueue.includes(idx)) radius = 4;

            ctx.globalAlpha = s.semitone === 0 ? 1.0 : 0.7;

            if (s.type === 'start') drawTriangle(ctx, x, y, radius + 2);
            else if (s.type === 'end') drawSquare(ctx, x, y, radius + 1);
            else ctx.arc(x, y, radius, 0, Math.PI * 2);

            if (playQueue.includes(idx)) {
                ctx.fillStyle = 'white'; ctx.fill();
                ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.stroke();
            } else {
                ctx.fillStyle = color; ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }
        ctx.closePath();
    });
}

function drawTriangle(ctx, x, y, size) {
    ctx.moveTo(x, y - size);
    ctx.lineTo(x + size, y + size);
    ctx.lineTo(x - size, y + size);
    ctx.lineTo(x, y - size);
}

function drawSquare(ctx, x, y, size) {
    ctx.rect(x - size, y - size, size * 2, size * 2);
}

function updateStatus(msg) {
    document.getElementById('status').innerText = msg;
    document.getElementById('status').style.opacity = 1;
}

function updateLegend() {
    const legend = document.getElementById('trackLegend');
    legend.innerHTML = '';
    loadedTracks.forEach(t => {
        const div = document.createElement('div');
        div.className = 'legend-item';
        div.innerHTML = `<div class="color-dot" style="background-color:${t.color}"></div><span>${t.name} <small>(${t.bpm} BPM)</small></span>`;
        legend.appendChild(div);
    });
}

document.getElementById('beatSelect').addEventListener('change', (e) => {
    CONFIG.beatsPerSegment = parseFloat(e.target.value);
    if (loadedTracks.length > 0) resegmentAll();
});
document.getElementById('btn-dev').addEventListener('click', toggleDevPanel);
document.getElementById('btn-aug').addEventListener('click', toggleAugmentation);

function loop() {}

window.onload = () => {
    initCanvas();
    document.getElementById('fileInput').addEventListener('change', (e) => handleFiles(e.target.files));
    document.getElementById('btn-play').addEventListener('click', startDJ);
    document.getElementById('btn-stop').addEventListener('click', stopDJ);
};

</script>
</body>
</html>