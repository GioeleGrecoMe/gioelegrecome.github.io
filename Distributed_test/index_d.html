<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Distributed MNIST PNG Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #050814;
      color: #f0f4ff;
      --card-bg: #151a2c;
      --accent: #4f9cff;
      --accent-soft: rgba(79, 156, 255, 0.15);
    }
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #20263a;
      display: flex;
      align-items: baseline;
      gap: 1rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.25rem;
    }
    header span {
      font-size: 0.85rem;
      color: #9ca4c7;
    }
    main {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      grid-template-rows: auto auto 1fr;
      gap: 1rem;
      padding: 1rem;
      box-sizing: border-box;
      flex: 1;
    }
    section {
      background: var(--card-bg);
      border-radius: 0.75rem;
      padding: 0.75rem 1rem;
      box-shadow: 0 0 0 1px #1f2840;
      min-width: 0;
    }
    section h2 {
      margin: 0 0 0.5rem;
      font-size: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .pill {
      font-size: 0.7rem;
      padding: 0.15rem 0.4rem;
      border-radius: 999px;
      background: var(--accent-soft);
      color: #4f9cff;
    }
    .ghost-btn {
      background: transparent;
      border: 1px solid #ff6b6b;
      color: #ff6b6b;
      border-radius: 999px;
      padding: 0.1rem 0.5rem;
      font-size: 0.7rem;
      cursor: pointer;
      margin-right: 0.4rem;
    }
    .ghost-btn:hover {
      background: rgba(255,107,107,0.15);
    }
    .ghost-btn:active {
      transform: translateY(1px);
    }
    #status-section {
      grid-column: 1 / 2;
      grid-row: 1 / 2;
    }
    #global-section {
      grid-column: 2 / 3;
      grid-row: 1 / 2;
    }
    #mesh-section {
      grid-column: 1 / 2;
      grid-row: 2 / 4;
    }
    #tester-section {
      grid-column: 2 / 3;
      grid-row: 2 / 4;
    }
    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }
    .stat {
      background: #1a2136;
      border-radius: 0.6rem;
      padding: 0.4rem 0.5rem;
      font-size: 0.8rem;
    }
    .stat .label {
      color: #9ca4c7;
      font-size: 0.7rem;
    }
    .stat .value {
      font-weight: 600;
      margin-top: 0.15rem;
    }
    .stat .sub {
      font-size: 0.7rem;
      color: #8891b3;
      margin-top: 0.1rem;
    }
    #meshCanvas {
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #1b2340, #050814);
      border-radius: 0.6rem;
      border: 1px solid #222a42;
      box-sizing: border-box;
      cursor: pointer;
    }
    #node-details {
      font-size: 0.8rem;
      background: #101628;
      border-radius: 0.5rem;
      padding: 0.5rem;
      margin-top: 0.5rem;
    }
    canvas.loss-chart {
      width: 100%;
      height: 140px;
    }
    footer {
      padding: 0.5rem 1rem;
      font-size: 0.7rem;
      color: #7b84a7;
      border-top: 1px solid #20263a;
    }
    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
    }
    #tester-section input[type="file"] {
      font-size: 0.8rem;
      margin-bottom: 0.4rem;
    }
    #tester-section button {
      background: var(--accent);
      border: none;
      border-radius: 0.5rem;
      padding: 0.35rem 0.7rem;
      color: #0b1020;
      font-size: 0.8rem;
      cursor: pointer;
    }
    #tester-section button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    #tester-result {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      white-space: pre-line;
    }
    .sample-thumb {
      width: 40px;
      height: 40px;
      border-radius: 0.3rem;
      border: 1px solid #303857;
      cursor: pointer;
      image-rendering: pixelated;
      background: #000;
      object-fit: cover;
    }
    .sample-thumb.selected {
      border-color: #4f9cff;
      box-shadow: 0 0 0 2px rgba(79,156,255,0.5);
    }
    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto auto auto;
      }
      #status-section, #global-section, #mesh-section, #tester-section, #dev-section {
        grid-column: 1 / 2;
        grid-row: auto;
      }
      #meshCanvas {
        height: 260px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Distributed MNIST PNG Demo</h1>
    <span>Training CNN federata su MNIST PNG, rete locale fissa + rete globale su Firebase</span>
  </header>

  <main>
    <!-- STATO LOCALE -->
    <section id="status-section">
      <h2>
        Nodo locale
        <span>
          <button id="panic-btn" class="ghost-btn">Reset locale</button>
          <span class="pill" id="client-id-pill">Client: …</span>
        </span>
      </h2>
      <div class="stat-grid">
        <div class="stat">
          <div class="label">Backend TF.js</div>
          <div class="value" id="tf-backend">–</div>
          <div class="sub" id="tf-version">–</div>
        </div>
        <div class="stat">
          <div class="label">Dati macinati</div>
          <div class="value" id="samples-trained">0</div>
          <div class="sub" id="batches-trained">0 batch totali</div>
        </div>
        <div class="stat">
          <div class="label">Carico training</div>
          <div class="value" id="batch-ms">–</div>
          <div class="sub" id="throughput">–</div>
        </div>
        <div class="stat">
          <div class="label">Batteria (se disponibile)</div>
          <div class="value" id="battery-level">–</div>
          <div class="sub" id="battery-status">API non disponibile</div>
        </div>
        <div class="stat">
          <div class="label">Loss locale</div>
          <div class="value" id="local-loss">–</div>
          <div class="sub" id="val-loss">validation: –</div>
        </div>
        <div class="stat">
          <div class="label">Layer nascosto locale</div>
          <div class="value" id="hidden-size">–</div>
          <div class="sub" id="hidden-policy">neuroni fissi / max</div>
        </div>
      </div>
      <canvas id="localLossChart" class="loss-chart"></canvas>
    </section>

    <!-- STATO GLOBALE -->
    <section id="global-section">
      <h2>
        Vista globale
        <span class="pill" id="clients-count">Nodi: 0</span>
      </h2>
      <div class="stat-grid">
        <div class="stat">
          <div class="label">Loss globale (modello fuso)</div>
          <div class="value" id="global-loss">–</div>
          <div class="sub">val loss del modello aggregato su questo nodo</div>
        </div>
        <div class="stat">
          <div class="label">Snapshot recenti</div>
          <div class="value" id="snapshots-count">0</div>
          <div class="sub" id="last-snapshot-age">–</div>
        </div>
        <div class="stat">
          <div class="label">Qualità Sinkhorn</div>
          <div class="value" id="sinkhorn-quality">–</div>
          <div class="sub">allineamento neuroni nella rete globale</div>
        </div>
      </div>
      <canvas id="globalLossChart" class="loss-chart"></canvas>
    </section>

    <!-- MESH -->
    <section id="mesh-section">
      <h2>
        Rete mesh dei dispositivi
        <span class="pill">clicca sui nodi per dettagli</span>
      </h2>
      <canvas id="meshCanvas"></canvas>
      <div id="node-details">
        <strong>Dettagli nodo selezionato</strong>
        <div id="node-details-body">Nessun nodo selezionato.</div>
      </div>
    </section>

    <!-- TESTER -->
    <section id="tester-section">
      <h2>
        Tester modello
        <span class="pill" id="model-ready-pill">Modello: inizializzazione…</span>
      </h2>
      <p style="font-size:0.8rem; color:#9ca4c7;">
        Carica una piccola immagine (sarà ridimensionata a 32×32, in scala di grigi) oppure clicca su alcune cifre
        di esempio dal test set MNIST. Il training continua in background mentre osservi i risultati.
      </p>
      <input type="file" id="test-image-input" accept="image/*" />
      <button id="test-btn" disabled>Testa immagine</button>
      <div id="tester-result">In attesa che il modello si stabilizzi…</div>

      <div style="margin-top:0.8rem;">
        <div style="font-size:0.75rem;color:#9ca4c7;margin-bottom:0.2rem;">
          Oppure prova con alcune cifre di esempio (dal test set MNIST):
        </div>
        <div id="sample-images-container"
             style="display:flex;flex-wrap:wrap;gap:0.3rem;"></div>
      </div>

      <hr style="border-color:#20263a; margin:0.8rem 0;" />
      <p style="font-size:0.75rem; color:#7b84a7;">
        Questo prototipo:
      </p>
      <ul style="font-size:0.75rem; margin-top:0.2rem; padding-left:1.2rem; color:#9ca4c7;">
        <li>Scarica MNIST-PNG (CSV + PNG) dal repo MIT di <code>rasbt/mnist-pngs</code></li>
        <li>Allena una CNN locale con TF.js, salvata manualmente in <code>localStorage</code></li>
        <li>Condivide snapshot quantizzati su Firestore (nessun server custom)</li>
        <li>Costruisce una rete globale “astratta” (solo pesi) e un <strong>globalModel</strong> per le predizioni</li>
        <li>Mostra le predizioni <strong>locali vs globali</strong> quando clicchi un sample</li>
      </ul>
    </section>

    <!-- DEVELOPER SECTION (nascosta, si sblocca con Shift+D 3 volte) -->
    <section id="dev-section" style="display:none; margin-top:0.5rem;">
      <h2>
        Developer tools
        <span class="pill">Dev</span>
      </h2>
      <button id="firebase-reset-btn" class="ghost-btn">Reset stanza Firebase</button>
      <p style="font-size:0.75rem;color:#9ca4c7;margin-top:0.4rem;">
        Questo reset è <strong>logico</strong>: imposta un nuovo <code>resetToken</code> su Firestore
        per la stanza <code>rooms/&lt;ROOM_ID&gt;</code>. Tutti i nodi che vedono un token diverso
        da quello locale resettano il modello e ripartono da zero, ma gli snapshot vecchi non vengono cancellati.
      </p>
      <div id="dev-log" style="margin-top:0.5rem;max-height:200px;overflow:auto;
           font-size:0.7rem;background:#101628;border-radius:0.5rem;
           padding:0.4rem;border:1px solid #232b45;">
        <div id="dev-log-body">Developer log vuoto…</div>
      </div>
    </section>
  </main>

  <footer>
    Prototipo puramente client-side. Configura <code>firebaseConfig</code>, MNIST PNG e regole Firestore nel tuo progetto Firebase.
  </footer>

  <!-- Canvas nascosto per caricare / ridimensionare immagini -->
  <canvas id="imageLoaderCanvas" style="display:none;"></canvas>

  <!-- LIBRERIE -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script type="module">
    /******************************************************************
     * IMPORT FIREBASE (MODULAR API)
     ******************************************************************/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
    import {
      getFirestore,
      doc,
      setDoc,
      collection,
      addDoc,
      onSnapshot,
      query,
      orderBy,
      limit,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";
    import {
      getAuth,
      signInAnonymously,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

    /******************************************************************
     * CONFIGURAZIONE FIREBASE
     ******************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyDUYL3b05b0RoyNMYCy9GZRtDs-4SBb-AI",
      authDomain: "twin-dungeon.firebaseapp.com",
      projectId: "twin-dungeon",
      storageBucket: "twin-dungeon.firebasestorage.app",
      messagingSenderId: "141719069384",
      appId: "1:141719069384:web:8cf21db6eddcadea0d3bfd",
      measurementId: "G-8L8Y6CL8M2"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    /******************************************************************
     * PARAMETRI MODELLO / TRAINING
     ******************************************************************/
    const ROOM_ID = "image-room";
    const IMG_SIZE = 32;
    const NUM_CHANNELS = 1;
    const NUM_CLASSES = 10; // cifre 0–9

    // Layer nascosto (locale fisso, globale adattivo come meta)
    const HIDDEN_MAX = 32;
    const HIDDEN_INIT = 16;
    const HIDDEN_MIN = 8;

    // Training
    const TRAIN_BATCH_SIZE = 4;
    const VAL_BATCH_SIZE = 4;
    const TRAINING_PAUSE_MS = 1500;
    const VALIDATION_EVERY_STEPS = 4;
    const SNAPSHOT_EVERY_STEPS = 8;
    const FUSION_INTERVAL_MS = 7000;
    const FUSION_NEIGHBORS_LIMIT = 3;

    // Indici pesi
    const IDX_CONV1_KERNEL = 0;
    const IDX_CONV1_BIAS   = 1;
    const IDX_CONV2_KERNEL = 2;
    const IDX_CONV2_BIAS   = 3;
    const IDX_DH_KERNEL    = 4;
    const IDX_DH_BIAS      = 5;
    const IDX_DO_KERNEL    = 6;
    const IDX_DO_BIAS      = 7;

    // Storage locale
    const META_STORAGE_KEY  = "distributed-image-model-meta-weights-v1";

    // MNIST PNG (rasbt/mnist-pngs, MIT)
    const MNIST_ROOT = "https://raw.githubusercontent.com/rasbt/mnist-pngs/main/";
    const MNIST_TRAIN_CSV_URL = MNIST_ROOT + "train.csv";
    const MNIST_TEST_CSV_URL  = MNIST_ROOT + "test.csv";
    const MAX_TRAIN_ITEMS = 12000;
    const MAX_VAL_ITEMS   = 2000;

    // Nodo offline se lastSeen è troppo vecchio
    const OFFLINE_THRESHOLD_MS = 60_000; // 1 minuto

    // Developer log
    const DEV_LOG_MAX = 200;
    const devLogBuffer = [];

    /******************************************************************
     * STATO GLOBALE
     ******************************************************************/
    let currentUser = null;
    let clientId = null;

    // Modelli TF.js
    let model = null;         // modello locale (training)
    let globalModel = null;   // modello globale aggregato (solo inference/val)

    let activeHiddenSize = HIDDEN_MAX; // meta per il nodo

    // Rete globale astratta (solo arrays)
    let globalModelState = null; // { shapes, arrays, activeHiddenSize }

    let trainManifest = null;
    let valManifest = null;

    let stepsTrained = 0;
    let samplesTrained = 0;
    let batchesTrained = 0;
    let avgBatchMs = 0;
    let lastTrainLoss = null;
    let lastValLoss = null;
    let lastGlobalValLoss = null;

    let lastSinkhornQuality = null;
    let batteryInfo = null;

    const clientsState = new Map();
    let trustScores = new Map(); // clientId -> { score, ts }

    let lastSnapshots = [];
    let currentResetToken = null;

    let localLossChart = null;
    let globalLossChart = null;

    const meshCanvas = document.getElementById("meshCanvas");
    const meshCtx = meshCanvas.getContext("2d");
    let meshNodesLayout = new Map();

    /******************************************************************
     * DEV LOG
     ******************************************************************/
    function devLog(message) {
      const ts = new Date().toLocaleTimeString();
      const line = `[${ts}] ${message}`;
      devLogBuffer.unshift(line);
      if (devLogBuffer.length > DEV_LOG_MAX) devLogBuffer.pop();
      const el = document.getElementById("dev-log-body");
      if (el) {
        el.innerHTML = devLogBuffer.join("<br>");
      }
      console.log("[DEV]", message);
    }

    /******************************************************************
     * UTILITY
     ******************************************************************/
    function sleep(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    function formatMs(ms) {
      if (ms == null) return "–";
      return ms.toFixed(1) + " ms/batch";
    }

    function clamp(v, min, max) {
      return Math.min(Math.max(v, min), max);
    }

    /******************************************************************
     * MNIST PNG: CSV → MANIFEST BILANCIATO PER CLASSE
     ******************************************************************/
    async function fetchCsvLines(url, maxLines = null) {
      devLog("Scarico CSV MNIST: " + url);
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error("Impossibile caricare CSV: " + url + " (" + resp.status + ")");
      }
      const text = await resp.text();
      const allLines = text.trim().split(/\r?\n/);
      const header = allLines.shift();
      if (!header.toLowerCase().startsWith("filepath")) {
        console.warn("Header CSV inatteso per", url, ":", header);
      }
      if (maxLines && allLines.length > maxLines) {
        return allLines.slice(0, maxLines);
      }
      return allLines;
    }

    function parseMnistCsvLinesToItems(lines) {
      const items = [];
      for (const line of lines) {
        if (!line) continue;
        const parts = line.split(",");
        if (parts.length < 2) continue;
        const filepath = parts[0].trim();
        const labelStr = parts[1].trim();
        const label = parseInt(labelStr, 10);
        if (Number.isNaN(label)) continue;
        const url = MNIST_ROOT + filepath;
        items.push({ url, label });
      }
      return items;
    }

    function balancedSampleByLabel(items, maxTotal) {
      const shuffled = items.slice();
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        const tmp = shuffled[i];
        shuffled[i] = shuffled[j];
        shuffled[j] = tmp;
      }
      const perClass = Math.max(1, Math.floor(maxTotal / NUM_CLASSES));
      const counts = new Array(NUM_CLASSES).fill(0);
      const result = [];
      for (const item of shuffled) {
        if (result.length >= maxTotal) break;
        const label = item.label;
        if (label < 0 || label >= NUM_CLASSES) continue;
        if (counts[label] >= perClass) continue;
        counts[label]++;
        result.push(item);
      }
      return result;
    }

    async function loadMnistPngManifests() {
      const [trainLines, testLines] = await Promise.all([
        fetchCsvLines(MNIST_TRAIN_CSV_URL, null),
        fetchCsvLines(MNIST_TEST_CSV_URL,  null)
      ]);
      const trainAll = parseMnistCsvLinesToItems(trainLines);
      const valAll   = parseMnistCsvLinesToItems(testLines);

      const trainItems = balancedSampleByLabel(trainAll, MAX_TRAIN_ITEMS);
      const valItems   = balancedSampleByLabel(valAll,   MAX_VAL_ITEMS);

      const classes = Array.from({ length: NUM_CLASSES }, (_, i) => String(i));
      devLog(`MNIST bilanciato: ${trainItems.length} train, ${valItems.length} val`);

      return {
        trainManifest: { classes, items: trainItems },
        valManifest:   { classes, items: valItems }
      };
    }

    /******************************************************************
     * MODELLO CNN + COMPILE
     ******************************************************************/
    function compileModel(m) {
      m.compile({
        optimizer: tf.train.adam(0.0005),
        loss: "categoricalCrossentropy",
        metrics: ["accuracy"]
      });
    }

    function buildModel() {
      const m = tf.sequential();
      m.add(tf.layers.conv2d({
        inputShape: [IMG_SIZE, IMG_SIZE, NUM_CHANNELS],
        filters: 8,
        kernelSize: 3,
        activation: "relu",
        padding: "same",
        name: "conv1"
      }));
      m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
      m.add(tf.layers.conv2d({
        filters: 16,
        kernelSize: 3,
        activation: "relu",
        padding: "same",
        name: "conv2"
      }));
      m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
      m.add(tf.layers.flatten());
      m.add(tf.layers.dense({
        units: HIDDEN_MAX,
        activation: "relu",
        name: "dense_hidden"
      }));
      m.add(tf.layers.dense({
        units: NUM_CLASSES,
        activation: "softmax",
        name: "dense_out"
      }));
      compileModel(m);
      return m;
    }

    async function reinitializeModelWeights() {
      devLog("Creo un nuovo modello locale (rete fissa).");
      model = buildModel();
    }

    /******************************************************************
     * PESI FLOAT / QUANTIZZAZIONE + SANITIZZAZIONE
     ******************************************************************/
    function extractFloatWeights() {
      // NON dispose: questi Tensor sono le Variables del modello
      const tensors = model.getWeights();
      const shapes = tensors.map(t => t.shape);
      const arrays = tensors.map(t => Float32Array.from(t.dataSync()));
      return { shapes, arrays };
    }

    function quantizeWeights(shapes, arrays) {
      const scales = [];
      const quantArrays = [];
      for (const arr of arrays) {
        let maxAbs = 0;
        for (let i = 0; i < arr.length; i++) {
          const a = Math.abs(arr[i]);
          if (a > maxAbs) maxAbs = a;
        }
        const scale = maxAbs > 0 ? maxAbs / 127.0 : 1e-8;
        const q = new Int8Array(arr.length);
        for (let i = 0; i < arr.length; i++) {
          q[i] = Math.max(-127, Math.min(127, Math.round(arr[i] / scale)));
        }
        scales.push(scale);
        quantArrays.push(Array.from(q));
      }
      return { shapes, scales, quantArrays };
    }

    function dequantizeSnapshot(snapDoc) {
      const shapesContainer = snapDoc.shapes || {};
      const scales = snapDoc.scales || [];
      const quantContainer = snapDoc.quantArrays || {};

      const arrays = [];
      const shapes = [];

      const indices = Object.keys(quantContainer)
        .map(k => Number(k))
        .sort((a, b) => a - b);

      for (const idx of indices) {
        const qArr = quantContainer[idx];
        const shape = Array.isArray(shapesContainer)
          ? shapesContainer[idx]
          : shapesContainer[idx];
        const scale = scales[idx];
        if (!qArr || !shape || scale == null) continue;

        const fArr = new Float32Array(qArr.length);
        for (let i = 0; i < qArr.length; i++) {
          fArr[i] = qArr[i] * scale;
        }
        arrays.push(fArr);
        shapes.push(shape);
      }
      return { shapes, arrays };
    }

    function sanitizeWeightArrays(arrays) {
      let changed = false;
      for (let t = 0; t < arrays.length; t++) {
        const arr = arrays[t];
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i];
          if (!Number.isFinite(v)) {
            arr[i] = 0;
            changed = true;
          }
        }
      }
      if (changed) {
        devLog("Sanitizzazione pesi globali: trovati NaN/Inf → settati a 0.");
      }
      return changed;
    }
    async function computeTrustScoreForSnapshot(snap) {
  // Se non abbiamo ancora il validation set, diamo un trust "neutrale"
  if (!valManifest || !valManifest.items || !valManifest.items.length) {
    devLog("Trust: valManifest non pronto, uso trust neutrale 0.5");
    return 0.5;
  }

  const d = snap.data || {};
  const peerId = d.clientId || "unknown";
  devLog(`Trust: valutazione snapshot ${snap.id} da client ${peerId}`);

  const { shapes, arrays } = dequantizeSnapshot(d);

  try {
    // Costruiamo un modello temporaneo con QUEI pesi
    const tempModel = buildModel();
    const tensors = arrays.map((arr, idx) =>
      tf.tensor(arr, shapes[idx], "float32")
    );
    tempModel.setWeights(tensors);
    tensors.forEach(t => t.dispose());

    // Mini-task di validazione locale (message test): 24–32 esempi
    const B = Math.min(VAL_BATCH_SIZE * 2, 32);
    const batch = await loadBatchFromManifest(valManifest, B);
    const evalRes = await tempModel.evaluate(batch.xs, batch.ys, {
      batchSize: VAL_BATCH_SIZE,
      verbose: 0
    });

    const lossTensor = Array.isArray(evalRes) ? evalRes[0] : evalRes;
    const accTensor  = Array.isArray(evalRes) ? evalRes[1] : null;

    const lossArr = await lossTensor.data();
    const loss = lossArr[0];
    let acc = null;
    if (accTensor) {
      const accArr = await accTensor.data();
      acc = accArr[0];
    }

    lossTensor.dispose();
    accTensor && accTensor.dispose();
    batch.xs.dispose();
    batch.ys.dispose();
    tempModel.dispose();

    if (!Number.isFinite(loss) || acc == null || !Number.isFinite(acc)) {
      devLog(`Trust: snapshot ${snap.id} produce NaN/acc=null → trust=0.`);
      return 0;
    }

    // Accuracy random per 10 classi ≈ 0.1 → normalizziamo tra 0 e 1
    const trust = clamp((acc - 0.10) / 0.90, 0, 1);
    devLog(
      `Trust: snapshot ${snap.id} acc=${(acc * 100).toFixed(1)}%, loss=${loss.toFixed(
        3
      )} → trust=${trust.toFixed(3)}`
    );
    return trust;
  } catch (e) {
    console.warn("Errore computeTrustScoreForSnapshot:", e);
    devLog("Trust: errore valutando snapshot " + snap.id + ": " + e.message);
    return 0;
  }
}

async function getTrustScoreForSnapshot(snap) {
  const d = snap.data || {};
  const peerId = d.clientId || "unknown";
  const now = Date.now();
  const existing = trustScores.get(peerId);

  // Ricicla il trust se è recente (es. < 10 minuti)
  if (existing && now - existing.ts < 10 * 60 * 1000) {
    return existing.score;
  }

  const score = await computeTrustScoreForSnapshot(snap);
  trustScores.set(peerId, { score, ts: now });
  return score;
}


    /******************************************************************
     * SALVATAGGIO MANUALE DEL MODELLO IN LOCALSTORAGE
     ******************************************************************/
    async function saveLocalModelAndMeta() {
      let weightsPayload = null;
      try {
        const { shapes, arrays } = extractFloatWeights();
        weightsPayload = {
          shapes,
          arrays: arrays.map(a => Array.from(a))
        };
      } catch (e) {
        console.warn("Errore estrazione pesi per salvataggio:", e);
        devLog("Errore estrazione pesi per salvataggio: " + e.message);
      }

      const meta = {
        weights: weightsPayload,
        activeHiddenSize,
        samplesTrained,
        batchesTrained,
        lastTrainLoss,
        lastValLoss,
        resetToken: currentResetToken || null
      };
      try {
        localStorage.setItem(META_STORAGE_KEY, JSON.stringify(meta));
      } catch (e) {
        console.warn("Salvataggio meta localStorage fallito:", e);
        devLog("Salvataggio meta localStorage fallito: " + e.message);
      }
    }

    async function loadLocalModelIfExists() {
      let meta = null;
      try {
        const metaStr = localStorage.getItem(META_STORAGE_KEY);
        if (metaStr) meta = JSON.parse(metaStr);
      } catch (e) {
        console.warn("Errore lettura meta localStorage:", e);
      }

      model = buildModel();

      if (meta && meta.weights && meta.weights.shapes && meta.weights.arrays) {
        activeHiddenSize = clamp(meta.activeHiddenSize || HIDDEN_MAX, HIDDEN_MIN, HIDDEN_MAX);
        samplesTrained   = meta.samplesTrained || 0;
        batchesTrained   = meta.batchesTrained || 0;
        lastTrainLoss    = meta.lastTrainLoss ?? null;
        lastValLoss      = meta.lastValLoss ?? null;
        currentResetToken= meta.resetToken || null;

        try {
          const shapes = meta.weights.shapes;
          const arrays = meta.weights.arrays;
          if (shapes.length === arrays.length) {
            const tensors = shapes.map((shape, idx) =>
              tf.tensor(arrays[idx], shape, "float32")
            );
            model.setWeights(tensors);
            tensors.forEach(t => t.dispose());
            devLog("Pesi modello ripristinati da localStorage.");
          } else {
            devLog("Meta pesi inconsistente (shapes/arrays length mismatch), uso modello random.");
          }
        } catch (e) {
          console.warn("Errore ripristino pesi da meta:", e);
          devLog("Errore ripristino pesi da meta: " + e.message);
        }
        devLog(
          `Meta locale caricata: samples=${samplesTrained}, batches=${batchesTrained}, activeH=${activeHiddenSize}`
        );
      } else {
        activeHiddenSize = HIDDEN_MAX;
        currentResetToken = meta?.resetToken || null;
        devLog("Nessun modello salvato in localStorage, modello nuovo.");
        await saveLocalModelAndMeta();
      }
    }

    /******************************************************************
     * IMAGE LOADING → TENSOR
     ******************************************************************/
    async function loadImageAsTensor(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const canvas = document.getElementById("imageLoaderCanvas");
          const ctx = canvas.getContext("2d");
          canvas.width = IMG_SIZE;
          canvas.height = IMG_SIZE;
          ctx.drawImage(img, 0, 0, IMG_SIZE, IMG_SIZE);
          let imgTensor = tf.browser.fromPixels(canvas, NUM_CHANNELS);
          imgTensor = tf.tidy(() => imgTensor.toFloat().div(255.0));
          const batched = imgTensor.expandDims(0);
          imgTensor.dispose();
          resolve(batched);
        };
        img.onerror = (e) => reject(e);
        img.src = url;
      });
    }

    async function loadBatchFromManifest(manifest, batchSize) {
      const items = manifest.items;
      if (!items || items.length === 0) {
        throw new Error("Manifest dataset vuoto.");
      }
      const xsList = [];
      const ysList = [];
      for (let i = 0; i < batchSize; i++) {
        const idx = Math.floor(Math.random() * items.length);
        const item = items[idx];
        const x = await loadImageAsTensor(item.url);
        xsList.push(x);
        ysList.push(item.label);
      }
      const xs = tf.concat(xsList, 0);
      xsList.forEach(t => t.dispose());
      const ysIdx = tf.tensor1d(ysList, "int32");
      const ys = tf.oneHot(ysIdx, NUM_CLASSES);
      ysIdx.dispose();
      return { xs, ys };
    }

    /******************************************************************
     * SINKHORN & UTILITIES PER RETE GLOBALE
     ******************************************************************/
    function denseHiddenKernelToNeuronMatrix(flatArray, shape, activeSize) {
      const inDim = shape[0];
      const hiddenMax = shape[1];
      const H = Math.min(activeSize, hiddenMax);
      const matrix = [];
      for (let h = 0; h < H; h++) {
        const neuron = [];
        for (let i = 0; i < inDim; i++) {
          const idx = i * hiddenMax + h;
          neuron.push(flatArray[idx]);
        }
        matrix.push(neuron);
      }
      return matrix;
    }

    function euclideanDistance(a, b) {
      let sum = 0;
      for (let i = 0; i < a.length; i++) {
        const d = a[i] - b[i];
        sum += d * d;
      }
      return Math.sqrt(sum);
    }

    function computeCostMatrix(localMat, neighMat) {
      const Hloc = localMat.length;
      const Hnei = neighMat.length;
      const H = Math.min(Hloc, Hnei);
      const C = [];
      for (let i = 0; i < H; i++) {
        const row = [];
        for (let j = 0; j < H; j++) {
          row.push(euclideanDistance(localMat[i], neighMat[j]));
        }
        C.push(row);
      }
      return C;
    }

    function runSinkhorn(costMatrix, baseEpsFactor = 0.25, iterations = 20) {
  const H = costMatrix.length;
  if (!H) return { P: [] };

  // Stima della scala tipica dei costi
  let sum = 0;
  let count = 0;
  for (let i = 0; i < H; i++) {
    for (let j = 0; j < H; j++) {
      sum += costMatrix[i][j];
      count++;
    }
  }
  const meanC = count > 0 ? sum / count : 1.0;
  const epsilon = Math.max(meanC * baseEpsFactor, 1e-6);

  // Kernel entropico iniziale
  const P = [];
  for (let i = 0; i < H; i++) {
    const row = [];
    for (let j = 0; j < H; j++) {
      row.push(Math.exp(-costMatrix[i][j] / epsilon));
    }
    P.push(row);
  }

  // Normalizzazione alternata (righe/colonne)
  for (let it = 0; it < iterations; it++) {
    // righe
    for (let i = 0; i < H; i++) {
      let s = 0;
      for (let j = 0; j < H; j++) s += P[i][j];
      if (s > 0) {
        for (let j = 0; j < H; j++) P[i][j] /= s;
      }
    }
    // colonne
    for (let j = 0; j < H; j++) {
      let s = 0;
      for (let i = 0; i < H; i++) s += P[i][j];
      if (s > 0) {
        for (let i = 0; i < H; i++) P[i][j] /= s;
      }
    }
  }

  return { P };
}

function alignNeighborHidden(shapes, arraysLocal, arraysNeigh, localActive, neighActive) {
  const H = Math.min(localActive, neighActive);
  if (H === 0) return { arraysAligned: arraysNeigh, quality: 0 };

  const kernelShape = shapes[IDX_DH_KERNEL];
  const localKernel = arraysLocal[IDX_DH_KERNEL];
  const neighKernel = arraysNeigh[IDX_DH_KERNEL];
  const localMat = denseHiddenKernelToNeuronMatrix(localKernel, kernelShape, localActive);
  const neighMat = denseHiddenKernelToNeuronMatrix(neighKernel, kernelShape, neighActive);

  const C = computeCostMatrix(localMat.slice(0, H), neighMat.slice(0, H));
  const { P } = runSinkhorn(C, 0.25, 20);
  const perm = argmaxPermutation(P);

  // qualità normalizzata: 0 ≈ matching casuale, 1 ≈ matching perfetto
  let diagSum = 0;
  for (let i = 0; i < H; i++) {
    diagSum += P[i][perm[i]];
  }
  const meanDiag = diagSum / H;
  const uniformDiag = 1.0 / H;
  let qNorm = (meanDiag - uniformDiag) / (1 - uniformDiag + 1e-6);
  qNorm = clamp(qNorm, 0, 1);

  devLog(
    `Sinkhorn align: H=${H}, meanDiag=${meanDiag.toFixed(3)}, qNorm=${qNorm.toFixed(3)}`
  );

  // Permutazione dei neuroni nella rete del vicino
  const alignedNeighArrays = arraysNeigh.map(arr => arr.slice());
  const neighKernelFlat = alignedNeighArrays[IDX_DH_KERNEL];
  const neighBiasFlat   = alignedNeighArrays[IDX_DH_BIAS];
  const neighOutKernel  = alignedNeighArrays[IDX_DO_KERNEL];
  const inDim = kernelShape[0];
  const hiddenMax = kernelShape[1];

  for (let h = 0; h < H; h++) {
    const srcH = perm[h];
    if (srcH === h) continue;
    // dense_hidden kernel
    for (let i = 0; i < inDim; i++) {
      const idx1 = i * hiddenMax + h;
      const idx2 = i * hiddenMax + srcH;
      const tmp = neighKernelFlat[idx1];
      neighKernelFlat[idx1] = neighKernelFlat[idx2];
      neighKernelFlat[idx2] = tmp;
    }
    // dense_hidden bias
    const tmpb = neighBiasFlat[h];
    neighBiasFlat[h] = neighBiasFlat[srcH];
    neighBiasFlat[srcH] = tmpb;
    // dense_out kernel
    const numClasses = shapes[IDX_DO_KERNEL][1];
    for (let c = 0; c < numClasses; c++) {
      const idx1 = h * numClasses + c;
      const idx2 = srcH * numClasses + c;
      const tmp2 = neighOutKernel[idx1];
      neighOutKernel[idx1] = neighOutKernel[idx2];
      neighOutKernel[idx2] = tmp2;
    }
  }
  return { arraysAligned: alignedNeighArrays, quality: qNorm };
}



    function argmaxPermutation(P) {
      const H = P.length;
      const perm = new Array(H).fill(0);
      const used = new Array(H).fill(false);
      for (let i = 0; i < H; i++) {
        let bestJ = 0;
        let bestVal = -Infinity;
        for (let j = 0; j < H; j++) {
          if (!used[j] && P[i][j] > bestVal) {
            bestVal = P[i][j];
            bestJ = j;
          }
        }
        perm[i] = bestJ;
        used[bestJ] = true;
      }
      return perm;
    }



   function robustAggregateTwo(shapes, arraysA, arraysB, stepAlpha) {
  // stepAlpha è la "forza" con cui il vicino influenza il modello globale
  const alpha = clamp(stepAlpha, 0.01, 0.15); // max 15% per fusione
  const out = [];
  for (let t = 0; t < arraysA.length; t++) {
    const a = arraysA[t];
    const b = arraysB[t];
    const n = a.length;
    const r = new Float32Array(n);
    for (let i = 0; i < n; i++) {
      r[i] = (1 - alpha) * a[i] + alpha * b[i];
    }
    out.push(r);
  }
  return out;
}


    /******************************************************************
     * UI: CHARTS, STATO, MESH
     ******************************************************************/
    function initCharts() {
      const localCtx = document.getElementById("localLossChart").getContext("2d");
      localLossChart = new Chart(localCtx, {
        type: "line",
        data: { labels: [], datasets: [{ label: "Loss locale", data: [], tension: 0.2 }] },
        options: {
          responsive: true,
          scales: { x: { display: false }, y: { display: true } },
          plugins: { legend: { display: false } }
        }
      });

      const globalCtx = document.getElementById("globalLossChart").getContext("2d");
      globalLossChart = new Chart(globalCtx, {
        type: "line",
        data: { labels: [], datasets: [{ label: "Loss globale (modello fuso)", data: [], tension: 0.2 }] },
        options: {
          responsive: true,
          scales: { x: { display: false }, y: { display: true } },
          plugins: { legend: { display: false } }
        }
      });
    }

    function pushChartPoint(chart, value) {
      if (!chart || value == null || !Number.isFinite(value)) return;
      chart.data.labels.push("");
      chart.data.datasets[0].data.push(value);
      if (chart.data.labels.length > 60) {
        chart.data.labels.shift();
        chart.data.datasets[0].data.shift();
      }
      chart.update("quiet");
    }

    function updateLocalStatusUI() {
      document.getElementById("tf-backend").textContent = tf.getBackend() || "–";
      document.getElementById("tf-version").textContent = "TF.js " + (tf.version ? tf.version.tfjs : "");

      document.getElementById("samples-trained").textContent = samplesTrained.toString();
      document.getElementById("batches-trained").textContent = batchesTrained + " batch";
      document.getElementById("batch-ms").textContent = formatMs(avgBatchMs);
      const throughput = avgBatchMs > 0 ? (TRAIN_BATCH_SIZE / (avgBatchMs / 1000)).toFixed(1) + " img/s" : "–";
      document.getElementById("throughput").textContent = throughput;

      const battLevelEl = document.getElementById("battery-level");
      const battStatusEl = document.getElementById("battery-status");
      if (batteryInfo) {
        const level = Math.round(batteryInfo.level * 100);
        battLevelEl.textContent = level + " %";
        battStatusEl.textContent = batteryInfo.charging ? "in carica" : "su batteria";
      } else {
        battLevelEl.textContent = "–";
        battStatusEl.textContent = "API non disponibile";
      }

      document.getElementById("local-loss").textContent =
        lastTrainLoss != null && Number.isFinite(lastTrainLoss) ? lastTrainLoss.toFixed(4) : "–";
      document.getElementById("val-loss").textContent =
        lastValLoss != null && Number.isFinite(lastValLoss)
          ? "validation: " + lastValLoss.toFixed(4)
          : "validation: –";

      document.getElementById("hidden-size").textContent = activeHiddenSize + " / " + HIDDEN_MAX;
      document.getElementById("hidden-policy").textContent = "rete locale: dimensione fissa";
      document.getElementById("sinkhorn-quality").textContent =
        lastSinkhornQuality != null && Number.isFinite(lastSinkhornQuality)
          ? lastSinkhornQuality.toFixed(3)
          : "–";
    }

    function updateGlobalStatusUI() {
      document.getElementById("clients-count").textContent = "Nodi: " + clientsState.size;
      document.getElementById("global-loss").textContent =
        lastGlobalValLoss != null && Number.isFinite(lastGlobalValLoss)
          ? lastGlobalValLoss.toFixed(4)
          : "–";

      document.getElementById("snapshots-count").textContent = lastSnapshots.length.toString();
      const lastSnapshotAgeEl = document.getElementById("last-snapshot-age");
      if (lastSnapshots.length > 0) {
        const last = lastSnapshots[0];
        if (last.localTimestamp) {
          const ageS = Math.round((Date.now() - last.localTimestamp) / 1000);
          lastSnapshotAgeEl.textContent = "ultimo snapshot ≈ " + ageS + " s fa";
        } else {
          lastSnapshotAgeEl.textContent = "ultimo snapshot: –";
        }
      } else {
        lastSnapshotAgeEl.textContent = "nessuno snapshot ancora";
      }
    }

    function resizeMeshCanvas() {
      const rect = meshCanvas.getBoundingClientRect();
      meshCanvas.width = rect.width * window.devicePixelRatio;
      meshCanvas.height = rect.height * window.devicePixelRatio;
      meshCtx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
      drawMesh();
    }
    window.addEventListener("resize", resizeMeshCanvas);

    function drawMesh() {
      const ctx = meshCtx;
      const width = meshCanvas.clientWidth;
      const height = meshCanvas.clientHeight;
      ctx.clearRect(0, 0, width, height);

      const entries = Array.from(clientsState.entries());
      const n = entries.length;
      if (n === 0) return;

      const cx = width / 2;
      const cy = height / 2;
      const radius = Math.min(width, height) * 0.35;
      meshNodesLayout.clear();

      for (let i = 0; i < n; i++) {
        const [cid, data] = entries[i];
        const angle = 2 * Math.PI * i / n;
        const x = cx + radius * Math.cos(angle);
        const y = cy + radius * Math.sin(angle);
        const cred = data.activeHiddenSize ? (data.activeHiddenSize / HIDDEN_MAX) : 0.5;
        const r = 10 + 8 * cred;
        meshNodesLayout.set(cid, { x, y, r });
      }

      ctx.strokeStyle = "rgba(120,150,255,0.15)";
      ctx.lineWidth = 1;
      for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
          const [cid1] = entries[i];
          const [cid2] = entries[j];
          const n1 = meshNodesLayout.get(cid1);
          const n2 = meshNodesLayout.get(cid2);
          ctx.beginPath();
          ctx.moveTo(n1.x, n1.y);
          ctx.lineTo(n2.x, n2.y);
          ctx.stroke();
        }
      }

      for (let i = 0; i < n; i++) {
        const [cid, data] = entries[i];
        const node = meshNodesLayout.get(cid);
        const isSelf = cid === clientId;
        let color = "#4f9cff";
        const loss = data.localLoss;
        if (loss != null) {
          if (loss < 0.4) color = "#57e39f";
          else if (loss < 0.8) color = "#ffd166";
          else color = "#ff6b6b";
        }
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.r, 0, 2 * Math.PI);
        ctx.fillStyle = isSelf ? "#ffffff" : color;
        ctx.fill();
        ctx.lineWidth = isSelf ? 3 : 1.5;
        ctx.strokeStyle = isSelf ? "#4f9cff" : "#111728";
        ctx.stroke();
      }
    }

    meshCanvas.addEventListener("click", (evt) => {
      const rect = meshCanvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;

      if (!meshNodesLayout.size) {
        console.warn("Nessun nodo nel layout mesh al click.");
        return;
      }

      let bestId = null;
      let bestDist2 = Infinity;
      for (const [cid, node] of meshNodesLayout.entries()) {
        const dx = x - node.x;
        const dy = y - node.y;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestDist2) {
          bestDist2 = d2;
          bestId = cid;
        }
      }
      if (!bestId) return;

      const node = meshNodesLayout.get(bestId);
      const maxDist2 = (meshNodesLayout.size === 1) ? Infinity : (4 * node.r * node.r);
      if (bestDist2 <= maxDist2) {
        showNodeDetails(bestId);
      }
    });

    function showNodeDetails(cid) {
      const data = clientsState.get(cid);
      const body = document.getElementById("node-details-body");
      if (!data) {
        body.textContent = "Nessun dato per questo nodo.";
        return;
      }
      const isSelf = cid === clientId;
      const lines = [];
      lines.push(`<div><strong>${isSelf ? "Questo nodo" : "Nodo remoto"}</strong></div>`);
      lines.push(`<div style="word-break:break-all;font-size:0.7rem;">ID: ${cid}</div>`);
      lines.push(`<div>Loss locale: ${data.localLoss != null && Number.isFinite(data.localLoss) ? data.localLoss.toFixed(4) : "–"}</div>`);
      lines.push(`<div>Val loss: ${data.valLoss != null && Number.isFinite(data.valLoss) ? data.valLoss.toFixed(4) : "–"}</div>`);
      lines.push(`<div>Neuroni nascosti attivi (meta): ${data.activeHiddenSize ?? "?"} / ${HIDDEN_MAX}</div>`);
      lines.push(`<div>Samples macinati: ${data.numSamplesTrained ?? 0}</div>`);
            const trustEntry = trustScores.get(cid);
      if (trustEntry && typeof trustEntry.score === "number") {
        lines.push(
          `<div>Trust locale: ${(trustEntry.score * 100).toFixed(1)} %</div>`
        );
      }

      lines.push(`<div>Ultimo visto: ${data.lastSeen ? new Date(data.lastSeen).toLocaleTimeString() : "–"}</div>`);
      body.innerHTML = lines.join("");
    }

    /******************************************************************
     * BATTERIA
     ******************************************************************/
    function initBattery() {
      if ("getBattery" in navigator) {
        navigator.getBattery().then(b => {
          batteryInfo = b;
          b.addEventListener("levelchange", updateLocalStatusUI);
          b.addEventListener("chargingchange", updateLocalStatusUI);
          updateLocalStatusUI();
        }).catch(() => {});
      }
    }

    /******************************************************************
     * TESTER: FILE + SAMPLE GALLERY (locale vs globale)
     ******************************************************************/
    function probsContainNonFinite(probs) {
      for (let i = 0; i < probs.length; i++) {
        if (!Number.isFinite(probs[i])) return true;
      }
      return false;
    }

    async function predictBothModels(xBatch) {
      const classes = trainManifest?.classes || [];
      const result = { local: null, global: null };

      // locale
      const yLocal = model.predict(xBatch);
      const localProbs = await yLocal.data();
      yLocal.dispose();
      if (!probsContainNonFinite(localProbs)) {
        let bestIdxL = 0;
        for (let i = 1; i < localProbs.length; i++) {
          if (localProbs[i] > localProbs[bestIdxL]) bestIdxL = i;
        }
        result.local = {
          probs: Array.from(localProbs),
          predIdx: bestIdxL,
          predLabel: classes[bestIdxL] ?? String(bestIdxL)
        };
      }

      // globale
      if (globalModel) {
        const yGlob = globalModel.predict(xBatch);
        const globProbs = await yGlob.data();
        yGlob.dispose();
        if (!probsContainNonFinite(globProbs)) {
          let bestIdxG = 0;
          for (let i = 1; i < globProbs.length; i++) {
            if (globProbs[i] > globProbs[bestIdxG]) bestIdxG = i;
          }
          result.global = {
            probs: Array.from(globProbs),
            predIdx: bestIdxG,
            predLabel: classes[bestIdxG] ?? String(bestIdxG)
          };
        }
      }

      return result;
    }

    function formatSoftmaxLine(pred, classes) {
      if (!pred) return "n/d (NaN o modello non pronto)";
      const probsStr = pred.probs
        .map((p, i) => {
          const name = classes[i] ?? String(i);
          return `${name}:${p.toFixed(3)}`;
        })
        .join(", ");
      return `[${probsStr}]  → pred: ${pred.predLabel}`;
    }

    function initTesterUI() {
      const input = document.getElementById("test-image-input");
      const btn = document.getElementById("test-btn");
      btn.addEventListener("click", async () => {
        const file = input.files && input.files[0];
        if (!file || !model || !trainManifest) return;
        const reader = new FileReader();
        reader.onload = async () => {
          const img = new Image();
          img.onload = async () => {
            const canvas = document.getElementById("imageLoaderCanvas");
            const ctx = canvas.getContext("2d");
            canvas.width = IMG_SIZE;
            canvas.height = IMG_SIZE;
            ctx.drawImage(img, 0, 0, IMG_SIZE, IMG_SIZE);
            let imgTensor = tf.browser.fromPixels(canvas, NUM_CHANNELS);
            imgTensor = tf.tidy(() => imgTensor.toFloat().div(255.0));
            const x = imgTensor.expandDims(0);
            imgTensor.dispose();

            const res = await predictBothModels(x);
            x.dispose();

            const classes = trainManifest.classes || [];
            const resultEl = document.getElementById("tester-result");

            const localStr  = formatSoftmaxLine(res.local, classes);
            const globalStr = formatSoftmaxLine(res.global, classes);

            resultEl.textContent =
              `File caricato\n` +
              `Locale  → ${localStr}\n` +
              `Globale → ${globalStr}`;

            devLog(
              `Predizione file: local=${res.local?.predLabel ?? "n/d"}, global=${res.global?.predLabel ?? "n/d"}`
            );
          };
          img.onerror = () => {
            document.getElementById("tester-result").textContent =
              "Errore caricamento immagine di test.";
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      });
    }

    function populateSampleImagesGallery() {
      const container = document.getElementById("sample-images-container");
      if (!container || !valManifest || !valManifest.items || !valManifest.items.length) {
        console.warn("Val manifest non pronto, nessuna immagine di esempio.");
        return;
      }
      container.innerHTML = "";
      const items = valManifest.items;
      const numSamples = Math.min(12, items.length);
      const used = new Set();
      while (used.size < numSamples) {
        const idx = Math.floor(Math.random() * items.length);
        used.add(idx);
      }
      for (const idx of used) {
        const item = items[idx];
        const imgEl = document.createElement("img");
        imgEl.src = item.url;
        imgEl.className = "sample-thumb";
        imgEl.title = "Label reale: " + item.label;
        imgEl.dataset.label = item.label;
        imgEl.dataset.url = item.url;
        imgEl.addEventListener("click", async () => {
          document.querySelectorAll(".sample-thumb.selected")
            .forEach(el => el.classList.remove("selected"));
          imgEl.classList.add("selected");
          try {
            await runPredictionOnSample(item.url, item.label);
          } catch (err) {
            console.error("Errore predizione sample:", err);
            devLog("Errore predizione sample: " + err);
          }
        });
        container.appendChild(imgEl);
      }
    }

    async function runPredictionOnSample(url, label) {
      if (!model || !trainManifest) {
        document.getElementById("tester-result").textContent =
          "Modello non ancora pronto.";
        return;
      }
      const x = await loadImageAsTensor(url);
      const res = await predictBothModels(x);
      x.dispose();

      const classes = trainManifest.classes || [];
      const trueName = classes[label] ?? String(label);

      const localStr  = formatSoftmaxLine(res.local, classes);
      const globalStr = formatSoftmaxLine(res.global, classes);

      const resultEl = document.getElementById("tester-result");
      resultEl.textContent =
        `Sample dal dataset (label reale: ${trueName})\n` +
        `Locale  → ${localStr}\n` +
        `Globale → ${globalStr}`;

      devLog(
        `Pred sample: true=${trueName}, local=${res.local?.predLabel ?? "n/d"}, global=${res.global?.predLabel ?? "n/d"}`
      );
    }

    /******************************************************************
     * PANIC BUTTON (reset locale)
     ******************************************************************/
    async function doLocalPanicReset() {
      if (!confirm("Reset locale: il modello e le statistiche su questo dispositivo verranno azzerati. Procedere?")) {
        return;
      }
      devLog("Panic reset locale richiesto.");

      try {
        localStorage.removeItem(META_STORAGE_KEY);
      } catch (e) {
        console.warn("Errore nel cancellare localStorage:", e);
      }

      stepsTrained = 0;
      batchesTrained = 0;
      samplesTrained = 0;
      lastTrainLoss = null;
      lastValLoss = null;
      lastGlobalValLoss = null;
      activeHiddenSize = HIDDEN_MAX;
      currentResetToken = null;

      await reinitializeModelWeights();
      await saveLocalModelAndMeta();
      updateLocalStatusUI();

      document.getElementById("tester-result").textContent =
        "Modello locale resettato. Il training riparte da zero su questo nodo.";
    }

    function initPanicButton() {
      const btn = document.getElementById("panic-btn");
      if (!btn) return;
      btn.addEventListener("click", () => {
        doLocalPanicReset().catch(err => console.error("Errore panic reset:", err));
      });
    }

    /******************************************************************
     * FIREBASE SUBSCRIPTIONS (CLIENTS + SNAPSHOTS + ROOM CONTROL)
     ******************************************************************/
    function subscribeToClientsAndSnapshots(db, roomId) {
      const clientsColRef = collection(db, "rooms", roomId, "clients");
      const snapshotsColRef = collection(db, "rooms", roomId, "snapshots");

      onSnapshot(clientsColRef, (snap) => {
        clientsState.clear();
        const now = Date.now();
        snap.forEach(docSnap => {
          const d = docSnap.data();
          let lastSeenMs = null;
          if (d.lastSeen && d.lastSeen.toMillis) {
            lastSeenMs = d.lastSeen.toMillis();
          }
          const isOffline = lastSeenMs && (now - lastSeenMs > OFFLINE_THRESHOLD_MS);
          if (isOffline) {
            return;
          }

          let localLoss = d.localLoss ?? null;
          let valLoss   = d.valLoss ?? null;
          let activeH   = d.activeHiddenSize ?? null;
          let numS      = d.numSamplesTrained ?? 0;

          if (docSnap.id === clientId) {
            localLoss = lastTrainLoss;
            valLoss   = lastValLoss;
            activeH   = activeHiddenSize;
            numS      = samplesTrained;
          }

          clientsState.set(docSnap.id, {
            localLoss: localLoss,
            valLoss: valLoss,
            activeHiddenSize: activeH,
            numSamplesTrained: numS,
            lastSeen: lastSeenMs
          });
        });
        updateGlobalStatusUI();
        drawMesh();
      });

      const q = query(snapshotsColRef, orderBy("createdAt", "desc"), limit(10));
      onSnapshot(q, snap => {
        const docs = [];
        snap.forEach(docSnap => {
          const d = docSnap.data();
          docs.push({ id: docSnap.id, data: d, localTimestamp: Date.now() });
        });
        lastSnapshots = docs;
        updateGlobalStatusUI();
      });

      return snapshotsColRef;
    }

    async function handleGlobalResetFromToken(newToken) {
      devLog("Reset globale rilevato. Nuovo token=" + newToken + ", vecchio=" + currentResetToken);
      currentResetToken = newToken;

      try {
        localStorage.removeItem(META_STORAGE_KEY);
      } catch (e) {
        console.warn("Errore nel cancellare localStorage durante reset globale:", e);
      }

      stepsTrained = 0;
      batchesTrained = 0;
      samplesTrained = 0;
      lastTrainLoss = null;
      lastValLoss = null;
      lastGlobalValLoss = null;
      activeHiddenSize = HIDDEN_MAX;

      await reinitializeModelWeights();
      await saveLocalModelAndMeta();
      updateLocalStatusUI();

      document.getElementById("tester-result").textContent =
        "Reset globale stanza rilevato. Modello locale re-inizializzato.";
    }

    function subscribeToRoomControl(db, roomId) {
      const roomRef = doc(db, "rooms", roomId);
      onSnapshot(roomRef, snapshot => {
        const d = snapshot.data() || {};
        const token = d.resetToken || null;
        if (!token) return;
        if (currentResetToken === null) {
          currentResetToken = token;
          devLog("ResetToken stanza iniziale: " + token);
          return;
        }
        if (token !== currentResetToken) {
          handleGlobalResetFromToken(token).catch(err => console.error("Errore handleGlobalReset:", err));
        }
      });
    }

    async function developerResetRoom() {
      if (!clientId) {
        alert("Non sei ancora autenticato su Firebase. Attendi qualche secondo.");
        return;
      }
      if (!confirm("Reset stanza Firebase: tutti i nodi connessi resetteranno il proprio modello locale. Procedere?")) {
        return;
      }

      const roomRef = doc(db, "rooms", ROOM_ID);
      const newToken = "reset-" + Date.now() + "-" + Math.random().toString(36).slice(2, 8);
      devLog("Developer reset stanza, nuovo resetToken=" + newToken);

      await setDoc(roomRef, {
        resetToken: newToken,
        lastResetBy: clientId,
        lastResetAt: serverTimestamp()
      }, { merge: true });
    }

    function initDeveloperTools() {
      const devSection = document.getElementById("dev-section");
      const devBtn = document.getElementById("firebase-reset-btn");
      if (!devSection || !devBtn) return;

      devBtn.addEventListener("click", () => {
        developerResetRoom().catch(err => console.error("Errore developerResetRoom:", err));
      });

      let devTapCount = 0;
      let devTimer = null;
      window.addEventListener("keydown", (e) => {
        if (e.key === "D" && e.shiftKey) {
          devTapCount++;
          if (devTapCount >= 3) {
            devSection.style.display = "block";
            devLog("Developer section sbloccata (Shift+D x3).");
          }
          clearTimeout(devTimer);
          devTimer = setTimeout(() => { devTapCount = 0; }, 2000);
        }
      });
    }

    /******************************************************************
     * TRAINING LOOP LOCALE (rete fissa, reset completo su errori)
     ******************************************************************/
    async function trainingLoop(clientRef, snapshotsColRef) {
      devLog("Training loop avviato.");
      while (true) {
        let xs = null, ys = null;
        const t0 = performance.now();
        try {
          const batch = await loadBatchFromManifest(trainManifest, TRAIN_BATCH_SIZE);
          xs = batch.xs;
          ys = batch.ys;

          const history = await model.fit(xs, ys, {
            epochs: 1,
            batchSize: TRAIN_BATCH_SIZE,
            shuffle: true,
            verbose: 0
          });
          const t1 = performance.now();

          xs.dispose();
          ys.dispose();
          xs = null; ys = null;

          let loss = history.history.loss[0];

          if (!Number.isFinite(loss)) {
            console.warn("Loss NaN/Inf, resetto completamente il modello locale.");
            devLog("Loss NaN/Inf durante training; recreo il modello locale da zero.");

            await reinitializeModelWeights();
            lastTrainLoss = null;
            lastValLoss = null;
            lastGlobalValLoss = null;
            stepsTrained = 0;
            batchesTrained = 0;
            samplesTrained = 0;

            await saveLocalModelAndMeta();
            updateLocalStatusUI();
            await sleep(TRAINING_PAUSE_MS);
            continue;
          }

          lastTrainLoss = loss;
          stepsTrained += 1;
          batchesTrained += 1;
          samplesTrained += TRAIN_BATCH_SIZE;

          const batchMs = t1 - t0;
          if (avgBatchMs === 0) avgBatchMs = batchMs;
          else avgBatchMs = avgBatchMs * 0.9 + batchMs * 0.1;

          pushChartPoint(localLossChart, loss);
          devLog(`Train step ${stepsTrained}: loss=${loss.toFixed(4)}, samples=${samplesTrained}`);

          if (stepsTrained % VALIDATION_EVERY_STEPS === 0) {
            try {
              const valBatch = await loadBatchFromManifest(valManifest, VAL_BATCH_SIZE);
              const evalRes = await model.evaluate(valBatch.xs, valBatch.ys, {
                batchSize: VAL_BATCH_SIZE,
                verbose: 0
              });
              const valLossTensor = Array.isArray(evalRes) ? evalRes[0] : evalRes;
              const valLossVal = (await valLossTensor.data())[0];
              if (Number.isFinite(valLossVal)) {
                lastValLoss = valLossVal;
                devLog(`Validation: valLoss=${valLossVal.toFixed(4)}`);
              } else {
                console.warn("Val loss NaN/Inf ignorata.");
                devLog("Val loss NaN/Inf ignorata.");
              }
              valLossTensor.dispose();
              valBatch.xs.dispose();
              valBatch.ys.dispose();
            } catch (e) {
              console.warn("Errore validation batch:", e);
              devLog("Errore validation batch: " + e.message);
            }
          }

          if (stepsTrained % SNAPSHOT_EVERY_STEPS === 0) {
            const { shapes, arrays } = extractFloatWeights();
            const quant = quantizeWeights(shapes, arrays);

            const shapesMap = {};
            quant.shapes.forEach((shapeArr, idx) => {
              shapesMap[idx] = shapeArr;
            });
            const quantArraysMap = {};
            quant.quantArrays.forEach((qArr, idx) => {
              quantArraysMap[idx] = qArr;
            });

            const snapshotDoc = {
              clientId,
              createdAt: serverTimestamp(),
              localValLoss: lastValLoss,
              modelVersion: stepsTrained,
              shapes: shapesMap,
              scales: quant.scales,
              quantArrays: quantArraysMap,
              activeHiddenSize
            };
            await addDoc(snapshotsColRef, snapshotDoc);
            await saveLocalModelAndMeta();
            devLog(`Snapshot pubblicato (step=${stepsTrained}, activeH=${activeHiddenSize})`);
          }

          await setDoc(clientRef, {
            lastSeen: serverTimestamp(),
            localLoss: lastTrainLoss,
            valLoss: lastValLoss,
            activeHiddenSize,
            numSamplesTrained: samplesTrained
          }, { merge: true });

          updateLocalStatusUI();
          await sleep(TRAINING_PAUSE_MS);
        } catch (e) {
          if (xs) xs.dispose();
          if (ys) ys.dispose();
          console.error("Errore in trainingLoop step:", e);
          devLog("Errore trainingLoop step: " + (e && e.message ? e.message : e));
          if (e && e.stack) {
            devLog("Stack (primi 300 caratteri): " + e.stack.slice(0, 300) + "...");
          }

          try {
            await reinitializeModelWeights();
          } catch (re) {
            console.error("Errore reinitializeModelWeights dopo failure:", re);
            devLog("Errore reinitializeModelWeights: " + re.message);
          }
          lastTrainLoss = null;
          lastValLoss = null;
          lastGlobalValLoss = null;
          stepsTrained = 0;
          batchesTrained = 0;
          samplesTrained = 0;

          try {
            await saveLocalModelAndMeta();
          } catch (se) {
            console.error("Errore saveLocalModelAndMeta dopo failure:", se);
            devLog("Errore saveLocalModelAndMeta post-failure: " + se.message);
          }

          updateLocalStatusUI();
          await sleep(TRAINING_PAUSE_MS);
        }
      }
    }

    /******************************************************************
     * FUSIONE DISTRIBUITA: aggiorna globalModel e global loss
     ******************************************************************/
    async function fusionLoop() {
      devLog("Fusion loop (rete globale) avviato.");

      while (true) {
        await sleep(FUSION_INTERVAL_MS);
        if (!lastSnapshots.length) continue;

        const candidates = lastSnapshots.filter(
          s => s.data && s.data.clientId !== clientId
        );
        if (!candidates.length) continue;

        if (!globalModelState) {
          let best = candidates[0];
          let bestScore =
            candidates[0].data.localValLoss != null
              ? candidates[0].data.localValLoss
              : Infinity;

          for (const s of candidates) {
            const v =
              s.data.localValLoss != null ? s.data.localValLoss : Infinity;
            if (v < bestScore) {
              bestScore = v;
              best = s;
            }
          }

          const base = dequantizeSnapshot(best.data);
          const baseActive = clamp(
            best.data.activeHiddenSize ?? HIDDEN_MAX,
            HIDDEN_MIN,
            HIDDEN_MAX
          );

          globalModelState = {
            shapes: base.shapes,
            arrays: base.arrays,
            activeHiddenSize: baseActive
          };

          devLog(
            `Global model inizializzato da snapshot ${best.id} (activeH=${baseActive})`
          );
        } else {
                const { shapes } = globalModelState;
        let globalArrays = globalModelState.arrays;
        let globalActive = globalModelState.activeHiddenSize;

        let qualityAccum = 0;
        let qualityCount = 0;

        const neighbors = candidates.slice(0, FUSION_NEIGHBORS_LIMIT);
        for (const snap of neighbors) {
          const d = snap.data;
          try {
            const neigh = dequantizeSnapshot(d);

            if (JSON.stringify(neigh.shapes) !== JSON.stringify(shapes)) {
              devLog(`Fusion: snapshot ${snap.id} ignorato (shape diversa).`);
              continue;
            }

            const neighActive = clamp(
              d.activeHiddenSize ?? globalActive,
              HIDDEN_MIN,
              HIDDEN_MAX
            );

            const { arraysAligned, quality } = alignNeighborHidden(
              shapes,
              globalArrays,
              neigh.arrays,
              globalActive,
              neighActive
            );

            if (!Number.isFinite(quality)) {
              devLog(`Fusion: snapshot ${snap.id} scartato (quality NaN).`);
              continue;
            }

            // Gestione asincronia: penalizziamo snapshot vecchi
            let ageSec = 0;
            if (d.createdAt && d.createdAt.toMillis) {
              ageSec = (Date.now() - d.createdAt.toMillis()) / 1000;
            } else if (snap.localTimestamp) {
              ageSec = (Date.now() - snap.localTimestamp) / 1000;
            }
            const timeFactor = Math.exp(-ageSec / 120); // 2 minuti → ~1/e
            const qEff = quality * timeFactor;

            if (qEff < 0.15) {
              devLog(
                `Fusion: snapshot ${snap.id} scartato (qEff=${qEff.toFixed(
                  3
                )}, age=${ageSec.toFixed(1)}s)`
              );
              continue;
            }

            // 🔐 TRUST: mini-task di validazione sul modello del vicino
            const trust = await getTrustScoreForSnapshot(snap);
            if (trust < 0.2) {
              devLog(
                `Fusion: snapshot ${snap.id} scartato (trust=${trust.toFixed(3)})`
              );
              continue;
            }

            // α di aggiornamento: dipende da qualità, tempo e trust
            const stepAlpha = clamp(0.08 * qEff * trust, 0.01, 0.10);

            qualityAccum += quality;
            qualityCount++;

            globalArrays = robustAggregateTwo(
              shapes,
              globalArrays,
              arraysAligned,
              stepAlpha
            );

            const metaAlpha = 0.05;
            globalActive = Math.round(
              (1 - metaAlpha) * globalActive + metaAlpha * neighActive
            );
            globalActive = clamp(globalActive, HIDDEN_MIN, HIDDEN_MAX);

            devLog(
              `Fusion step con ${snap.id}: quality=${quality.toFixed(
                3
              )}, qEff=${qEff.toFixed(3)}, trust=${trust.toFixed(
                3
              )}, alpha=${stepAlpha.toFixed(3)}, globalH=${globalActive}`
            );
          } catch (e) {
            console.warn("Errore nella fusione globale con snapshot", snap.id, e);
            devLog(
              "Errore fusione globale con snapshot " + snap.id + ": " + e.message
            );
          }
        }


        if (qualityCount > 0) {
          lastSinkhornQuality = qualityAccum / qualityCount;
          sanitizeWeightArrays(globalArrays);
          globalModelState.arrays = globalArrays;
          globalModelState.activeHiddenSize = globalActive;

          devLog(
            `Fusion globale aggiornata: neighbors=${neighbors.length}, avgQ=${lastSinkhornQuality.toFixed(
              3
            )}, globalH=${globalActive}`
          );
        }

        }

        // aggiorna / crea globalModel per inference
        if (globalModelState) {
          if (!globalModel) {
            globalModel = buildModel();
            devLog("Creato globalModel per inference.");
          }
          try {
            const tensors = globalModelState.arrays.map((arr, idx) =>
              tf.tensor(arr, globalModelState.shapes[idx], "float32")
            );
            globalModel.setWeights(tensors);
            tensors.forEach(t => t.dispose());
          } catch (e) {
            console.warn("Errore setWeights globalModel:", e);
            devLog("Errore setWeights globalModel: " + e.message);
          }

          // Valutazione rapida del modello globale
          try {
            if (valManifest && valManifest.items && valManifest.items.length > 0) {
              const valBatch = await loadBatchFromManifest(valManifest, VAL_BATCH_SIZE);
              const evalRes = await globalModel.evaluate(valBatch.xs, valBatch.ys, {
                batchSize: VAL_BATCH_SIZE,
                verbose: 0
              });
              const valLossTensor = Array.isArray(evalRes) ? evalRes[0] : evalRes;
              const valLossVal = (await valLossTensor.data())[0];
              if (Number.isFinite(valLossVal)) {
                lastGlobalValLoss = valLossVal;
                pushChartPoint(globalLossChart, lastGlobalValLoss);
                devLog(`Global model valLoss=${valLossVal.toFixed(4)}`);
                updateGlobalStatusUI();
              }
              valLossTensor.dispose();
              valBatch.xs.dispose();
              valBatch.ys.dispose();
            }
          } catch (e) {
            console.warn("Errore valutazione modello globale:", e);
            devLog("Errore valutazione modello globale: " + e.message);
          }
        }
      }
    }

    /******************************************************************
     * ENTRYPOINT
     ******************************************************************/
    async function start() {
      devLog("Applicazione avviata.");
      initCharts();
      initTesterUI();
      initPanicButton();
      initDeveloperTools();
      initBattery();
      resizeMeshCanvas();
      updateLocalStatusUI();
      updateGlobalStatusUI();

      const { trainManifest: tm, valManifest: vm } = await loadMnistPngManifests();
      trainManifest = tm;
      valManifest   = vm;
      populateSampleImagesGallery();

      try {
        await signInAnonymously(auth);
        devLog("Login anonimo Firebase OK.");
      } catch (err) {
        console.error("signInAnonymously error:", err);
        devLog("Errore login anonimo Firebase: " + err.message);
        return;
      }

      onAuthStateChanged(auth, async (user) => {
        if (!user) return;
        currentUser = user;
        clientId = user.uid;
        document.getElementById("client-id-pill").textContent =
          "Client: " + clientId.slice(0, 6) + "…";
        devLog("Auth state: clientId=" + clientId);

        await loadLocalModelIfExists();
        document.getElementById("model-ready-pill").textContent = "Modello: pronto";
        document.getElementById("test-btn").disabled = false;
        updateLocalStatusUI();

        const roomRef = doc(db, "rooms", ROOM_ID);
        await setDoc(roomRef, {
          name: "Distributed image demo",
          task: "MNIST PNG federated",
          createdAt: serverTimestamp()
        }, { merge: true });

        const clientRef = doc(db, "rooms", ROOM_ID, "clients", clientId);
        await setDoc(clientRef, {
          lastSeen: serverTimestamp(),
          localLoss: lastTrainLoss,
          valLoss: lastValLoss,
          activeHiddenSize,
          numSamplesTrained: samplesTrained
        }, { merge: true });

        setInterval(() => {
          setDoc(clientRef, { lastSeen: serverTimestamp() }, { merge: true });
        }, 30000);

        const snapshotsColRef = subscribeToClientsAndSnapshots(db, ROOM_ID);
        subscribeToRoomControl(db, ROOM_ID);

        trainingLoop(clientRef, snapshotsColRef);
        fusionLoop();
      });
    }

    start().catch(err => {
      console.error("Errore start()", err);
      devLog("Errore start(): " + err.message);
    });
  </script>
</body>
</html>
