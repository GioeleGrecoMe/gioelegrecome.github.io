<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>ATC Diffusion MNIST Demo (Sayed-style)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #050814;
      color: #f0f4ff;
      --card-bg: #151a2c;
      --accent: #4f9cff;
      --accent-soft: rgba(79, 156, 255, 0.15);
    }
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      padding: 0.8rem 1rem;
      border-bottom: 1px solid #20263a;
    }
    header h1 {
      margin: 0;
      font-size: 1.1rem;
    }
    header p {
      margin: 0.2rem 0 0;
      font-size: 0.75rem;
      color: #9ca4c7;
    }
    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      grid-template-rows: auto auto 1fr;
      gap: 0.8rem;
      padding: 0.8rem;
      box-sizing: border-box;
    }
    section {
      background: var(--card-bg);
      border-radius: 0.75rem;
      padding: 0.7rem 0.9rem;
      box-shadow: 0 0 0 1px #1f2840;
      min-width: 0;
    }
    section h2 {
      margin: 0 0 0.4rem;
      font-size: 0.95rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .pill {
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: var(--accent-soft);
      color: #4f9cff;
    }
    .ghost-btn {
      background: transparent;
      border: 1px solid #ff6b6b;
      color: #ff6b6b;
      border-radius: 999px;
      padding: 0.15rem 0.6rem;
      font-size: 0.7rem;
      cursor: pointer;
      margin-right: 0.4rem;
    }
    .ghost-btn:hover {
      background: rgba(255,107,107,0.15);
    }
    #local-section { grid-column: 1 / 2; grid-row: 1 / 2; }
    #combine-section { grid-column: 2 / 3; grid-row: 1 / 2; }
    #mesh-section { grid-column: 1 / 2; grid-row: 2 / 4; }
    #tester-section { grid-column: 2 / 3; grid-row: 2 / 4; }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.4rem;
      margin-bottom: 0.6rem;
    }
    .stat {
      background: #1a2136;
      border-radius: 0.6rem;
      padding: 0.35rem 0.45rem;
      font-size: 0.8rem;
    }
    .stat .label { color: #9ca4c7; font-size: 0.7rem; }
    .stat .value { font-weight: 600; margin-top: 0.1rem; }
    .stat .sub { font-size: 0.7rem; color: #8891b3; margin-top: 0.1rem; }

    canvas.loss-chart {
      width: 100%;
      height: 120px;
    }

    #meshCanvas {
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #1b2340, #050814);
      border-radius: 0.6rem;
      border: 1px solid #222a42;
      box-sizing: border-box;
      cursor: pointer;
    }
    #node-details {
      font-size: 0.8rem;
      background: #101628;
      border-radius: 0.5rem;
      padding: 0.45rem;
      margin-top: 0.4rem;
    }

    #tester-section input[type="file"] {
      font-size: 0.8rem;
      margin-bottom: 0.4rem;
    }
    #tester-section button {
      background: var(--accent);
      border: none;
      border-radius: 0.5rem;
      padding: 0.35rem 0.7rem;
      color: #0b1020;
      font-size: 0.8rem;
      cursor: pointer;
    }
    #tester-section button:disabled { opacity: 0.6; cursor: default; }
    #tester-result {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      white-space: pre-line;
    }
    .sample-thumb {
      width: 40px;
      height: 40px;
      border-radius: 0.3rem;
      border: 1px solid #303857;
      cursor: pointer;
      image-rendering: pixelated;
      background: #000;
      object-fit: cover;
    }
    .sample-thumb.selected {
      border-color: #4f9cff;
      box-shadow: 0 0 0 2px rgba(79,156,255,0.5);
    }

    #dev-log {
      margin-top: 0.4rem;
      max-height: 160px;
      overflow: auto;
      font-size: 0.7rem;
      background: #101628;
      border-radius: 0.5rem;
      padding: 0.4rem;
      border: 1px solid #232b45;
    }

    footer {
      padding: 0.5rem 0.8rem;
      font-size: 0.7rem;
      color: #7b84a7;
      border-top: 1px solid #20263a;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto auto;
      }
      #local-section, #combine-section, #mesh-section, #tester-section {
        grid-column: 1 / 2;
        grid-row: auto;
      }
      #meshCanvas { height: 260px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>ATC Diffusion MNIST Demo</h1>
    <p>
      Implementazione semplificata di <strong>Adaptâ€“Thenâ€“Combine (Sayed)</strong> su MNIST PNG.
      Ogni nodo fa <em>Ïˆ-update</em> locale e poi combina con i vicini usando
      <strong>Adaptive Relative Variance</strong>.
    </p>
  </header>

  <main>
    <!-- STATO LOCALE -->
    <section id="local-section">
      <h2>
        Nodo locale
        <span>
          <button id="panic-btn" class="ghost-btn">Reset locale</button>
          <span class="pill" id="client-pill">Client: â€¦</span>
        </span>
      </h2>
      <div class="stat-grid">
        <div class="stat">
          <div class="label">Backend TF.js</div>
          <div class="value" id="tf-backend">â€“</div>
          <div class="sub" id="tf-version">â€“</div>
        </div>
        <div class="stat">
          <div class="label">Iterazioni (k)</div>
          <div class="value" id="local-steps">0</div>
          <div class="sub" id="local-samples">0 samples</div>
        </div>
        <div class="stat">
          <div class="label">Loss locale</div>
          <div class="value" id="local-loss">â€“</div>
          <div class="sub" id="local-valloss">validation: â€“</div>
        </div>
        <div class="stat">
          <div class="label">Tempo batch</div>
          <div class="value" id="batch-ms">â€“</div>
          <div class="sub" id="throughput">â€“</div>
        </div>
        <div class="stat">
          <div class="label">Varianza grad locale</div>
          <div class="value" id="grad-var">â€“</div>
          <div class="sub" id="grad-var-count">stima ARV (kâ‰¥10)</div>
        </div>
        <div class="stat">
          <div class="label">Hidden units</div>
          <div class="value" id="hidden-size">32</div>
          <div class="sub">stessa architettura per tutti</div>
        </div>
      </div>
      <canvas id="localLossChart" class="loss-chart"></canvas>
    </section>

    <!-- STATO COMBINE -->
    <section id="combine-section">
      <h2>
        Fusione ATC + ARV
        <span class="pill" id="clients-count">Nodi: 0</span>
      </h2>
      <div class="stat-grid">
        <div class="stat">
          <div class="label">Ultima fusione</div>
          <div class="value" id="combine-age">â€“</div>
          <div class="sub" id="combine-neighbors">â€“</div>
        </div>
        <div class="stat">
          <div class="label">Peso medio vicini</div>
          <div class="value" id="combine-weight">â€“</div>
          <div class="sub">somma a<sub>ij</sub> per jâ‰ i</div>
        </div>
        <div class="stat">
          <div class="label">Val loss dopo combine</div>
          <div class="value" id="combine-valloss">â€“</div>
          <div class="sub">su batch di validation locale</div>
        </div>
      </div>
      <canvas id="globalLossChart" class="loss-chart"></canvas>
    </section>

    <!-- MESH -->
    <section id="mesh-section">
      <h2>
        Rete dei nodi
        <span class="pill">Spessore = peso ATC locale</span>
      </h2>
      <canvas id="meshCanvas"></canvas>
      <div id="node-details">
        <strong>Dettagli nodo selezionato</strong>
        <div id="node-details-body">Nessun nodo selezionato.</div>
      </div>

      <div id="dev-log">
        <div id="dev-log-body">Developer logâ€¦</div>
      </div>
    </section>

    <!-- TESTER -->
    <section id="tester-section">
      <h2>
        Tester modello locale
        <span class="pill" id="model-pill">Modello: inizializzazioneâ€¦</span>
      </h2>
      <p style="font-size:0.78rem;color:#9ca4c7;">
        Carica una piccola immagine (ridimensionata a 28Ã—28, scala di grigi)
        oppure clicca su cifre dal test set MNIST. La rete che risponde Ã¨
        <strong>quella locale</strong>, dopo i passi di Adaptâ€“Thenâ€“Combine.
      </p>
      <input type="file" id="test-image-input" accept="image/*" />
      <button id="test-btn" disabled>Testa immagine</button>
      <div id="tester-result">In attesa che il training locale partaâ€¦</div>

      <div style="margin-top:0.7rem;">
        <div style="font-size:0.75rem;color:#9ca4c7;margin-bottom:0.2rem;">
          Oppure prova alcune cifre dal test set MNIST:
        </div>
        <div id="sample-images-container" style="display:flex;flex-wrap:wrap;gap:0.3rem;"></div>
      </div>

      <hr style="border-color:#20263a;margin:0.8rem 0;"/>
      <p style="font-size:0.72rem;color:#7b84a7;">
        Architettura:
        <code>conv8 â†’ conv16 â†’ flatten â†’ dense32 â†’ softmax10</code><br/>
        Algoritmo: <strong>ATC</strong> con scambio del vettore
        <em>Ïˆ</em> (pesi dopo l'adattamento) e combinazione
        <strong>Adaptive Relative Variance</strong>: i nodi con update piÃ¹ stabili
        pesano di piÃ¹.
      </p>
    </section>
  </main>

  <footer>
    Prototipo puramente client-side. Sostituisci il <code>firebaseConfig</code> con il tuo
    progetto Firebase (Firestore + auth anonima). Dataset: MNIST PNG, repo
    <code>rasbt/mnist-pngs</code> (MIT).
  </footer>

  <!-- Canvas nascosto per caricare / ridimensionare immagini -->
  <canvas id="imageLoaderCanvas" style="display:none;"></canvas>

  <!-- LIBRERIE -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script type="module">
    /******************************************************************
     * FIREBASE MODULAR API
     ******************************************************************/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
    import {
  getFirestore,
  doc,
  setDoc,
  collection,
  addDoc,
  onSnapshot,
  query,
  orderBy,
  limit,
  serverTimestamp,
  getDocs
} from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";
    import {
      getAuth,
      signInAnonymously,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

    /******************************************************************
     * CONFIGURAZIONE FIREBASE
     * (Sostituisci questi valori con i tuoi e NON committare le chiavi reali)
     ******************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyDUYL3b05b0RoyNMYCy9GZRtDs-4SBb-AI",
      authDomain: "twin-dungeon.firebaseapp.com",
      projectId: "twin-dungeon",
      storageBucket: "twin-dungeon.firebasestorage.app",
      messagingSenderId: "141719069384",
      appId: "1:141719069384:web:8cf21db6eddcadea0d3bfd",
      measurementId: "G-8L8Y6CL8M2"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    /******************************************************************
     * COSTANTI MODELLO / ATC
     ******************************************************************/
    const ROOM_ID = "atc-mnist-room";

    const IMG_SIZE = 28;
    const NUM_CHANNELS = 1;
    const NUM_CLASSES = 10;
    const HIDDEN_UNITS = 32;
// Indici dei tensori di pesi nella CNN:
// 0: conv1/kernel, 1: conv1/bias, 2: conv2/kernel, 3: conv2/bias,
// 4: dense_hidden/kernel, 5: dense_hidden/bias,
// 6: dense_out/kernel, 7: dense_out/bias
const IDX_DH_KERNEL = 4;
const IDX_DH_BIAS   = 5;
const IDX_DO_KERNEL = 6;

    const TRAIN_BATCH_SIZE = 16;
    const VAL_BATCH_SIZE   = 32;
    const TRAINING_PAUSE_MS = 800;

    const MAX_TRAIN_ITEMS = 12000;
    const MAX_VAL_ITEMS   = 2000;

    const MNIST_ROOT      = "https://raw.githubusercontent.com/rasbt/mnist-pngs/main/";
    const MNIST_TRAIN_CSV = MNIST_ROOT + "train.csv";
    const MNIST_TEST_CSV  = MNIST_ROOT + "test.csv";

    const META_STORAGE_KEY = "atc-mnist-meta-v2";

    // ATC: parametri per la parte Combine
    const VAR_BETA = 0.1;              // smoothing per stima varianza
    const VAR_WARMUP_ITERS = 10;       // prima di usare un nodo nella ARV
    const COMBINE_VAL_EVERY = 10;      // ogni tot passi facciamo una val loss dopo combine
    const OFFLINE_THRESHOLD_MS = 60000;

    /******************************************************************
     * STATO GLOBALE
     ******************************************************************/
    let currentUser = null;
    let clientId = null;

    let model = null;

    let trainManifest = null;
    let valManifest   = null;

    let localSteps   = 0;    // iterazioni ATC
    let localSamples = 0;
    let lastTrainLoss = null;
    let lastValLoss   = null;
    let avgBatchMs = 0;

    let localGradVar = null;      // stima varianza grad / update
    let localGradVarCount = 0;    // quante iterazioni sono state accumulate

    let lastCombineTime        = null;
    let lastCombineNeighbors   = 0;
    let lastCombineNeighborAvg = null;
    let lastCombineValLoss     = null;

    const clientsState = new Map();
    let recentSnapshots = []; // snapshot Ïˆ dei vicini (Firebase)

    let batteryInfo = null;

    let localLossChart  = null;
    let globalLossChart = null;

    let meshNodesLayout = new Map();
    let lastEdgeWeights = new Map(); // neighborId -> a_ij nellâ€™ultimo combine
let hasLocalMeta = false; // true se abbiamo caricato pesi da localStorage o bootstrap

    const devLogBuffer = [];
    const DEV_LOG_MAX  = 200;

    /******************************************************************
     * DEV LOG
     ******************************************************************/
    function devLog(msg) {
      const ts = new Date().toLocaleTimeString();
      const line = `[${ts}] ${msg}`;
      devLogBuffer.unshift(line);
      if (devLogBuffer.length > DEV_LOG_MAX) devLogBuffer.pop();
      const el = document.getElementById("dev-log-body");
      if (el) el.innerHTML = devLogBuffer.join("<br>");
      console.log("[DEV]", msg);
    }

    /******************************************************************
     * UTILITIES
     ******************************************************************/
    function sleep(ms) {
      return new Promise(res => setTimeout(res, ms));
    }
    function clamp(v, min, max) {
      return Math.min(Math.max(v, min), max);
    }
    function formatMs(ms) {
      if (ms == null) return "â€“";
      return ms.toFixed(1) + " ms/batch";
    }
/******************************************************************
 * GOSSIP: Sinkhorn per allineare i neuroni nascosti
 ******************************************************************/

function denseHiddenKernelToNeuronMatrix(flatArray, shape) {
  // shape = [inDim, H], array flatten in ordine (i, h)
  const inDim = shape[0];
  const H = shape[1];
  const mat = [];
  for (let h = 0; h < H; h++) {
    const neuron = [];
    for (let i = 0; i < inDim; i++) {
      const idx = i * H + h;
      neuron.push(flatArray[idx]);
    }
    mat.push(neuron);
  }
  return mat;
}

function euclideanDistanceVec(a, b) {
  let sum = 0;
  for (let i = 0; i < a.length; i++) {
    const d = a[i] - b[i];
    sum += d * d;
  }
  return Math.sqrt(sum);
}

function computeCostMatrix(localMat, neighMat) {
  const H = Math.min(localMat.length, neighMat.length);
  const C = [];
  for (let i = 0; i < H; i++) {
    const row = [];
    for (let j = 0; j < H; j++) {
      row.push(euclideanDistanceVec(localMat[i], neighMat[j]));
    }
    C.push(row);
  }
  return C;
}

// Sinkhorn "forte": poche iterazioni, epsilon piccolo â†’ quasi permutazione
function runSinkhornGossip(costMatrix, epsFactor = 0.1, iterations = 5) {
  const H = costMatrix.length;
  if (!H) return { P: [] };

  let sum = 0, cnt = 0;
  for (let i = 0; i < H; i++) {
    for (let j = 0; j < H; j++) {
      sum += costMatrix[i][j];
      cnt++;
    }
  }
  const meanC = cnt > 0 ? sum / cnt : 1.0;
  const epsilon = Math.max(meanC * epsFactor, 1e-6);

  const P = [];
  for (let i = 0; i < H; i++) {
    const row = [];
    for (let j = 0; j < H; j++) {
      row.push(Math.exp(-costMatrix[i][j] / epsilon));
    }
    P.push(row);
  }

  for (let it = 0; it < iterations; it++) {
    // normalizza righe
    for (let i = 0; i < H; i++) {
      let s = 0;
      for (let j = 0; j < H; j++) s += P[i][j];
      if (s > 0) {
        for (let j = 0; j < H; j++) P[i][j] /= s;
      }
    }
    // normalizza colonne
    for (let j = 0; j < H; j++) {
      let s = 0;
      for (let i = 0; i < H; i++) s += P[i][j];
      if (s > 0) {
        for (let i = 0; i < H; i++) P[i][j] /= s;
      }
    }
  }

  return { P };
}

function argmaxPermutation(P) {
  const H = P.length;
  const perm = new Array(H).fill(0);
  const used = new Array(H).fill(false);
  for (let i = 0; i < H; i++) {
    let bestJ = 0;
    let best = -Infinity;
    for (let j = 0; j < H; j++) {
      if (!used[j] && P[i][j] > best) {
        best = P[i][j];
        bestJ = j;
      }
    }
    perm[i] = bestJ;
    used[bestJ] = true;
  }
  return perm;
}

// Permuta i neuroni nascosti del modello locale secondo perm (dimensione H)
function permuteHiddenInPlace(arrays, shapes, perm) {
  const kernelShape = shapes[IDX_DH_KERNEL]; // [inDim, H]
  const inDim = kernelShape[0];
  const H = kernelShape[1];

  const kernel = arrays[IDX_DH_KERNEL];
  const bias   = arrays[IDX_DH_BIAS];
  const outK   = arrays[IDX_DO_KERNEL];
  const outShape = shapes[IDX_DO_KERNEL]; // [H, numClasses]
  const numClasses = outShape[1];

  const newKernel = new Float32Array(kernel.length);
  const newBias   = new Float32Array(bias.length);
  const newOutK   = new Float32Array(outK.length);

  // dense_hidden kernel: colonne = neuroni
  for (let h = 0; h < H; h++) {
    const srcH = perm[h];
    for (let i = 0; i < inDim; i++) {
      const srcIdx = i * H + srcH;
      const dstIdx = i * H + h;
      newKernel[dstIdx] = kernel[srcIdx];
    }
  }

  // bias hidden
  for (let h = 0; h < H; h++) {
    newBias[h] = bias[perm[h]];
  }

  // dense_out kernel: righe = neuroni
  for (let h = 0; h < H; h++) {
    const srcH = perm[h];
    for (let c = 0; c < numClasses; c++) {
      const srcIdx = srcH * numClasses + c;
      const dstIdx = h * numClasses + c;
      newOutK[dstIdx] = outK[srcIdx];
    }
  }

  arrays[IDX_DH_KERNEL] = newKernel;
  arrays[IDX_DH_BIAS]   = newBias;
  arrays[IDX_DO_KERNEL] = newOutK;
}

    /******************************************************************
     * MNIST PNG: CSV â†’ MANIFESTO
     ******************************************************************/
    async function fetchCsvLines(url, maxLines = null) {
      devLog("Scarico CSV: " + url);
      const resp = await fetch(url);
      if (!resp.ok) throw new Error("Impossibile caricare CSV: " + url);
      const text = await resp.text();
      const all = text.trim().split(/\r?\n/);
      const header = all.shift();
      if (!header.toLowerCase().startsWith("filepath")) {
        console.warn("Header CSV inatteso:", header);
      }
      const lines = maxLines ? all.slice(0, maxLines) : all;
      return lines;
    }

    function parseMnistCsvLines(lines) {
      const items = [];
      for (const line of lines) {
        if (!line) continue;
        const parts = line.split(",");
        if (parts.length < 2) continue;
        const fp  = parts[0].trim();
        const lbl = parseInt(parts[1].trim(), 10);
        if (Number.isNaN(lbl)) continue;
        items.push({ url: MNIST_ROOT + fp, label: lbl });
      }
      return items;
    }

    function balancedSampleByLabel(items, maxTotal) {
      const shuffled = items.slice();
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      const perClass = Math.max(1, Math.floor(maxTotal / NUM_CLASSES));
      const counts = new Array(NUM_CLASSES).fill(0);
      const out = [];
      for (const it of shuffled) {
        if (out.length >= maxTotal) break;
        if (it.label < 0 || it.label >= NUM_CLASSES) continue;
        if (counts[it.label] >= perClass) continue;
        counts[it.label]++;
        out.push(it);
      }
      return out;
    }

    async function loadMnistManifests() {
      const [trainLines, testLines] = await Promise.all([
        fetchCsvLines(MNIST_TRAIN_CSV, null),
        fetchCsvLines(MNIST_TEST_CSV,  null)
      ]);
      const trainAll = parseMnistCsvLines(trainLines);
      const valAll   = parseMnistCsvLines(testLines);

      const trainItems = balancedSampleByLabel(trainAll, MAX_TRAIN_ITEMS);
      const valItems   = balancedSampleByLabel(valAll,   MAX_VAL_ITEMS);

      devLog(`MNIST manifest: train=${trainItems.length}, val=${valItems.length}`);

      return {
        trainManifest: {
          classes: Array.from({length: NUM_CLASSES}, (_,i)=>String(i)),
          items: trainItems
        },
        valManifest: {
          classes: Array.from({length: NUM_CLASSES}, (_,i)=>String(i)),
          items: valItems
        }
      };
    }

    /******************************************************************
     * MODELLO CNN (UNICO PER NODO)
     ******************************************************************/
    function buildModel() {
      const m = tf.sequential();
      m.add(tf.layers.conv2d({
        inputShape: [IMG_SIZE, IMG_SIZE, NUM_CHANNELS],
        filters: 8,
        kernelSize: 3,
        activation: "relu",
        padding: "same",
        name: "conv1"
      }));
      m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
      m.add(tf.layers.conv2d({
        filters: 16,
        kernelSize: 3,
        activation: "relu",
        padding: "same",
        name: "conv2"
      }));
      m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
      m.add(tf.layers.flatten());
      m.add(tf.layers.dense({
        units: HIDDEN_UNITS,
        activation: "relu",
        name: "dense_hidden"
      }));
      m.add(tf.layers.dense({
        units: NUM_CLASSES,
        activation: "softmax",
        name: "dense_out"
      }));
      m.compile({
        optimizer: tf.train.adam(0.001),
        loss: "categoricalCrossentropy",
        metrics: ["accuracy"]
      });
      return m;
    }

    /******************************************************************
     * PESI: ESTRAZIONE, APPLICAZIONE, QUANTIZZAZIONE
     ******************************************************************/
    function extractWeights() {
      const tensors = model.getWeights();
      const shapes  = tensors.map(t => t.shape);
      const arrays  = tensors.map(t => Float32Array.from(t.dataSync()));
      return { shapes, arrays };
    }

    function applyWeightsToModel(shapes, arrays) {
      const tensors = shapes.map((shape, idx) =>
        tf.tensor(arrays[idx], shape, "float32")
      );
      model.setWeights(tensors);
      tensors.forEach(t => t.dispose());
    }

    function quantizeWeights(shapes, arrays) {
      const scales = [];
      const quantMaps = {};
      const shapesMap = {};
      for (let idx = 0; idx < arrays.length; idx++) {
        const arr = arrays[idx];
        shapesMap[idx] = shapes[idx];
        let maxAbs = 0;
        for (let i = 0; i < arr.length; i++) {
          const a = Math.abs(arr[i]);
          if (a > maxAbs) maxAbs = a;
        }
        const scale = maxAbs > 0 ? maxAbs / 127.0 : 1e-8;
        const q = new Int8Array(arr.length);
        for (let i = 0; i < arr.length; i++) {
          q[i] = Math.max(-127, Math.min(127, Math.round(arr[i] / scale)));
        }
        scales.push(scale);
        quantMaps[idx] = Array.from(q);
      }
      return { shapes: shapesMap, scales, quantArrays: quantMaps };
    }

    function dequantizeSnapshot(snapData) {
      const shapesMap = snapData.shapes || {};
      const quantMap  = snapData.quantArrays || {};
      const scales    = snapData.scales || [];
      const indices = Object.keys(quantMap).map(k => Number(k)).sort((a,b)=>a-b);
      const shapes = [];
      const arrays = [];
      for (const idx of indices) {
        const shape = shapesMap[idx];
        const qArr  = quantMap[idx];
        const scale = scales[idx];
        if (!shape || !qArr || scale == null) continue;
        const fArr = new Float32Array(qArr.length);
        for (let i = 0; i < qArr.length; i++) {
          fArr[i] = qArr[i] * scale;
        }
        shapes.push(shape);
        arrays.push(fArr);
      }
      return { shapes, arrays };
    }

    function sanitizeWeightArrays(arrays) {
      let changed = false;
      for (const arr of arrays) {
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i];
          if (!Number.isFinite(v)) {
            arr[i] = 0;
            changed = true;
          }
        }
      }
      if (changed) devLog("Sanitizzazione pesi combinati: NaN/Inf â†’ 0");
    }

    /******************************************************************
     * LOCAL STORAGE
     ******************************************************************/
    async function saveLocalMeta(arraysForSave = null, shapesForSave = null) {
      let weightsPayload = null;
      try {
        const { shapes, arrays } = arraysForSave && shapesForSave
          ? { shapes: shapesForSave, arrays: arraysForSave }
          : extractWeights();
        weightsPayload = {
          shapes,
          arrays: arrays.map(a => Array.from(a))
        };
      } catch (e) {
        console.warn("Errore estrazione pesi per salvataggio:", e);
        devLog("Errore estrazione pesi per salvataggio: " + e.message);
      }
      const meta = {
        weights: weightsPayload,
        localSteps,
        localSamples,
        lastTrainLoss,
        lastValLoss,
        localGradVar,
        localGradVarCount
      };
      try {
        localStorage.setItem(META_STORAGE_KEY, JSON.stringify(meta));
      } catch (e) {
        console.warn("Errore salvataggio meta localStorage:", e);
        devLog("Errore salvataggio meta localStorage: " + e.message);
      }
    }

   async function loadLocalModelOrInit() {
  model = buildModel();
  hasLocalMeta = false;
  try {
    const metaStr = localStorage.getItem(META_STORAGE_KEY);
    if (!metaStr) {
      devLog("Nessun meta locale, modello nuovo.");
      return;
    }
    const meta = JSON.parse(metaStr);
    if (!meta.weights || !meta.weights.shapes || !meta.weights.arrays) {
      devLog("Meta incompleto, uso modello nuovo.");
      return;
    }
    const shapes = meta.weights.shapes;
    const arrays = meta.weights.arrays;
    if (shapes.length !== arrays.length) {
      devLog("Meta pesi incoerente, modello nuovo.");
      return;
    }
    const tensors = shapes.map((shape, idx) =>
      tf.tensor(arrays[idx], shape, "float32")
    );
    model.setWeights(tensors);
    tensors.forEach(t => t.dispose());

    localSteps          = meta.localSteps || 0;
    localSamples        = meta.localSamples || 0;
    lastTrainLoss       = meta.lastTrainLoss ?? null;
    lastValLoss         = meta.lastValLoss ?? null;
    localGradVar        = meta.localGradVar ?? null;
    localGradVarCount   = meta.localGradVarCount || 0;

    hasLocalMeta = true;
    devLog(`Meta locale ripristinato: steps=${localSteps}, samples=${localSamples}, gradVarCount=${localGradVarCount}`);
  } catch (e) {
    console.warn("Errore loadLocalModelOrInit:", e);
    devLog("Errore loadLocalModelOrInit: " + e.message);
  }
}


    /******************************************************************
     * IMAGE â†’ TENSOR
     ******************************************************************/
    async function loadImageAsTensor(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const canvas = document.getElementById("imageLoaderCanvas");
          const ctx = canvas.getContext("2d");
          canvas.width = IMG_SIZE;
          canvas.height = IMG_SIZE;
          ctx.drawImage(img, 0, 0, IMG_SIZE, IMG_SIZE);
          let imgTensor = tf.browser.fromPixels(canvas, NUM_CHANNELS);
          imgTensor = tf.tidy(() => imgTensor.toFloat().div(255.0));
          const batched = imgTensor.expandDims(0);
          imgTensor.dispose();
          resolve(batched);
        };
        img.onerror = (e) => reject(e);
        img.src = url;
      });
    }

    async function loadBatchFromManifest(manifest, batchSize) {
      const items = manifest.items;
      if (!items || !items.length) throw new Error("Manifest vuoto");
      const xsList = [];
      const ysList = [];
      for (let i = 0; i < batchSize; i++) {
        const idx = Math.floor(Math.random() * items.length);
        const item = items[idx];
        const x = await loadImageAsTensor(item.url);
        xsList.push(x);
        ysList.push(item.label);
      }
      const xs = tf.concat(xsList, 0);
      xsList.forEach(t => t.dispose());
      const ysIdx = tf.tensor1d(ysList, "int32");
      const ys = tf.oneHot(ysIdx, NUM_CLASSES);
      ysIdx.dispose();
      return { xs, ys };
    }

    /******************************************************************
     * CHARTS
     ******************************************************************/
    function pushChartPoint(chart, value) {
      if (!chart || value == null || !Number.isFinite(value)) return;
      chart.data.labels.push("");
      chart.data.datasets[0].data.push(value);
      if (chart.data.labels.length > 60) {
        chart.data.labels.shift();
        chart.data.datasets[0].data.shift();
      }
      chart.update("quiet");
    }

    function initCharts() {
      const ctxL = document.getElementById("localLossChart").getContext("2d");
      localLossChart = new Chart(ctxL, {
        type: "line",
        data: { labels: [], datasets: [{ label: "Loss locale", data: [], tension: 0.2 }] },
        options: {
          responsive: true,
          scales: { x: { display: false }, y: { display: true } },
          plugins: { legend: { display: false } }
        }
      });

      const ctxG = document.getElementById("globalLossChart").getContext("2d");
      globalLossChart = new Chart(ctxG, {
        type: "line",
        data: { labels: [], datasets: [{ label: "Val loss dopo combine", data: [], tension: 0.2 }] },
        options: {
          responsive: true,
          scales: { x: { display: false }, y: { display: true } },
          plugins: { legend: { display: false } }
        }
      });
    }

    /******************************************************************
     * UI UPDATE
     ******************************************************************/
    function updateLocalUI() {
  document.getElementById("tf-backend").textContent = tf.getBackend() || "â€“";
  document.getElementById("tf-version").textContent =
    "TF.js " + (tf.version ? tf.version.tfjs : "");

  document.getElementById("local-steps").textContent   = localSteps.toString();
  document.getElementById("local-samples").textContent = `${localSamples} samples`;
  document.getElementById("local-loss").textContent =
    lastTrainLoss != null && Number.isFinite(lastTrainLoss)
      ? lastTrainLoss.toFixed(4)
      : "â€“";
  document.getElementById("local-valloss").textContent =
    lastValLoss != null && Number.isFinite(lastValLoss)
      ? "validation: " + lastValLoss.toFixed(4)
      : "validation: â€“";

  document.getElementById("batch-ms").textContent = formatMs(avgBatchMs);
  const thr = avgBatchMs > 0 ? (TRAIN_BATCH_SIZE / (avgBatchMs / 1000)).toFixed(1) + " img/s" : "â€“";
  document.getElementById("throughput").textContent = thr;

  const gv = localGradVar;
  document.getElementById("grad-var").textContent =
    (gv != null && Number.isFinite(gv)) ? gv.toExponential(2) : "â€“";
  document.getElementById("grad-var-count").textContent =
    `stima ARV (k=${localGradVarCount})`;

  document.getElementById("hidden-size").textContent = HIDDEN_UNITS.toString();

  // ðŸ”§ BLOCCO BATTERIA FIXATO
  if (batteryInfo) {
    const lvl = Math.round(batteryInfo.level * 100);
    const bl = document.getElementById("battery-level");
    const bs = document.getElementById("battery-status");
    if (bl) bl.textContent = lvl + " %";
    if (bs) bs.textContent = batteryInfo.charging ? "in carica" : "su batteria";
  } else {
    const bl = document.getElementById("battery-level");
    const bs = document.getElementById("battery-status");
    if (bl) bl.textContent = "â€“";
    if (bs) bs.textContent = "API batteria non disponibile";
  }
}


    function updateCombineUI() {
      document.getElementById("clients-count").textContent =
        "Nodi: " + clientsState.size.toString();

      if (lastCombineTime) {
        const ageSec = Math.round((Date.now() - lastCombineTime) / 1000);
        document.getElementById("combine-age").textContent = ageSec + " s fa";
      } else {
        document.getElementById("combine-age").textContent = "â€“";
      }

      document.getElementById("combine-neighbors").textContent =
        lastCombineNeighbors > 0
          ? `${lastCombineNeighbors} vicini maturi`
          : "solo self";

      document.getElementById("combine-weight").textContent =
        lastCombineNeighborAvg != null
          ? (lastCombineNeighborAvg * 100).toFixed(1) + " %"
          : "â€“";

      document.getElementById("combine-valloss").textContent =
        lastCombineValLoss != null && Number.isFinite(lastCombineValLoss)
          ? lastCombineValLoss.toFixed(4)
          : "â€“";
    }

    /******************************************************************
     * MESH UI
     ******************************************************************/
    function resizeMeshCanvas() {
      const canvas = document.getElementById("meshCanvas");
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawMesh();
    }
    window.addEventListener("resize", resizeMeshCanvas);

    function drawMesh() {
      const canvas = document.getElementById("meshCanvas");
      const ctx = canvas.getContext("2d");
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      ctx.clearRect(0, 0, width, height);

      const entries = Array.from(clientsState.entries());
      const n = entries.length;
      if (!n) return;

      const cx = width / 2;
      const cy = height / 2;
      const radius = Math.min(width, height) * 0.35;
      meshNodesLayout.clear();

      for (let i = 0; i < n; i++) {
        const [cid, data] = entries[i];
        const angle = 2 * Math.PI * i / n;
        const x = cx + radius * Math.cos(angle);
        const y = cy + radius * Math.sin(angle);
        const stepsNorm = Math.min(1, (data.localSteps || 0) / 500);
        const r = 9 + 7 * stepsNorm;
        meshNodesLayout.set(cid, { x, y, r });
      }

      // Edges: spessore in base ai pesi di combinazione dellâ€™ultimo step di questo nodo
      for (let i = 0; i < n; i++) {
        for (let j = i+1; j < n; j++) {
          const [cid1] = entries[i];
          const [cid2] = entries[j];
          const n1 = meshNodesLayout.get(cid1);
          const n2 = meshNodesLayout.get(cid2);

          let lineWidth = 1;
          let alpha = 0.15;

          if (cid1 === clientId || cid2 === clientId) {
            const neighborId = cid1 === clientId ? cid2 : cid1;
            const w = lastEdgeWeights.get(neighborId) || 0;
            lineWidth = 1 + 4 * w;
            alpha = 0.15 + 0.35 * w;
          }

          ctx.strokeStyle = `rgba(120,150,255,${alpha})`;
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(n1.x, n1.y);
          ctx.lineTo(n2.x, n2.y);
          ctx.stroke();
        }
      }

      // nodi
      for (let i = 0; i < n; i++) {
        const [cid, data] = entries[i];
        const node = meshNodesLayout.get(cid);
        const isSelf = cid === clientId;
        let color = "#4f9cff";
        const vLoss = data.localValLoss;
        if (vLoss != null && Number.isFinite(vLoss)) {
          if (vLoss < 0.4) color = "#57e39f";
          else if (vLoss < 0.9) color = "#ffd166";
          else color = "#ff6b6b";
        }
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.r, 0, 2*Math.PI);
        ctx.fillStyle = isSelf ? "#ffffff" : color;
        ctx.fill();
        ctx.lineWidth = isSelf ? 3 : 1.5;
        ctx.strokeStyle = isSelf ? "#4f9cff" : "#111728";
        ctx.stroke();
      }
    }

    document.getElementById("meshCanvas").addEventListener("click", (evt) => {
      const canvas = document.getElementById("meshCanvas");
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      if (!meshNodesLayout.size) return;
      let bestId = null;
      let bestD2 = Infinity;
      for (const [cid, node] of meshNodesLayout.entries()) {
        const dx = x - node.x;
        const dy = y - node.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2) {
          bestD2 = d2;
          bestId = cid;
        }
      }
      if (!bestId) return;
      const node = meshNodesLayout.get(bestId);
      const maxD2 = node.r * node.r * 4;
      if (bestD2 > maxD2 && meshNodesLayout.size > 1) return;
      showNodeDetails(bestId);
    });

    function showNodeDetails(cid) {
      const d = clientsState.get(cid);
      const body = document.getElementById("node-details-body");
      if (!d) {
        body.textContent = "Nessun dato per questo nodo.";
        return;
      }
      const isSelf = cid === clientId;
      const lines = [];
      lines.push(`<div><strong>${isSelf ? "Questo nodo" : "Nodo remoto"}</strong></div>`);
      lines.push(`<div style="word-break:break-all;font-size:0.7rem;">ID: ${cid}</div>`);
      lines.push(`<div>Steps: ${d.localSteps ?? 0}</div>`);
      lines.push(`<div>Samples: ${d.localSamples ?? 0}</div>`);
      lines.push(`<div>Val loss: ${
        d.localValLoss != null && Number.isFinite(d.localValLoss)
          ? d.localValLoss.toFixed(4)
          : "â€“"
      }</div>`);
      if (d.gradVar != null && Number.isFinite(d.gradVar)) {
        lines.push(`<div>Var grad stimata: ${d.gradVar.toExponential(2)}</div>`);
        lines.push(`<div>k var: ${d.gradVarCount ?? 0}</div>`);
      }
      const edgeW = lastEdgeWeights.get(cid);
      if (edgeW != null) {
        lines.push(
          `<div>Peso ATC locale: ${(edgeW * 100).toFixed(1)} %</div>`
        );
      }
      lines.push(`<div>Ultimo visto: ${
        d.lastSeen ? new Date(d.lastSeen).toLocaleTimeString() : "â€“"
      }</div>`);
      body.innerHTML = lines.join("");
    }

    /******************************************************************
     * BATTERIA
     ******************************************************************/
    function initBattery() {
      if ("getBattery" in navigator) {
        navigator.getBattery().then(b => {
            batteryInfo = b;
          b.addEventListener("levelchange", updateLocalUI);
          b.addEventListener("chargingchange", updateLocalUI);
          updateLocalUI();
        }).catch(()=>{});
      }
    }

    /******************************************************************
     * TESTER: FILE + SAMPLE GALLERY (USA model LOCALE)
     ******************************************************************/
    function probsContainNonFinite(arr) {
      for (let i = 0; i < arr.length; i++) {
        if (!Number.isFinite(arr[i])) return true;
      }
      return false;
    }

    async function predictOne(x) {
      const y = model.predict(x);
      const probs = await y.data();
      y.dispose();
      if (probsContainNonFinite(probs)) return null;
      let best = 0;
      for (let i = 1; i < probs.length; i++) {
        if (probs[i] > probs[best]) best = i;
      }
      return {
        probs: Array.from(probs),
        predIdx: best
      };
    }

    function formatSoftmaxLine(pred, classes) {
      if (!pred) return "NaN / modello instabile";
      const probsStr = pred.probs
        .map((p, i) => `${classes[i] ?? i}:${p.toFixed(3)}`)
        .join(", ");
      return `[${probsStr}] â†’ pred: ${classes[pred.predIdx] ?? pred.predIdx}`;
    }

    function initTesterUI() {
      const input = document.getElementById("test-image-input");
      const btn = document.getElementById("test-btn");
      btn.addEventListener("click", async () => {
        const file = input.files && input.files[0];
        if (!file || !model) return;
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = async () => {
            const canvas = document.getElementById("imageLoaderCanvas");
            const ctx = canvas.getContext("2d");
            canvas.width = IMG_SIZE;
            canvas.height = IMG_SIZE;
            ctx.drawImage(img, 0, 0, IMG_SIZE, IMG_SIZE);
            let imgTensor = tf.browser.fromPixels(canvas, NUM_CHANNELS);
            imgTensor = tf.tidy(() => imgTensor.toFloat().div(255.0));
            const x = imgTensor.expandDims(0);
            imgTensor.dispose();

            const pred = await predictOne(x);
            x.dispose();

            const classes = trainManifest?.classes || [];
            const resultEl = document.getElementById("tester-result");
            resultEl.textContent =
              `File caricato\n` + formatSoftmaxLine(pred, classes);
            devLog("Test file: predIdx=" + (pred?.predIdx ?? "n/d"));
          };
          img.onerror = () => {
            document.getElementById("tester-result").textContent =
              "Errore caricamento immagine.";
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      });
    }

    function populateSampleGallery() {
      const container = document.getElementById("sample-images-container");
      if (!container || !valManifest || !valManifest.items || !valManifest.items.length) return;
      container.innerHTML = "";
      const items = valManifest.items;
      const numSamples = Math.min(12, items.length);
      const used = new Set();
      while (used.size < numSamples) {
        const idx = Math.floor(Math.random() * items.length);
        used.add(idx);
      }
      for (const idx of used) {
        const item = items[idx];
        const imgEl = document.createElement("img");
        imgEl.src = item.url;
        imgEl.className = "sample-thumb";
        imgEl.title = "Label reale: " + item.label;
        imgEl.dataset.label = item.label;
        imgEl.dataset.url = item.url;
        imgEl.addEventListener("click", async () => {
          document.querySelectorAll(".sample-thumb.selected")
            .forEach(el => el.classList.remove("selected"));
          imgEl.classList.add("selected");
          try {
            const x = await loadImageAsTensor(item.url);
            const pred = await predictOne(x);
            x.dispose();
            const classes = trainManifest?.classes || [];
            const trueLabel = classes[item.label] ?? String(item.label);
            const resultEl = document.getElementById("tester-result");
            resultEl.textContent =
              `Sample dal dataset (label reale: ${trueLabel})\n` +
              formatSoftmaxLine(pred, classes);
            devLog(
              `Pred sample (true=${trueLabel}): predIdx=${pred?.predIdx ?? "n/d"}`
            );
          } catch (e) {
            console.error("Errore pred sample:", e);
            devLog("Errore pred sample: " + e.message);
          }
        });
        container.appendChild(imgEl);
      }
    }

    /******************************************************************
     * PANIC BUTTON
     ******************************************************************/
    async function localPanicReset() {
      if (!confirm("Reset locale: azzera il modello e le statistiche su questo dispositivo. Procedere?")) {
        return;
      }
      devLog("Panic reset richiesto.");
      try {
        localStorage.removeItem(META_STORAGE_KEY);
      } catch {}
      if (model) model.dispose();
      model = buildModel();
      localSteps = 0;
      localSamples = 0;
      lastTrainLoss = null;
      lastValLoss   = null;
      localGradVar  = null;
      localGradVarCount = 0;
      avgBatchMs = 0;
      await saveLocalMeta();
      updateLocalUI();
      document.getElementById("tester-result").textContent =
        "Modello locale resettato. Il training riparte da zero.";
    }

    /******************************************************************
     * FIREBASE SUBSCRIPTIONS
     ******************************************************************/
    function subscribeClientsAndSnapshots(db, roomId) {
      const clientsRef = collection(db, "rooms", roomId, "clients");
      const snapsRef   = collection(db, "rooms", roomId, "snapshots");

      onSnapshot(clientsRef, (snap) => {
        clientsState.clear();
        const now = Date.now();
        snap.forEach(docSnap => {
          const d = docSnap.data();
          let lastSeen = d.lastSeen && d.lastSeen.toMillis ? d.lastSeen.toMillis() : null;
          const offline = lastSeen && (now - lastSeen > OFFLINE_THRESHOLD_MS);
          if (offline) return;
          clientsState.set(docSnap.id, {
            localSteps: d.localSteps ?? 0,
            localSamples: d.localSamples ?? 0,
            localValLoss: d.localValLoss ?? null,
            gradVar: d.gradVar ?? null,
            gradVarCount: d.gradVarCount ?? 0,
            lastSeen
          });
        });
        updateCombineUI();
        drawMesh();
      });

      const qSnaps = query(snapsRef, orderBy("createdAt", "desc"), limit(20));
      onSnapshot(qSnaps, (snap) => {
        const docs = [];
        snap.forEach(docSnap => {
          docs.push({
            id: docSnap.id,
            data: docSnap.data(),
            localTimestamp: Date.now()
          });
        });
        recentSnapshots = docs;
      });

      return { clientsRef, snapsRef };
    }
async function bootstrapFromBestPeerIfAny(snapsRef) {
  try {
    const qBoot = query(snapsRef, orderBy("createdAt", "desc"), limit(50));
    const snap = await getDocs(qBoot);
    if (snap.empty) {
      devLog("Bootstrap: nessun snapshot remoto disponibile.");
      return;
    }

    let bestData = null;
    let bestScore = -Infinity;

    snap.forEach(docSnap => {
      const d = docSnap.data();
      if (!d || !d.clientId || d.clientId === clientId) return;

      const valLoss = d.localValLoss;
      const steps   = d.iter || d.localSteps || 0;

      if (valLoss == null || !Number.isFinite(valLoss)) return;

      // score alto = bassa loss, molti step
      const score = -valLoss + 1e-4 * steps;
      if (score > bestScore) {
        bestScore = score;
        bestData = d;
      }
    });

    if (!bestData) {
      devLog("Bootstrap: nessun candidato valido trovato.");
      return;
    }

    const { shapes, arrays } = dequantizeSnapshot(bestData);
    applyWeightsToModel(shapes, arrays);

    // Copiamo anche la stima di varianza se presente
    if (bestData.gradVar != null && Number.isFinite(bestData.gradVar)) {
      localGradVar = bestData.gradVar;
    }
    if (bestData.gradVarCount != null) {
      localGradVarCount = bestData.gradVarCount;
    }

    await saveLocalMeta();
    hasLocalMeta = true;

    let lossStr = "n/d";
    if (typeof bestData.localValLoss === "number" && Number.isFinite(bestData.localValLoss)) {
      lossStr = bestData.localValLoss.toFixed(4);
    }
    devLog(`Bootstrap: modello copiato da client ${bestData.clientId}, valLoss=${lossStr}`);
  } catch (e) {
    console.error("Errore bootstrapFromBestPeerIfAny:", e);
    devLog("Errore bootstrapFromBestPeerIfAny: " + e.message);
  }
}

    /******************************************************************
     * ATC TRAINING LOOP (Adapt + Combine nello stesso ciclo)
     ******************************************************************/
    async function trainingLoop(clientRef, snapshotsColRef) {
      devLog("Training loop ATC avviato.");
      let combineValCounter = 0;

      while (true) {
        let xs=null, ys=null;
        const t0 = performance.now();
        try {
          // --- ADAPT STEP: Ïˆ_i = w_i - Î¼ âˆ‡J_i(w_i) ---
          const { shapes, arrays: arraysBefore } = extractWeights();
          const batch = await loadBatchFromManifest(trainManifest, TRAIN_BATCH_SIZE);
          xs = batch.xs;
          ys = batch.ys;

          const history = await model.fit(xs, ys, {
            epochs: 1,
            batchSize: TRAIN_BATCH_SIZE,
            shuffle: true,
            verbose: 0
          });
          const t1 = performance.now();

          xs.dispose();
          ys.dispose();
          xs = null; ys = null;

          const loss = history.history.loss[0];
          if (!Number.isFinite(loss)) {
            devLog("Loss NaN/Inf. Resetto modello locale.");
            model.dispose();
            model = buildModel();
            localSteps = 0;
            localSamples = 0;
            lastTrainLoss = null;
            lastValLoss   = null;
            localGradVar  = null;
            localGradVarCount = 0;
            await saveLocalMeta();
            updateLocalUI();
            await sleep(TRAINING_PAUSE_MS);
            continue;
          }

          localSteps   += 1;
          localSamples += TRAIN_BATCH_SIZE;
          lastTrainLoss = loss;

          const { arrays: arraysAfter } = extractWeights(); // Ïˆ_i

          // Stima varianza update (surrogato grad noise)
          let sumSq = 0;
          let count = 0;
          for (let t = 0; t < arraysBefore.length; t++) {
            const a0 = arraysBefore[t];
            const a1 = arraysAfter[t];
            for (let i = 0; i < a0.length; i++) {
              const d = a1[i] - a0[i];
              sumSq += d*d;
              count++;
            }
          }
          const stepVar = sumSq / Math.max(1, count);
          if (!Number.isFinite(stepVar) || stepVar <= 0) {
            // fallback
            if (localGradVar == null) localGradVar = 1e-4;
          } else {
            if (localGradVar == null) localGradVar = stepVar;
            else localGradVar = (1 - VAR_BETA) * localGradVar + VAR_BETA * stepVar;
          }
          localGradVarCount++;

          const batchMs = t1 - t0;
          if (avgBatchMs === 0) avgBatchMs = batchMs;
          else avgBatchMs = avgBatchMs*0.9 + batchMs*0.1;

          pushChartPoint(localLossChart, loss);
          devLog(`Adapt k=${localSteps}, loss=${loss.toFixed(4)}, stepVar=${stepVar.toExponential(2)}, gradVar=${localGradVar != null ? localGradVar.toExponential(2) : "n/d"}`);

          // Pubblica Ïˆ_i come snapshot per i vicini
          const q = quantizeWeights(shapes, arraysAfter);
          const snapshotDoc = {
            clientId,
            createdAt: serverTimestamp(),
            iter: localSteps,
            localSamples,
            localTrainLoss: lastTrainLoss,
            localValLoss: lastValLoss,
            gradVar: localGradVar,
            gradVarCount: localGradVarCount,
            shapes: q.shapes,
            scales: q.scales,
            quantArrays: q.quantArrays
          };
          await addDoc(snapshotsColRef, snapshotDoc);

          // Aggiorna stato client (per la mesh)
          await setDoc(clientRef, {
            lastSeen: serverTimestamp(),
            localSteps,
            localSamples,
            localValLoss: lastValLoss,
            gradVar: localGradVar,
            gradVarCount: localGradVarCount
          }, { merge: true });

          // --- COMBINE STEP: w_i = Î£ a_ij Ïˆ_j ---
          const now = Date.now();
          const byClient = new Map();
          for (const snap of recentSnapshots) {
            const d = snap.data;
            if (!d.clientId) continue;
            const cid = d.clientId;
            if (cid === clientId) continue; // self gestito separatamente
            const ts = d.createdAt && d.createdAt.toMillis
              ? d.createdAt.toMillis()
              : snap.localTimestamp || now;
            const prev = byClient.get(cid);
            if (!prev || ts > prev.ts) {
              byClient.set(cid, { snap, ts });
            }
          }

          const neighborsInfo = [];
for (const [cid, {snap}] of byClient.entries()) {
  const d = snap.data;
  const { shapes: neighShapes, arrays: neighArrays } = dequantizeSnapshot(d);
  if (JSON.stringify(neighShapes) !== JSON.stringify(shapes)) {
    continue; // architettura diversa
  }
  const gVar   = d.gradVar;
  const gCount = d.gradVarCount || 0;
  const valLoss = d.localValLoss;
  neighborsInfo.push({
    clientId: cid,
    arrays: neighArrays,
    gradVar: gVar,
    gradVarCount: gCount,
    valLoss
  });
}


          // ARV: costruiamo lâ€™insieme S di nodi maturi (self sempre incluso)
                    const S = [];
          const EPS_GVAR = 1e-12;

          // Self: se non abbiamo ancora una varianza sensata, usiamo un valore default
          const selfGamma = (localGradVar != null && Number.isFinite(localGradVar) && localGradVar > 0)
            ? localGradVar
            : 1e-4;
          S.push({
            clientId: clientId,
            arrays: arraysAfter,
            gamma: selfGamma,
            isSelf: true
          });

          // Vicini: NESSUN warmup a 10 step, li includiamo subito.
          for (const n of neighborsInfo) {
            let gVar = n.gradVar;
            if (gVar == null || !Number.isFinite(gVar) || gVar <= 0) {
              // se il vicino non ha ancora una varianza stimata, usiamo un fallback
              gVar = selfGamma;
            }
            S.push({
              clientId: n.clientId,
              arrays: n.arrays,
              gamma: gVar,
              isSelf: false
            });
          }


          // Se solo self o nessun gamma decente â†’ w_i = Ïˆ_i (no combine effettivo)
          let combinedArrays = arraysAfter.map(a => a.slice());
          lastEdgeWeights.clear();
          let neighborWeightSum = 0;

          if (S.length > 1) {
            // ARV: r_j = 1 / (eps + gamma_j), a_j = r_j / Î£ r
            let anyValidGamma = false;
            for (const s of S) {
              if (s.gamma > 0) { anyValidGamma = true; break; }
            }
            let weights = new Map();
            if (!anyValidGamma) {
              // averaging rule uniforme
              const w = 1 / S.length;
              S.forEach(s => weights.set(s.clientId, w));
            } else {
              let sumR = 0;
              for (const s of S) {
                const rj = 1 / (EPS_GVAR + s.gamma);
                sumR += rj;
                weights.set(s.clientId, rj);
              }
              for (const [cid, rj] of weights.entries()) {
                weights.set(cid, rj / sumR);
              }
            }

            // combine w_i = Î£_j a_j Ïˆ_j (Ïˆ_j = arrays di S[j])
            combinedArrays = arraysAfter.map(() => null);
            for (let t = 0; t < arraysAfter.length; t++) {
              const len = arraysAfter[t].length;
              combinedArrays[t] = new Float32Array(len);
            }

            for (const s of S) {
              const wj = weights.get(s.clientId);
              if (wj == null) continue;
              for (let t = 0; t < combinedArrays.length; t++) {
                const out = combinedArrays[t];
                const src = s.arrays[t];
                for (let i = 0; i < out.length; i++) {
                  out[i] += wj * src[i];
                }
              }
              if (!s.isSelf) {
                lastEdgeWeights.set(s.clientId, wj);
                neighborWeightSum += wj;
              }
            }

            devLog(
              `Combine k=${localSteps}: nodi S=${S.length}, peso vicini=${neighborWeightSum.toFixed(3)}`
            );
          } else {
            devLog(`Combine k=${localSteps}: solo self (nessun vicino maturo).`);
          }

          sanitizeWeightArrays(combinedArrays);
          applyWeightsToModel(shapes, combinedArrays);
          await saveLocalMeta(combinedArrays, shapes);
// GOSSIP: ogni 5 iterazioni, se ci sono vicini, controlla divergenza
if (neighborsInfo.length > 0 && (localSteps % 5 === 0)) {
  try {
    await gossipAlignIfDivergent(shapes, combinedArrays, neighborsInfo);
  } catch (e) {
    console.error("Errore gossipAlignIfDivergent:", e);
    devLog("Errore gossipAlignIfDivergent: " + e.message);
  }
}

lastCombineTime        = Date.now();
lastCombineNeighbors   = S.length - 1;
lastCombineNeighborAvg = neighborWeightSum;
          
          // ogni COMBINE_VAL_EVERY iter facciamo una val loss post-combine
          combineValCounter++;
          if (valManifest && valManifest.items && valManifest.items.length &&
              combineValCounter % COMBINE_VAL_EVERY === 0) {
            const vb = await loadBatchFromManifest(valManifest, VAL_BATCH_SIZE);
            const evalRes = await model.evaluate(vb.xs, vb.ys, {
              batchSize: VAL_BATCH_SIZE,
              verbose: 0
            });
            let lossT;
            if (Array.isArray(evalRes)) lossT = evalRes[0];
            else lossT = evalRes;
            const arr = await lossT.data();
            const vLoss = arr[0];
            lossT.dispose();
            vb.xs.dispose();
            vb.ys.dispose();
            if (Number.isFinite(vLoss)) {
              lastCombineValLoss = vLoss;
              pushChartPoint(globalLossChart, vLoss);
              devLog(`Val loss post-combine=${vLoss.toFixed(4)}`);
            }
          }

          updateLocalUI();
          updateCombineUI();
          drawMesh();
          await sleep(TRAINING_PAUSE_MS);
        } catch (e) {
          if (xs) xs.dispose();
          if (ys) ys.dispose();
          console.error("Errore trainingLoop ATC:", e);
          devLog("Errore trainingLoop ATC: " + e.message);
          await sleep(TRAINING_PAUSE_MS);
        }
      }
    }
/******************************************************************
 * GOSSIP STEP:
 * se il nodo diverge molto da un vicino "buono", usa Sinkhorn
 * per riallineare i neuroni nascosti (permutazione).
 ******************************************************************/
async function gossipAlignIfDivergent(shapes, localArrays, neighborsInfo) {
  if (!neighborsInfo.length) return;

  // selezioniamo un vicino "buono":
  // - valLoss simile alla nostra
  // - distanza nei pesi relativamente grande â†’ sospetta permutazione
  const selfVal = lastValLoss;
  let best = null;
  let bestScore = -Infinity;

  // Precalcolo norma dei pesi locali
  let normSelfSq = 0;
  for (let t = 0; t < localArrays.length; t++) {
    const arr = localArrays[t];
    for (let i = 0; i < arr.length; i++) {
      normSelfSq += arr[i] * arr[i];
    }
  }
  const normSelf = Math.sqrt(normSelfSq + 1e-12);

  for (const n of neighborsInfo) {
    const neighArr = n.arrays;
    // norma del vicino
    let normNeighSq = 0;
    for (let t = 0; t < neighArr.length; t++) {
      const arr = neighArr[t];
      for (let i = 0; i < arr.length; i++) {
        normNeighSq += arr[i] * arr[i];
      }
    }
    const normNeigh = Math.sqrt(normNeighSq + 1e-12);

    // distanza L2 normalizzata tra i vettori di pesi
    let distSq = 0;
    for (let t = 0; t < localArrays.length; t++) {
      const a = localArrays[t];
      const b = neighArr[t];
      if (a.length !== b.length) continue;
      for (let i = 0; i < a.length; i++) {
        const d = a[i] - b[i];
        distSq += d * d;
      }
    }
    const dist = Math.sqrt(distSq + 1e-12);
    const normDist = dist / (normSelf + normNeigh);

    // differenza di valLoss (se entrambe finite)
    let valDiff = null;
    if (selfVal != null && n.valLoss != null &&
        Number.isFinite(selfVal) && Number.isFinite(n.valLoss)) {
      valDiff = Math.abs(selfVal - n.valLoss);
    }

    // Heuristica:
    // - vogliamo divergenza abbastanza grande
    // - e prestazioni simili (valDiff piccola) â†’ probabile permutazione
    const DIVERGENCE_THRESHOLD = 0.4; // tuning
    const VAL_DIFF_MAX = 0.15;

    const diverging = normDist > DIVERGENCE_THRESHOLD;
    const similarPerf = (valDiff == null) ? true : (valDiff < VAL_DIFF_MAX);

    if (diverging && similarPerf) {
      // score = divergenza / (1 + valDiff) / gamma ~ preferiamo vicini stabili
      const gamma = (n.gradVar != null && Number.isFinite(n.gradVar) && n.gradVar > 0)
        ? n.gradVar
        : 1e-4;
      const score = normDist / (1 + (valDiff || 0.0)) / (1e-8 + gamma);
      if (score > bestScore) {
        bestScore = score;
        best = { neighbor: n, normDist, valDiff };
      }
    }
  }

  if (!best) {
    // nessun vicino che suggerisca permutazione
    return;
  }

  const n = best.neighbor;
  devLog(
    `[GOSSIP] Divergenza rilevata con ${n.clientId}: dist=${best.normDist.toFixed(3)}, ` +
    `valDiff=${best.valDiff != null ? best.valDiff.toFixed(3) : "n/d"} â†’ eseguo Sinkhorn (gossip)`
  );

  // Costruiamo la matrice di costi sui neuroni nascosti e ricaviamo una permutazione
  const kernelShape = shapes[IDX_DH_KERNEL];
  const localKernel  = localArrays[IDX_DH_KERNEL];
  const neighKernel  = n.arrays[IDX_DH_KERNEL];

  const localMat = denseHiddenKernelToNeuronMatrix(localKernel, kernelShape);
  const neighMat = denseHiddenKernelToNeuronMatrix(neighKernel, kernelShape);

  const H = Math.min(localMat.length, neighMat.length);
  if (!H) return;

  const C = computeCostMatrix(localMat.slice(0, H), neighMat.slice(0, H));
  const { P } = runSinkhornGossip(C, 0.1, 5); // pochi step, epsilon piccolo
  const perm = argmaxPermutation(P);

  // Applichiamo la permutazione ai pesi del modello locale
  permuteHiddenInPlace(localArrays, shapes, perm);

  // Aggiorniamo il modello con i nuovi pesi riallineati
  sanitizeWeightArrays(localArrays);
  applyWeightsToModel(shapes, localArrays);
  await saveLocalMeta(localArrays, shapes);

  devLog(
    `[GOSSIP] Allineamento completato con ${n.clientId}: ` +
    `perm[0..4]=${perm.slice(0, Math.min(5, perm.length)).join(",")}`
  );
}

    /******************************************************************
     * ENTRYPOINT
     ******************************************************************/
    async function start() {
      devLog("Start app.");
      initCharts();
      initTesterUI();
      initBattery();
      resizeMeshCanvas();
      updateLocalUI();
      updateCombineUI();

      const { trainManifest: tm, valManifest: vm } = await loadMnistManifests();
      trainManifest = tm;
      valManifest   = vm;
      populateSampleGallery();

      try {
        await signInAnonymously(auth);
        devLog("Login anonimo Firebase OK.");
      } catch (e) {
        console.error("Errore signInAnonymously:", e);
        devLog("Errore signInAnonymously: " + e.message);
        return;
      }

      onAuthStateChanged(auth, async (user) => {
        if (!user) return;
        currentUser = user;
        clientId = user.uid;
        document.getElementById("client-pill").textContent =
          "Client: " + clientId.slice(0, 6) + "â€¦";
        devLog("Auth: clientId=" + clientId);

        await loadLocalModelOrInit();
        document.getElementById("model-pill").textContent = "Modello: pronto";
        document.getElementById("test-btn").disabled = false;
        updateLocalUI();

        const roomRef = doc(db, "rooms", ROOM_ID);
        await setDoc(roomRef, {
          name: "ATC MNIST Demo",
          createdAt: serverTimestamp()
        }, { merge: true });

        const clientRef = doc(db, "rooms", ROOM_ID, "clients", clientId);
        await setDoc(clientRef, {
          lastSeen: serverTimestamp(),
          localSteps,
          localSamples,
          localValLoss: lastValLoss,
          gradVar: localGradVar,
          gradVarCount: localGradVarCount
        }, { merge: true });

        setInterval(() => {
          if (!clientId) return;
          setDoc(clientRef, { lastSeen: serverTimestamp() }, { merge: true });
        }, 30000);

        const { snapsRef } = subscribeClientsAndSnapshots(db, ROOM_ID);

// Se Ã¨ un nodo nuovo (nessun meta locale), prova a clonare il migliore
if (!hasLocalMeta) {
  await bootstrapFromBestPeerIfAny(snapsRef);
  updateLocalUI();
}

trainingLoop(clientRef, snapsRef);

      });

      document.getElementById("panic-btn").addEventListener("click", () => {
        localPanicReset().catch(e => console.error("Errore panic:", e));
      });
    }

    start().catch(e => {
      console.error("Errore start():", e);
      devLog("Errore start(): " + e.message);
    });
  </script>
</body>
</html>
