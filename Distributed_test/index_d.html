<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>ATC Diffusion MNIST Demo (Sayed-style)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #050814;
      color: #f0f4ff;
      --card-bg: #151a2c;
      --accent: #4f9cff;
      --accent-soft: rgba(79, 156, 255, 0.15);
    }
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      padding: 0.8rem 1rem;
      border-bottom: 1px solid #20263a;
    }
    header h1 {
      margin: 0;
      font-size: 1.1rem;
    }
    header p {
      margin: 0.2rem 0 0;
      font-size: 0.75rem;
      color: #9ca4c7;
    }
    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      grid-template-rows: auto auto 1fr;
      gap: 0.8rem;
      padding: 0.8rem;
      box-sizing: border-box;
    }
    section {
      background: var(--card-bg);
      border-radius: 0.75rem;
      padding: 0.7rem 0.9rem;
      box-shadow: 0 0 0 1px #1f2840;
      min-width: 0;
    }
    section h2 {
      margin: 0 0 0.4rem;
      font-size: 0.95rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .pill {
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: var(--accent-soft);
      color: #4f9cff;
    }
    .ghost-btn {
      background: transparent;
      border: 1px solid #ff6b6b;
      color: #ff6b6b;
      border-radius: 999px;
      padding: 0.15rem 0.6rem;
      font-size: 0.7rem;
      cursor: pointer;
      margin-right: 0.4rem;
    }
    .ghost-btn:hover {
      background: rgba(255,107,107,0.15);
    }
    #local-section { grid-column: 1 / 2; grid-row: 1 / 2; }
    #combine-section { grid-column: 2 / 3; grid-row: 1 / 2; }
    #mesh-section { grid-column: 1 / 2; grid-row: 2 / 4; }
    #tester-section { grid-column: 2 / 3; grid-row: 2 / 4; }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.4rem;
      margin-bottom: 0.6rem;
    }
    .stat {
      background: #1a2136;
      border-radius: 0.6rem;
      padding: 0.35rem 0.45rem;
      font-size: 0.8rem;
    }
    .stat .label { color: #9ca4c7; font-size: 0.7rem; }
    .stat .value { font-weight: 600; margin-top: 0.1rem; }
    .stat .sub { font-size: 0.7rem; color: #8891b3; margin-top: 0.1rem; }

    canvas.loss-chart {
      width: 100%;
      height: 120px;
    }

    #meshCanvas {
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #1b2340, #050814);
      border-radius: 0.6rem;
      border: 1px solid #222a42;
      box-sizing: border-box;
      cursor: pointer;
    }
    #node-details {
      font-size: 0.8rem;
      background: #101628;
      border-radius: 0.5rem;
      padding: 0.45rem;
      margin-top: 0.4rem;
    }

    #tester-section input[type="file"] {
      font-size: 0.8rem;
      margin-bottom: 0.4rem;
    }
    #tester-section button {
      background: var(--accent);
      border: none;
      border-radius: 0.5rem;
      padding: 0.35rem 0.7rem;
      color: #0b1020;
      font-size: 0.8rem;
      cursor: pointer;
    }
    #tester-section button:disabled { opacity: 0.6; cursor: default; }
    #tester-result {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      white-space: pre-line;
    }
    .sample-thumb {
      width: 40px;
      height: 40px;
      border-radius: 0.3rem;
      border: 1px solid #303857;
      cursor: pointer;
      image-rendering: pixelated;
      background: #000;
      object-fit: cover;
    }
    .sample-thumb.selected {
      border-color: #4f9cff;
      box-shadow: 0 0 0 2px rgba(79,156,255,0.5);
    }

    #dev-log {
      margin-top: 0.4rem;
      max-height: 160px;
      overflow: auto;
      font-size: 0.7rem;
      background: #101628;
      border-radius: 0.5rem;
      padding: 0.4rem;
      border: 1px solid #232b45;
    }

    footer {
      padding: 0.5rem 0.8rem;
      font-size: 0.7rem;
      color: #7b84a7;
      border-top: 1px solid #20263a;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto auto;
      }
      #local-section, #combine-section, #mesh-section, #tester-section {
        grid-column: 1 / 2;
        grid-row: auto;
      }
      #meshCanvas { height: 260px; }
    }

    /* --- VISUALIZZATORE NN LIVE --- */
    #nn-live-wrapper {
      margin-top: 0.8rem;
    }
    .nn-layout {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: flex-start;
    }
    .nn-left {
      flex: 0 0 260px;
      max-width: 100%;
    }
    .nn-right {
      flex: 1 1 260px;
      min-width: 0;
    }
    #drawCanvas {
      width: 100%;
      max-width: 260px;
      height: auto;
      border-radius: 0.6rem;
      border: 1px solid #303857;
      background: #000;
      touch-action: none;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
      display: block;
    }
    .nn-controls {
      margin-top: 0.4rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
    }

    button.secondary {
      background: #1f2937;
      border: 1px solid #374151;
      color: #e5e7eb;
      border-radius: 0.5rem;
      padding: 0.25rem 0.7rem;
      font-size: 0.75rem;
      cursor: pointer;
    }
    button.secondary:hover {
      background: #111827;
    }

    .nn-label-row {
      margin-top: 0.4rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
      font-size: 0.75rem;
    }
    .nn-label-row input {
      width: 3rem;
      margin-left: 0.25rem;
      padding: 0.1rem 0.2rem;
      border-radius: 0.3rem;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
    }
    .nn-label-status {
      font-size: 0.7rem;
      color: #9ca4c7;
    }

    #pixelGridCanvas {
      width: 100%;
      max-width: 260px;
      height: auto;
      margin-top: 0.45rem;
      border-radius: 0.6rem;
      border: 1px solid #303857;
      background: #000;
      image-rendering: pixelated;
      display: block;
    }
    #nnCanvas {
      width: 100%;
      height: 260px;
      border-radius: 0.6rem;
      border: 1px solid #222a42;
      background: radial-gradient(circle at top left, #1b2340, #050814);
      box-sizing: border-box;
      display: block;
    }
    #draw-output-panel {
      margin-top: 0.4rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
      background: #0b1020;
      border-radius: 0.5rem;
      border: 1px solid #232b45;
      padding: 0.4rem 0.6rem;
      max-height: 160px;
      overflow-y: auto;
    }
    .prob-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.15rem;
    }
    .prob-label {
      width: 1.3rem;
      text-align: right;
      color: #9ca4c7;
      font-size: 0.75rem;
    }
    .prob-bar-wrap {
      flex: 1;
      background: #050b18;
      border-radius: 999px;
      overflow: hidden;
      height: 0.5rem;
      position: relative;
    }
    .prob-bar {
      height: 100%;
      background: linear-gradient(90deg, #22c55e, #22d3ee);
      border-radius: 999px;
    }
    .prob-val {
      width: 3.2rem;
      text-align: right;
      color: #e5e7eb;
      font-size: 0.75rem;
    }
    .prob-row.best .prob-label {
      color: #fbbf24;
      font-weight: 600;
    }
    .prob-row.best .prob-val {
      color: #fbbf24;
    }
  </style>
</head>
<body>
  <header>
    <h1>ATC Diffusion MNIST Demo</h1>
    <p>
      Implementazione semplificata di <strong>Adapt–Then–Combine (Sayed)</strong> su MNIST PNG.
      Ogni nodo fa <em>ψ-update</em> locale e poi combina con i vicini usando
      <strong>Adaptive Relative Variance</strong>.
    </p>
  </header>

  <main>
    <!-- STATO LOCALE -->
    <section id="local-section">
      <h2>
        Nodo locale
        <span>
          <button id="panic-btn" class="ghost-btn">Reset locale</button>
          <span class="pill" id="client-pill">Client: …</span>
        </span>
      </h2>
      <div class="stat-grid">
        <div class="stat">
          <div class="label">Backend TF.js</div>
          <div class="value" id="tf-backend">–</div>
          <div class="sub" id="tf-version">–</div>
        </div>
        <div class="stat">
          <div class="label">Iterazioni (k)</div>
          <div class="value" id="local-steps">0</div>
          <div class="sub" id="local-samples">0 samples</div>
        </div>
        <div class="stat">
          <div class="label">Loss locale</div>
          <div class="value" id="local-loss">–</div>
          <div class="sub" id="local-valloss">validation: –</div>
        </div>
        <div class="stat">
          <div class="label">Tempo batch</div>
          <div class="value" id="batch-ms">–</div>
          <div class="sub" id="throughput">–</div>
        </div>
        <div class="stat">
          <div class="label">Varianza grad locale</div>
          <div class="value" id="grad-var">–</div>
          <div class="sub" id="grad-var-count">stima ARV (k≥10)</div>
        </div>
        <div class="stat">
          <div class="label">Hidden units</div>
          <div class="value" id="hidden-size">16+32+16</div>
          <div class="sub">stessa architettura per tutti</div>
        </div>
      </div>
      <canvas id="localLossChart" class="loss-chart"></canvas>
    </section>

    <!-- STATO COMBINE -->
    <section id="combine-section">
      <h2>
        Fusione ATC + ARV
        <span class="pill" id="clients-count">Nodi: 0</span>
      </h2>
      <div class="stat-grid">
        <div class="stat">
          <div class="label">Ultima fusione</div>
          <div class="value" id="combine-age">–</div>
          <div class="sub" id="combine-neighbors">–</div>
        </div>
        <div class="stat">
          <div class="label">Peso medio vicini</div>
          <div class="value" id="combine-weight">–</div>
          <div class="sub">somma a<sub>ij</sub> per j≠i</div>
        </div>
        <div class="stat">
          <div class="label">Val loss dopo combine</div>
          <div class="value" id="combine-valloss">–</div>
          <div class="sub">su batch di validation locale</div>
        </div>
      </div>
      <canvas id="globalLossChart" class="loss-chart"></canvas>
    </section>

    <!-- MESH -->
    <section id="mesh-section">
      <h2>
        Rete dei nodi
        <span class="pill">Spessore = peso ATC locale</span>
      </h2>
      <canvas id="meshCanvas"></canvas>
      <div id="node-details">
        <strong>Dettagli nodo selezionato</strong>
        <div id="node-details-body">Nessun nodo selezionato.</div>
      </div>

      <div id="dev-log">
        <div id="dev-log-body">Developer log…</div>
      </div>
    </section>

    <!-- TESTER -->
    <section id="tester-section">
      <h2>
        Tester modello locale
        <span class="pill" id="model-pill">Modello: inizializzazione…</span>
      </h2>
      <p style="font-size:0.78rem;color:#9ca4c7;">
        Carica una piccola immagine (ridimensionata a 32×32, scala di grigi)
        oppure clicca su cifre dal test set MNIST. La rete che risponde è
        <strong>quella locale</strong>, dopo i passi di Adapt–Then–Combine.
      </p>
      <input type="file" id="test-image-input" accept="image/*" />
      <button id="test-btn" disabled>Testa immagine</button>
      <div id="tester-result">In attesa che il training locale parta…</div>

      <div style="margin-top:0.7rem;">
        <div style="font-size:0.75rem;color:#9ca4c7;margin-bottom:0.2rem;">
          Oppure prova alcune cifre dal test set MNIST:
        </div>
        <div id="sample-images-container" style="display:flex;flex-wrap:wrap;gap:0.3rem;"></div>
      </div>

      <!-- VISUALIZZATORE LIVE: DISEGNO + RETE NEURALE + MATRICE PIXEL -->
      <div id="nn-live-wrapper">
        <h3 style="margin:0.7rem 0 0.3rem;font-size:0.85rem;color:#f0f4ff;">
          Rete neurale live (modello locale)
        </h3>
        <p style="font-size:0.72rem;color:#9ca4c7;margin:0 0 0.4rem;">
          Disegna una cifra: l'immagine viene campionata in una matrice
          di input 32×32 e passata al modello locale
          <code>conv8 → conv16 → flatten → dense16 → dense32 → dense16 → softmax10</code>.
          A sinistra vedi i pixel effettivi (matrice input), a destra le attivazioni
          interne di <strong>tutti i tre hidden layer</strong> che si accendono.
        </p>
        <div class="nn-layout">
          <div class="nn-left">
            <canvas id="drawCanvas" width="260" height="260"></canvas>
            <div class="nn-controls">
              <button id="draw-clear-btn" class="secondary">Pulisci</button>
              <button id="draw-noise-btn" class="secondary">Rumore</button>
              <span style="font-size:0.7rem;color:#9ca4c7;">
                Aggiornamento in tempo reale mentre disegni
              </span>
            </div>
            <div class="nn-label-row">
              <label style="color:#e5e7eb;">
                Etichetta:
                <input id="draw-label-input" type="number" min="0" max="9" value="0" />
              </label>
              <button id="draw-train-btn" class="secondary">Usa per training</button>
              <span id="draw-train-status" class="nn-label-status"></span>
            </div>
            <canvas id="pixelGridCanvas" width="128" height="128"></canvas>
            <p style="font-size:0.7rem;color:#9ca4c7;margin:0.2rem 0 0;">
              Matrice input (32×32) usata dal modello (un quadratino per pixel).
            </p>
            <h4 style="margin:0.5rem 0 0.2rem;font-size:0.8rem;">Output live (softmax)</h4>
            <div id="draw-output-panel"></div>
          </div>
          <div class="nn-right">
            <canvas id="nnCanvas"></canvas>
            <div class="legend" style="margin-top:0.35rem;font-size:0.72rem;color:#9ca4c7;">
              <span style="display:inline-block;width:16px;height:8px;border-radius:999px;background:linear-gradient(90deg,#000000,#ffffff);margin-right:4px;"></span>
              da nodo spento (nero) a molto attivo (bianco, con bagliore).<br/>
              Le linee più luminose corrispondono a neuroni sorgente più attivi.
            </div>
          </div>
        </div>
      </div>

      <hr style="border-color:#20263a;margin:0.8rem 0;"/>
      <p style="font-size:0.72rem;color:#7b84a7;">
        Architettura:
        <code>conv8 → conv16 → flatten → dense16 → dense32 → dense16 → softmax10</code><br/>
        Algoritmo: <strong>ATC</strong> con scambio del vettore
        <em>ψ</em> (pesi dopo l'adattamento) e combinazione
        <strong>Adaptive Relative Variance</strong>: i nodi con update più stabili
        pesano di più.
      </p>
    </section>
  </main>

  <footer>
    Prototipo puramente client-side. Sostituisci il <code>firebaseConfig</code> con il tuo
    progetto Firebase (Firestore + auth anonima). Dataset: MNIST PNG, repo
    <code>rasbt/mnist-pngs</code> (MIT).
  </footer>

  <!-- Canvas nascosto per caricare / ridimensionare immagini -->
  <canvas id="imageLoaderCanvas" style="display:none;"></canvas>

  <!-- LIBRERIE -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script type="module">
    /******************************************************************
     * FIREBASE MODULAR API
     ******************************************************************/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
    import {
      getFirestore,
      doc,
      setDoc,
      collection,
      addDoc,
      onSnapshot,
      query,
      orderBy,
      limit,
      serverTimestamp,
      getDocs
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";
    import {
      getAuth,
      signInAnonymously,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

    /******************************************************************
     * CONFIGURAZIONE FIREBASE
     ******************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyDUYL3b05b0RoyNMYCy9GZRtDs-4SBb-AI",
      authDomain: "twin-dungeon.firebaseapp.com",
      projectId: "twin-dungeon",
      storageBucket: "twin-dungeon.firebasestorage.app",
      messagingSenderId: "141719069384",
      appId: "1:141719069384:web:8cf21db6eddcadea0d3bfd",
      measurementId: "G-8L8Y6CL8M2"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    /******************************************************************
     * COSTANTI MODELLO / ATC
     ******************************************************************/
    const ROOM_ID = "atc-mnist-room";

    const IMG_SIZE = 32; // input effettivo usato dal modello (32×32)
    const NUM_CHANNELS = 1;
    const NUM_CLASSES = 10;
    const HIDDEN1_UNITS = 16;
    const HIDDEN2_UNITS = 32;
    const HIDDEN3_UNITS = 16;
    const TOTAL_HIDDEN_UNITS = HIDDEN1_UNITS + HIDDEN2_UNITS + HIDDEN3_UNITS;

    // Indici dei tensori di pesi nella CNN:
    // 0: conv1/kernel, 1: conv1/bias,
    // 2: conv2/kernel, 3: conv2/bias,
    // 4: dense_hidden1/kernel, 5: dense_hidden1/bias,
    // 6: dense_hidden2/kernel, 7: dense_hidden2/bias,
    // 8: dense_hidden3/kernel, 9: dense_hidden3/bias,
    // 10: dense_out/kernel,   11: dense_out/bias
    // Per il gossip allineiamo il TERZO hidden (dense_hidden3)
    const IDX_DH_KERNEL = 8;
    const IDX_DH_BIAS   = 9;
    const IDX_DO_KERNEL = 10;

    const TRAIN_BATCH_SIZE = 16;
    const VAL_BATCH_SIZE   = 32;
    const TRAINING_PAUSE_MS = 800;

    const MAX_TRAIN_ITEMS = 12000;
    const MAX_VAL_ITEMS   = 2000;

    const MNIST_ROOT      = "https://raw.githubusercontent.com/rasbt/mnist-pngs/main/";
    const MNIST_TRAIN_CSV = MNIST_ROOT + "train.csv";
    const MNIST_TEST_CSV  = MNIST_ROOT + "test.csv";

    // nuova versione per non clashare con meta precedenti
    const META_STORAGE_KEY = "atc-mnist-meta-v4-32x32";

    const VAR_BETA = 0.1;
    const COMBINE_VAL_EVERY = 10;
    const OFFLINE_THRESHOLD_MS = 60000;

    /******************************************************************
     * STATO GLOBALE
     ******************************************************************/
    let currentUser = null;
    let clientId = null;

    let model = null;
    let activationModel = null;

    let trainManifest = null;
    let valManifest   = null;

    let localSteps   = 0;
    let localSamples = 0;
    let lastTrainLoss = null;
    let lastValLoss   = null;
    let avgBatchMs = 0;

    let localGradVar = null;
    let localGradVarCount = 0;

    let lastCombineTime        = null;
    let lastCombineNeighbors   = 0;
    let lastCombineNeighborAvg = null;
    let lastCombineValLoss     = null;

    const clientsState = new Map();
    let recentSnapshots = [];

    let batteryInfo = null;

    let localLossChart  = null;
    let globalLossChart = null;

    let meshNodesLayout = new Map();
    let lastEdgeWeights = new Map();
    let hasLocalMeta = false;

    const devLogBuffer = [];
    const DEV_LOG_MAX  = 200;

    // canvas per griglia di pixel
    let pixelGridCanvas = null;
    let pixelGridCtx = null;

    // coordinazione tra training ATC e training da disegno
    let trainingBusy = false;
    let clientDocRef = null;
    let snapshotsColRefGlobal = null;

    /******************************************************************
     * DEV LOG
     ******************************************************************/
    function devLog(msg) {
      const ts = new Date().toLocaleTimeString();
      const line = `[${ts}] ${msg}`;
      devLogBuffer.unshift(line);
      if (devLogBuffer.length > DEV_LOG_MAX) devLogBuffer.pop();
      const el = document.getElementById("dev-log-body");
      if (el) el.innerHTML = devLogBuffer.join("<br>");
      console.log("[DEV]", msg);
    }

    /******************************************************************
     * UTILITIES
     ******************************************************************/
    function sleep(ms) {
      return new Promise(res => setTimeout(res, ms));
    }
    function clamp(v, min, max) {
      return Math.min(Math.max(v, min), max);
    }
    function formatMs(ms) {
      if (ms == null) return "–";
      return ms.toFixed(1) + " ms/batch";
    }

    /******************************************************************
     * GOSSIP: Sinkhorn per allineare i neuroni nascosti (3° layer dense)
     ******************************************************************/
    function denseHiddenKernelToNeuronMatrix(flatArray, shape) {
      const inDim = shape[0];
      const H = shape[1];
      const mat = [];
      for (let h = 0; h < H; h++) {
        const neuron = [];
        for (let i = 0; i < inDim; i++) {
          const idx = i * H + h;
          neuron.push(flatArray[idx]);
        }
        mat.push(neuron);
      }
      return mat;
    }

    function euclideanDistanceVec(a, b) {
      let sum = 0;
      for (let i = 0; i < a.length; i++) {
        const d = a[i] - b[i];
        sum += d * d;
      }
      return Math.sqrt(sum);
    }

    function computeCostMatrix(localMat, neighMat) {
      const H = Math.min(localMat.length, neighMat.length);
      const C = [];
      for (let i = 0; i < H; i++) {
        const row = [];
        for (let j = 0; j < H; j++) {
          row.push(euclideanDistanceVec(localMat[i], neighMat[j]));
        }
        C.push(row);
      }
      return C;
    }

    function runSinkhornGossip(costMatrix, epsFactor = 0.1, iterations = 5) {
      const H = costMatrix.length;
      if (!H) return { P: [] };

      let sum = 0, cnt = 0;
      for (let i = 0; i < H; i++) {
        for (let j = 0; j < H; j++) {
          sum += costMatrix[i][j];
          cnt++;
        }
      }
      const meanC = cnt > 0 ? sum / cnt : 1.0;
      const epsilon = Math.max(meanC * epsFactor, 1e-6);

      const P = [];
      for (let i = 0; i < H; i++) {
        const row = [];
        for (let j = 0; j < H; j++) {
          row.push(Math.exp(-costMatrix[i][j] / epsilon));
        }
        P.push(row);
      }

      for (let it = 0; it < iterations; it++) {
        // righe
        for (let i = 0; i < H; i++) {
          let s = 0;
          for (let j = 0; j < H; j++) s += P[i][j];
          if (s > 0) {
            for (let j = 0; j < H; j++) P[i][j] /= s;
          }
        }
        // colonne
        for (let j = 0; j < H; j++) {
          let s = 0;
          for (let i = 0; i < H; i++) s += P[i][j];
          if (s > 0) {
            for (let i = 0; i < H; i++) P[i][j] /= s;
          }
        }
      }

      return { P };
    }

    function argmaxPermutation(P) {
      const H = P.length;
      const perm = new Array(H).fill(0);
      const used = new Array(H).fill(false);
      for (let i = 0; i < H; i++) {
        let bestJ = 0;
        let best = -Infinity;
        for (let j = 0; j < H; j++) {
          if (!used[j] && P[i][j] > best) {
            best = P[i][j];
            bestJ = j;
          }
        }
        perm[i] = bestJ;
        used[bestJ] = true;
      }
      return perm;
    }

    function permuteHiddenInPlace(arrays, shapes, perm) {
      const kernelShape = shapes[IDX_DH_KERNEL]; // [inDim, H] del terzo hidden
      const inDim = kernelShape[0];
      const H = kernelShape[1];

      const kernel = arrays[IDX_DH_KERNEL];
      const bias   = arrays[IDX_DH_BIAS];
      const outK   = arrays[IDX_DO_KERNEL];
      const outShape = shapes[IDX_DO_KERNEL]; // [H, numClasses]
      const numClasses = outShape[1];

      const newKernel = new Float32Array(kernel.length);
      const newBias   = new Float32Array(bias.length);
      const newOutK   = new Float32Array(outK.length);

      for (let h = 0; h < H; h++) {
        const srcH = perm[h];
        for (let i = 0; i < inDim; i++) {
          const srcIdx = i * H + srcH;
          const dstIdx = i * H + h;
          newKernel[dstIdx] = kernel[srcIdx];
        }
      }

      for (let h = 0; h < H; h++) {
        newBias[h] = bias[perm[h]];
      }

      for (let h = 0; h < H; h++) {
        const srcH = perm[h];
        for (let c = 0; c < numClasses; c++) {
          const srcIdx = srcH * numClasses + c;
          const dstIdx = h * numClasses + c;
          newOutK[dstIdx] = outK[srcIdx];
        }
      }

      arrays[IDX_DH_KERNEL] = newKernel;
      arrays[IDX_DH_BIAS]   = newBias;
      arrays[IDX_DO_KERNEL] = newOutK;
    }

    /******************************************************************
     * MNIST PNG: CSV → MANIFESTO
     ******************************************************************/
    async function fetchCsvLines(url, maxLines = null) {
      devLog("Scarico CSV: " + url);
      const resp = await fetch(url);
      if (!resp.ok) throw new Error("Impossibile caricare CSV: " + url);
      const text = await resp.text();
      const all = text.trim().split(/\r?\n/);
      const header = all.shift();
      if (!header.toLowerCase().startsWith("filepath")) {
        console.warn("Header CSV inatteso:", header);
      }
      const lines = maxLines ? all.slice(0, maxLines) : all;
      return lines;
    }

    function parseMnistCsvLines(lines) {
      const items = [];
      for (const line of lines) {
        if (!line) continue;
        const parts = line.split(",");
        if (parts.length < 2) continue;
        const fp  = parts[0].trim();
        const lbl = parseInt(parts[1].trim(), 10);
        if (Number.isNaN(lbl)) continue;
        items.push({ url: MNIST_ROOT + fp, label: lbl });
      }
      return items;
    }

    function balancedSampleByLabel(items, maxTotal) {
      const shuffled = items.slice();
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      const perClass = Math.max(1, Math.floor(maxTotal / NUM_CLASSES));
      const counts = new Array(NUM_CLASSES).fill(0);
      const out = [];
      for (const it of shuffled) {
        if (out.length >= maxTotal) break;
        if (it.label < 0 || it.label >= NUM_CLASSES) continue;
        if (counts[it.label] >= perClass) continue;
        counts[it.label]++;
        out.push(it);
      }
      return out;
    }

    async function loadMnistManifests() {
      const [trainLines, testLines] = await Promise.all([
        fetchCsvLines(MNIST_TRAIN_CSV, null),
        fetchCsvLines(MNIST_TEST_CSV,  null)
      ]);
      const trainAll = parseMnistCsvLines(trainLines);
      const valAll   = parseMnistCsvLines(testLines);

      const trainItems = balancedSampleByLabel(trainAll, MAX_TRAIN_ITEMS);
      const valItems   = balancedSampleByLabel(valAll,   MAX_VAL_ITEMS);

      devLog(`MNIST manifest: train=${trainItems.length}, val=${valItems.length}`);

      return {
        trainManifest: {
          classes: Array.from({length: NUM_CLASSES}, (_,i)=>String(i)),
          items: trainItems
        },
        valManifest: {
          classes: Array.from({length: NUM_CLASSES}, (_,i)=>String(i)),
          items: valItems
        }
      };
    }

    /******************************************************************
     * MODELLO CNN (3 hidden: 16 → 32 → 16, input 32×32)
     ******************************************************************/
    function buildModel() {
      const m = tf.sequential();
      m.add(tf.layers.conv2d({
        inputShape: [IMG_SIZE, IMG_SIZE, NUM_CHANNELS],
        filters: 8,
        kernelSize: 3,
        activation: "relu",
        padding: "same",
        name: "conv1"
      }));
      m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
      m.add(tf.layers.conv2d({
        filters: 16,
        kernelSize: 3,
        activation: "relu",
        padding: "same",
        name: "conv2"
      }));
      m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
      m.add(tf.layers.flatten());
      m.add(tf.layers.dense({
        units: HIDDEN1_UNITS,
        activation: "relu",
        name: "dense_hidden1"
      }));
      m.add(tf.layers.dense({
        units: HIDDEN2_UNITS,
        activation: "relu",
        name: "dense_hidden2"
      }));
      m.add(tf.layers.dense({
        units: HIDDEN3_UNITS,
        activation: "relu",
        name: "dense_hidden3"
      }));
      m.add(tf.layers.dense({
        units: NUM_CLASSES,
        activation: "softmax",
        name: "dense_out"
      }));
      m.compile({
        optimizer: tf.train.adam(0.001),
        loss: "categoricalCrossentropy",
        metrics: ["accuracy"]
      });
      return m;
    }

    /******************************************************************
     * PESI: ESTRAZIONE, APPLICAZIONE, QUANTIZZAZIONE
     ******************************************************************/
    function extractWeights() {
      const tensors = model.getWeights();
      const shapes  = tensors.map(t => t.shape);
      const arrays  = tensors.map(t => Float32Array.from(t.dataSync()));
      return { shapes, arrays };
    }

    function applyWeightsToModel(shapes, arrays) {
      const tensors = shapes.map((shape, idx) =>
        tf.tensor(arrays[idx], shape, "float32")
      );
      model.setWeights(tensors);
      tensors.forEach(t => t.dispose());
    }

    function quantizeWeights(shapes, arrays) {
      const scales = [];
      const quantMaps = {};
      const shapesMap = {};
      for (let idx = 0; idx < arrays.length; idx++) {
        const arr = arrays[idx];
        shapesMap[idx] = shapes[idx];
        let maxAbs = 0;
        for (let i = 0; i < arr.length; i++) {
          const a = Math.abs(arr[i]);
          if (a > maxAbs) maxAbs = a;
        }
        const scale = maxAbs > 0 ? maxAbs / 127.0 : 1e-8;
        const q = new Int8Array(arr.length);
        for (let i = 0; i < arr.length; i++) {
          q[i] = Math.max(-127, Math.min(127, Math.round(arr[i] / scale)));
        }
        scales.push(scale);
        quantMaps[idx] = Array.from(q);
      }
      return { shapes: shapesMap, scales, quantArrays: quantMaps };
    }

    function dequantizeSnapshot(snapData) {
      const shapesMap = snapData.shapes || {};
      const quantMap  = snapData.quantArrays || {};
      const scales    = snapData.scales || [];
      const indices = Object.keys(quantMap).map(k => Number(k)).sort((a,b)=>a-b);
      const shapes = [];
      const arrays = [];
      for (const idx of indices) {
        const shape = shapesMap[idx];
        const qArr  = quantMap[idx];
        const scale = scales[idx];
        if (!shape || !qArr || scale == null) continue;
        const fArr = new Float32Array(qArr.length);
        for (let i = 0; i < qArr.length; i++) {
          fArr[i] = qArr[i] * scale;
        }
        shapes.push(shape);
        arrays.push(fArr);
      }
      return { shapes, arrays };
    }

    function sanitizeWeightArrays(arrays) {
      let changed = false;
      for (const arr of arrays) {
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i];
          if (!Number.isFinite(v)) {
            arr[i] = 0;
            changed = true;
          }
        }
      }
      if (changed) devLog("Sanitizzazione pesi combinati: NaN/Inf → 0");
    }

    /******************************************************************
     * LOCAL STORAGE
     ******************************************************************/
    async function saveLocalMeta(arraysForSave = null, shapesForSave = null) {
      let weightsPayload = null;
      try {
        const { shapes, arrays } = arraysForSave && shapesForSave
          ? { shapes: shapesForSave, arrays: arraysForSave }
          : extractWeights();
        weightsPayload = {
          shapes,
          arrays: arrays.map(a => Array.from(a))
        };
      } catch (e) {
        console.warn("Errore estrazione pesi per salvataggio:", e);
        devLog("Errore estrazione pesi per salvataggio: " + e.message);
      }
      const meta = {
        weights: weightsPayload,
        localSteps,
        localSamples,
        lastTrainLoss,
        lastValLoss,
        localGradVar,
        localGradVarCount
      };
      try {
        localStorage.setItem(META_STORAGE_KEY, JSON.stringify(meta));
      } catch (e) {
        console.warn("Errore salvataggio meta localStorage:", e);
        devLog("Errore salvataggio meta localStorage: " + e.message);
      }
    }

    async function loadLocalModelOrInit() {
      model = buildModel();
      hasLocalMeta = false;
      try {
        const metaStr = localStorage.getItem(META_STORAGE_KEY);
        if (!metaStr) {
          devLog("Nessun meta locale, modello nuovo.");
          return;
        }
        const meta = JSON.parse(metaStr);
        if (!meta.weights || !meta.weights.shapes || !meta.weights.arrays) {
          devLog("Meta incompleto, uso modello nuovo.");
          return;
        }
        const shapes = meta.weights.shapes;
        const arrays = meta.weights.arrays;
        const expectedWeights = model.getWeights().length;
        if (shapes.length !== arrays.length || shapes.length !== expectedWeights) {
          devLog("Meta pesi incoerente con la nuova architettura, uso modello nuovo.");
          return;
        }
        const tensors = shapes.map((shape, idx) =>
          tf.tensor(arrays[idx], shape, "float32")
        );
        model.setWeights(tensors);
        tensors.forEach(t => t.dispose());

        localSteps          = meta.localSteps || 0;
        localSamples        = meta.localSamples || 0;
        lastTrainLoss       = meta.lastTrainLoss ?? null;
        lastValLoss         = meta.lastValLoss ?? null;
        localGradVar        = meta.localGradVar ?? null;
        localGradVarCount   = meta.localGradVarCount || 0;

        hasLocalMeta = true;
        devLog(`Meta locale ripristinato: steps=${localSteps}, samples=${localSamples}, gradVarCount=${localGradVarCount}`);
      } catch (e) {
        console.warn("Errore loadLocalModelOrInit:", e);
        devLog("Errore loadLocalModelOrInit: " + e.message);
      }
    }

    /******************************************************************
     * IMAGE → TENSOR (da URL) - ora 32×32
     ******************************************************************/
    async function loadImageAsTensor(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const canvas = document.getElementById("imageLoaderCanvas");
          const ctx = canvas.getContext("2d");
          canvas.width = IMG_SIZE;
          canvas.height = IMG_SIZE;
          ctx.drawImage(img, 0, 0, IMG_SIZE, IMG_SIZE); // “stira” il 28×28 in 32×32
          let imgTensor = tf.browser.fromPixels(canvas, NUM_CHANNELS);
          imgTensor = tf.tidy(() => imgTensor.toFloat().div(255.0));
          const batched = imgTensor.expandDims(0);
          imgTensor.dispose();
          resolve(batched);
        };
        img.onerror = (e) => reject(e);
        img.src = url;
      });
    }

    async function loadBatchFromManifest(manifest, batchSize) {
      const items = manifest.items;
      if (!items || !items.length) throw new Error("Manifest vuoto");
      const xsList = [];
      const ysList = [];
      for (let i = 0; i < batchSize; i++) {
        const idx = Math.floor(Math.random() * items.length);
        const item = items[idx];
        const x = await loadImageAsTensor(item.url);
        xsList.push(x);
        ysList.push(item.label);
      }
      const xs = tf.concat(xsList, 0);
      xsList.forEach(t => t.dispose());
      const ysIdx = tf.tensor1d(ysList, "int32");
      const ys = tf.oneHot(ysIdx, NUM_CLASSES);
      ysIdx.dispose();
      return { xs, ys };
    }

    /******************************************************************
     * CHARTS
     ******************************************************************/
    function pushChartPoint(chart, value) {
      if (!chart || value == null || !Number.isFinite(value)) return;
      chart.data.labels.push("");
      chart.data.datasets[0].data.push(value);
      if (chart.data.labels.length > 60) {
        chart.data.labels.shift();
        chart.data.datasets[0].data.shift();
      }
      chart.update("quiet");
    }

    function initCharts() {
      const ctxL = document.getElementById("localLossChart").getContext("2d");
      localLossChart = new Chart(ctxL, {
        type: "line",
        data: { labels: [], datasets: [{ label: "Loss locale", data: [], tension: 0.2 }] },
        options: {
          responsive: true,
          scales: { x: { display: false }, y: { display: true } },
          plugins: { legend: { display: false } }
        }
      });

      const ctxG = document.getElementById("globalLossChart").getContext("2d");
      globalLossChart = new Chart(ctxG, {
        type: "line",
        data: { labels: [], datasets: [{ label: "Val loss dopo combine", data: [], tension: 0.2 }] },
        options: {
          responsive: true,
          scales: { x: { display: false }, y: { display: true } },
          plugins: { legend: { display: false } }
        }
      });
    }

    /******************************************************************
     * UI UPDATE
     ******************************************************************/
    function updateLocalUI() {
      document.getElementById("tf-backend").textContent = tf.getBackend() || "–";
      document.getElementById("tf-version").textContent =
        "TF.js " + (tf.version ? tf.version.tfjs : "");

      document.getElementById("local-steps").textContent   = localSteps.toString();
      document.getElementById("local-samples").textContent = `${localSamples} samples`;
      document.getElementById("local-loss").textContent =
        lastTrainLoss != null && Number.isFinite(lastTrainLoss)
          ? lastTrainLoss.toFixed(4)
          : "–";
      document.getElementById("local-valloss").textContent =
        lastValLoss != null && Number.isFinite(lastValLoss)
          ? "validation: " + lastValLoss.toFixed(4)
          : "validation: –";

      document.getElementById("batch-ms").textContent = formatMs(avgBatchMs);
      const thr = avgBatchMs > 0 ? (TRAIN_BATCH_SIZE / (avgBatchMs / 1000)).toFixed(1) + " img/s" : "–";
      document.getElementById("throughput").textContent = thr;

      const gv = localGradVar;
      document.getElementById("grad-var").textContent =
        (gv != null && Number.isFinite(gv)) ? gv.toExponential(2) : "–";
      document.getElementById("grad-var-count").textContent =
        `stima ARV (k=${localGradVarCount})`;

      document.getElementById("hidden-size").textContent =
        `${HIDDEN1_UNITS}+${HIDDEN2_UNITS}+${HIDDEN3_UNITS}`;

      if (batteryInfo) {
        const lvl = Math.round(batteryInfo.level * 100);
        const bl = document.getElementById("battery-level");
        const bs = document.getElementById("battery-status");
        if (bl) bl.textContent = lvl + " %";
        if (bs) bs.textContent = batteryInfo.charging ? "in carica" : "su batteria";
      } else {
        const bl = document.getElementById("battery-level");
        const bs = document.getElementById("battery-status");
        if (bl) bl.textContent = "–";
        if (bs) bs.textContent = "API batteria non disponibile";
      }
    }

    function updateCombineUI() {
      document.getElementById("clients-count").textContent =
        "Nodi: " + clientsState.size.toString();

      if (lastCombineTime) {
        const ageSec = Math.round((Date.now() - lastCombineTime) / 1000);
        document.getElementById("combine-age").textContent = ageSec + " s fa";
      } else {
        document.getElementById("combine-age").textContent = "–";
      }

      document.getElementById("combine-neighbors").textContent =
        lastCombineNeighbors > 0
          ? `${lastCombineNeighbors} vicini maturi`
          : "solo self";

      document.getElementById("combine-weight").textContent =
        lastCombineNeighborAvg != null
          ? (lastCombineNeighborAvg * 100).toFixed(1) + " %"
          : "–";

      document.getElementById("combine-valloss").textContent =
        lastCombineValLoss != null && Number.isFinite(lastCombineValLoss)
          ? lastCombineValLoss.toFixed(4)
          : "–";
    }

    /******************************************************************
     * MESH UI
     ******************************************************************/
    function resizeMeshCanvas() {
      const canvas = document.getElementById("meshCanvas");
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawMesh();
    }
    window.addEventListener("resize", resizeMeshCanvas);

    function drawMesh() {
      const canvas = document.getElementById("meshCanvas");
      const ctx = canvas.getContext("2d");
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      ctx.clearRect(0, 0, width, height);

      const entries = Array.from(clientsState.entries());
      const n = entries.length;
      if (!n) return;

      const cx = width / 2;
      const cy = height / 2;
      const radius = Math.min(width, height) * 0.35;
      meshNodesLayout.clear();

      for (let i = 0; i < n; i++) {
        const [cid, data] = entries[i];
        const angle = 2 * Math.PI * i / n;
        const x = cx + radius * Math.cos(angle);
        const y = cy + radius * Math.sin(angle);
        const stepsNorm = Math.min(1, (data.localSteps || 0) / 500);
        const r = 9 + 7 * stepsNorm;
        meshNodesLayout.set(cid, { x, y, r });
      }

      for (let i = 0; i < n; i++) {
        for (let j = i+1; j < n; j++) {
          const [cid1] = entries[i];
          const [cid2] = entries[j];
          const n1 = meshNodesLayout.get(cid1);
          const n2 = meshNodesLayout.get(cid2);

          let lineWidth = 1;
          let alpha = 0.15;

          if (cid1 === clientId || cid2 === clientId) {
            const neighborId = cid1 === clientId ? cid2 : cid1;
            const w = lastEdgeWeights.get(neighborId) || 0;
            lineWidth = 1 + 4 * w;
            alpha = 0.15 + 0.35 * w;
          }

          ctx.strokeStyle = `rgba(120,150,255,${alpha})`;
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(n1.x, n1.y);
          ctx.lineTo(n2.x, n2.y);
          ctx.stroke();
        }
      }

      for (let i = 0; i < n; i++) {
        const [cid, data] = entries[i];
        const node = meshNodesLayout.get(cid);
        const isSelf = cid === clientId;
        let color = "#4f9cff";
        const vLoss = data.localValLoss;
        if (vLoss != null && Number.isFinite(vLoss)) {
          if (vLoss < 0.4) color = "#57e39f";
          else if (vLoss < 0.9) color = "#ffd166";
          else color = "#ff6b6b";
        }
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.r, 0, 2*Math.PI);
        ctx.fillStyle = isSelf ? "#ffffff" : color;
        ctx.fill();
        ctx.lineWidth = isSelf ? 3 : 1.5;
        ctx.strokeStyle = isSelf ? "#4f9cff" : "#111728";
        ctx.stroke();
      }
    }

    document.getElementById("meshCanvas").addEventListener("click", (evt) => {
      const canvas = document.getElementById("meshCanvas");
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      if (!meshNodesLayout.size) return;
      let bestId = null;
      let bestD2 = Infinity;
      for (const [cid, node] of meshNodesLayout.entries()) {
        const dx = x - node.x;
        const dy = y - node.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2) {
          bestD2 = d2;
          bestId = cid;
        }
      }
      if (!bestId) return;
      const node = meshNodesLayout.get(bestId);
      const maxD2 = node.r * node.r * 4;
      if (bestD2 > maxD2 && meshNodesLayout.size > 1) return;
      showNodeDetails(bestId);
    });

    function showNodeDetails(cid) {
      const d = clientsState.get(cid);
      const body = document.getElementById("node-details-body");
      if (!d) {
        body.textContent = "Nessun dato per questo nodo.";
        return;
      }
      const isSelf = cid === clientId;
      const lines = [];
      lines.push(`<div><strong>${isSelf ? "Questo nodo" : "Nodo remoto"}</strong></div>`);
      lines.push(`<div style="word-break:break-all;font-size:0.7rem;">ID: ${cid}</div>`);
      lines.push(`<div>Steps: ${d.localSteps ?? 0}</div>`);
      lines.push(`<div>Samples: ${d.localSamples ?? 0}</div>`);
      lines.push(`<div>Val loss: ${
        d.localValLoss != null && Number.isFinite(d.localValLoss)
          ? d.localValLoss.toFixed(4)
          : "–"
      }</div>`);
      if (d.gradVar != null && Number.isFinite(d.gradVar)) {
        lines.push(`<div>Var grad stimata: ${d.gradVar.toExponential(2)}</div>`);
        lines.push(`<div>k var: ${d.gradVarCount ?? 0}</div>`);
      }
      const edgeW = lastEdgeWeights.get(cid);
      if (edgeW != null) {
        lines.push(
          `<div>Peso ATC locale: ${(edgeW * 100).toFixed(1)} %</div>`
        );
      }
      lines.push(`<div>Ultimo visto: ${
        d.lastSeen ? new Date(d.lastSeen).toLocaleTimeString() : "–"
      }</div>`);
      body.innerHTML = lines.join("");
    }

    /******************************************************************
     * BATTERIA
     ******************************************************************/
    function initBattery() {
      if ("getBattery" in navigator) {
        navigator.getBattery().then(b => {
          batteryInfo = b;
          b.addEventListener("levelchange", updateLocalUI);
          b.addEventListener("chargingchange", updateLocalUI);
          updateLocalUI();
        }).catch(()=>{});
      }
    }

    /******************************************************************
     * TESTER: FILE + SAMPLE GALLERY
     ******************************************************************/
    function probsContainNonFinite(arr) {
      for (let i = 0; i < arr.length; i++) {
        if (!Number.isFinite(arr[i])) return true;
      }
      return false;
    }

    async function predictOne(x) {
      const y = model.predict(x);
      const probs = await y.data();
      y.dispose();
      if (probsContainNonFinite(probs)) return null;
      let best = 0;
      for (let i = 1; i < probs.length; i++) {
        if (probs[i] > probs[best]) best = i;
      }
      return {
        probs: Array.from(probs),
        predIdx: best
      };
    }

    function formatSoftmaxLine(pred, classes) {
      if (!pred) return "NaN / modello instabile";
      const probsStr = pred.probs
        .map((p, i) => `${classes[i] ?? i}:${p.toFixed(3)}`)
        .join(", ");
      return `[${probsStr}] → pred: ${classes[pred.predIdx] ?? pred.predIdx}`;
    }

    function initTesterUI() {
      const input = document.getElementById("test-image-input");
      const btn = document.getElementById("test-btn");
      btn.addEventListener("click", async () => {
        const file = input.files && input.files[0];
        if (!file || !model) return;
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = async () => {
            const canvas = document.getElementById("imageLoaderCanvas");
            const ctx = canvas.getContext("2d");
            canvas.width = IMG_SIZE;
            canvas.height = IMG_SIZE;
            ctx.drawImage(img, 0, 0, IMG_SIZE, IMG_SIZE);
            let imgTensor = tf.browser.fromPixels(canvas, NUM_CHANNELS);
            imgTensor = tf.tidy(() => imgTensor.toFloat().div(255.0));
            const x = imgTensor.expandDims(0);
            imgTensor.dispose();

            const pred = await predictOne(x);
            x.dispose();

            const classes = trainManifest?.classes || [];
            const resultEl = document.getElementById("tester-result");
            resultEl.textContent =
              `File caricato\n` + formatSoftmaxLine(pred, classes);
            devLog("Test file: predIdx=" + (pred?.predIdx ?? "n/d"));
          };
          img.onerror = () => {
            document.getElementById("tester-result").textContent =
              "Errore caricamento immagine.";
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      });
    }

    function populateSampleGallery() {
      const container = document.getElementById("sample-images-container");
      if (!container || !valManifest || !valManifest.items || !valManifest.items.length) return;
      container.innerHTML = "";
      const items = valManifest.items;
      const numSamples = Math.min(12, items.length);
      const used = new Set();
      while (used.size < numSamples) {
        const idx = Math.floor(Math.random() * items.length);
        used.add(idx);
      }
      for (const idx of used) {
        const item = items[idx];
        const imgEl = document.createElement("img");
        imgEl.src = item.url;
        imgEl.className = "sample-thumb";
        imgEl.title = "Label reale: " + item.label;
        imgEl.dataset.label = item.label;
        imgEl.dataset.url = item.url;
        imgEl.addEventListener("click", async () => {
          document.querySelectorAll(".sample-thumb.selected")
            .forEach(el => el.classList.remove("selected"));
          imgEl.classList.add("selected");
          try {
            const x = await loadImageAsTensor(item.url);
            const pred = await predictOne(x);
            x.dispose();
            const classes = trainManifest?.classes || [];
            const trueLabel = classes[item.label] ?? String(item.label);
            const resultEl = document.getElementById("tester-result");
            resultEl.textContent =
              `Sample dal dataset (label reale: ${trueLabel})\n` +
              formatSoftmaxLine(pred, classes);
            devLog(
              `Pred sample (true=${trueLabel}): predIdx=${pred?.predIdx ?? "n/d"}`
            );
          } catch (e) {
            console.error("Errore pred sample:", e);
            devLog("Errore pred sample: " + e.message);
          }
        });
        container.appendChild(imgEl);
      }
    }

    /******************************************************************
     * VISUALIZZATORE NN LIVE (disegno → attivazioni modello locale)
     * Visualizza la rete effettiva:
     *   input (4x4 blocchi) → hidden1(16) → hidden2(32) → hidden3(16) → output(10)
     ******************************************************************/
    const VIS_IN  = 16;                // 4×4 blocchi dall'immagine
    const VIS_H1  = HIDDEN1_UNITS;     // 16 neuroni
    const VIS_H2  = HIDDEN2_UNITS;     // 32 neuroni
    const VIS_H3  = HIDDEN3_UNITS;     // 16 neuroni
    const VIS_OUT = NUM_CLASSES;       // 10 cifre

    let drawCanvasNN = null;
    let drawCtxNN = null;
    let drawDownCanvasNN = null;
    let drawDownCtxNN = null;
    let drawIsDrawing = false;
    let drawLastX = 0, drawLastY = 0;
    let drawUpdateQueuedNN = false;
    let drawPredictBusy = false;

    let nnCanvasEl = null;
    let nnCtx = null;
    let nnPositions = {
      input: [],
      hidden1: [],
      hidden2: [],
      hidden3: [],
      output: []
    };

    let visActs = {
      input:  new Array(VIS_IN).fill(0),
      hidden1: new Array(VIS_H1).fill(0),
      hidden2: new Array(VIS_H2).fill(0),
      hidden3: new Array(VIS_H3).fill(0),
      output: new Array(VIS_OUT).fill(1 / VIS_OUT)
    };

    function initActivationModel() {
      if (!model) return;
      try {
        if (activationModel) {
          activationModel.dispose();
          activationModel = null;
        }
        const dense1 = model.getLayer("dense_hidden1");
        const dense2 = model.getLayer("dense_hidden2");
        const dense3 = model.getLayer("dense_hidden3");
        const denseOut = model.getLayer("dense_out");
        activationModel = tf.model({
          inputs: model.inputs,
          outputs: [dense1.output, dense2.output, dense3.output, denseOut.output]
        });
        devLog("Activation model inizializzato per visualizzazione live (dense_hidden1-2-3 + output).");
      } catch (e) {
        console.warn("Impossibile creare activationModel:", e);
        devLog("Impossibile creare activationModel: " + e.message);
      }
    }

    function initNNVisualizer() {
      initPixelGridCanvas();
      setupDrawingNNCanvas();
      setupNNCanvas();
      updateFromDrawingNN();

      const trainBtn = document.getElementById("draw-train-btn");
      if (trainBtn) {
        trainBtn.addEventListener("click", () => {
          trainOnDrawingExample().catch(e => {
            console.error("Errore trainOnDrawingExample (click):", e);
          });
        });
      }
    }

    function initPixelGridCanvas() {
      pixelGridCanvas = document.getElementById("pixelGridCanvas");
      if (!pixelGridCanvas) return;
      pixelGridCtx = pixelGridCanvas.getContext("2d");
      if (pixelGridCtx) {
        pixelGridCtx.imageSmoothingEnabled = false;
        renderPixelGridNN(new Float32Array(IMG_SIZE * IMG_SIZE).fill(0));
      }
    }

    function setupDrawingNNCanvas() {
      drawCanvasNN = document.getElementById("drawCanvas");
      if (!drawCanvasNN) return;
      drawCtxNN = drawCanvasNN.getContext("2d");

      drawDownCanvasNN = document.createElement("canvas");
      drawDownCanvasNN.width = IMG_SIZE;
      drawDownCanvasNN.height = IMG_SIZE;
      drawDownCtxNN = drawDownCanvasNN.getContext("2d");

      clearDrawingNN();

      const getPos = (e) => {
        const rect = drawCanvasNN.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
          x: clientX - rect.left,
          y: clientY - rect.top
        };
      };

      const start = (e) => {
        e.preventDefault();
        drawIsDrawing = true;
        const p = getPos(e);
        drawLastX = p.x;
        drawLastY = p.y;
        scheduleUpdateFromDrawingNN();
      };

      const move = (e) => {
        if (!drawIsDrawing) return;
        e.preventDefault();
        const p = getPos(e);
        drawCtxNN.lineCap = "round";
        drawCtxNN.lineJoin = "round";
        drawCtxNN.lineWidth = 18;
        drawCtxNN.strokeStyle = "#ffffff";
        drawCtxNN.beginPath();
        drawCtxNN.moveTo(drawLastX, drawLastY);
        drawCtxNN.lineTo(p.x, p.y);
        drawCtxNN.stroke();
        drawLastX = p.x;
        drawLastY = p.y;
        scheduleUpdateFromDrawingNN();
      };

      const end = (e) => {
        if (!drawIsDrawing) return;
        e.preventDefault();
        drawIsDrawing = false;
        scheduleUpdateFromDrawingNN();
      };

      drawCanvasNN.addEventListener("mousedown", start);
      drawCanvasNN.addEventListener("mousemove", move);
      window.addEventListener("mouseup", end);

      drawCanvasNN.addEventListener("touchstart", start, { passive: false });
      drawCanvasNN.addEventListener("touchmove", move, { passive: false });
      drawCanvasNN.addEventListener("touchend", end);

      const clearBtn = document.getElementById("draw-clear-btn");
      const noiseBtn = document.getElementById("draw-noise-btn");
      if (clearBtn) clearBtn.addEventListener("click", () => {
        clearDrawingNN();
        updateFromDrawingNN();
      });
      if (noiseBtn) noiseBtn.addEventListener("click", () => {
        addRandomNoiseNN();
        updateFromDrawingNN();
      });
    }

    function clearDrawingNN() {
      if (!drawCtxNN || !drawCanvasNN) return;
      drawCtxNN.fillStyle = "#000000";
      drawCtxNN.fillRect(0, 0, drawCanvasNN.width, drawCanvasNN.height);
    }

    function addRandomNoiseNN() {
      if (!drawCtxNN || !drawCanvasNN) return;
      const imgData = drawCtxNN.getImageData(0, 0, drawCanvasNN.width, drawCanvasNN.height);
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        const v = Math.random() < 0.04 ? 255 : 0;
        data[i] = v;
        data[i + 1] = v;
        data[i + 2] = v;
      }
      drawCtxNN.putImageData(imgData, 0, 0);
    }

    function scheduleUpdateFromDrawingNN() {
      if (drawUpdateQueuedNN) return;
      drawUpdateQueuedNN = true;
      requestAnimationFrame(() => {
        drawUpdateQueuedNN = false;
        if (!drawPredictBusy) {
          updateFromDrawingNN();
        }
      });
    }

    // estrai dalla canvas di disegno la matrice IMG_SIZE×IMG_SIZE e le feature 4×4
    function extractFeaturesFromDrawing() {
      if (!drawDownCtxNN || !drawCanvasNN) return null;
      drawDownCtxNN.fillStyle = "#000000";
      drawDownCtxNN.fillRect(0, 0, IMG_SIZE, IMG_SIZE);
      drawDownCtxNN.drawImage(drawCanvasNN, 0, 0, IMG_SIZE, IMG_SIZE);

      const imgData = drawDownCtxNN.getImageData(0, 0, IMG_SIZE, IMG_SIZE);
      const data = imgData.data;
      const pixels = new Float32Array(IMG_SIZE * IMG_SIZE);

      const features = new Array(VIS_IN).fill(0);
      const counts = new Array(VIS_IN).fill(0);
      const blocksPerSide = 4;
      const blockW = IMG_SIZE / blocksPerSide;
      const blockH = IMG_SIZE / blocksPerSide;

      for (let y = 0; y < IMG_SIZE; y++) {
        for (let x = 0; x < IMG_SIZE; x++) {
          const idx = (y * IMG_SIZE + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          const v = (r + g + b) / 3 / 255;
          pixels[y * IMG_SIZE + x] = v;

          const bx = Math.floor(x / blockW);
          const by = Math.floor(y / blockH);
          const bi = by * blocksPerSide + bx;
          if (bi >= 0 && bi < VIS_IN) {
            features[bi] += v;
            counts[bi]  += 1;
          }
        }
      }

      for (let i = 0; i < VIS_IN; i++) {
        features[i] = counts[i] > 0 ? features[i] / counts[i] : 0;
      }

      return { inputVec: features, pixels };
    }

    function renderPixelGridNN(pixels) {
      if (!pixelGridCtx || !pixelGridCanvas || !pixels) return;
      const size = IMG_SIZE;
      const w = pixelGridCanvas.width;
      const h = pixelGridCanvas.height;
      const cellW = w / size;
      const cellH = h / size;

      pixelGridCtx.clearRect(0, 0, w, h);
      pixelGridCtx.fillStyle = "#000000";
      pixelGridCtx.fillRect(0, 0, w, h);

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const v = clamp(pixels[y * size + x] || 0, 0, 1);
          const c = Math.round(v * 255);
          pixelGridCtx.fillStyle = `rgb(${c},${c},${c})`;
          pixelGridCtx.fillRect(x * cellW, y * cellH, cellW + 0.5, cellH + 0.5);
        }
      }

      pixelGridCtx.strokeStyle = "rgba(15,23,42,0.7)";
      pixelGridCtx.lineWidth = 0.5;
      for (let x = 0; x <= size; x++) {
        const px = x * cellW;
        pixelGridCtx.beginPath();
        pixelGridCtx.moveTo(px, 0);
        pixelGridCtx.lineTo(px, h);
        pixelGridCtx.stroke();
      }
      for (let y = 0; y <= size; y++) {
        const py = y * cellH;
        pixelGridCtx.beginPath();
        pixelGridCtx.moveTo(0, py);
        pixelGridCtx.lineTo(w, py);
        pixelGridCtx.stroke();
      }
    }

    async function updateFromDrawingNN() {
      const pack = extractFeaturesFromDrawing();
      if (!pack) return;
      const { inputVec, pixels } = pack;

      // aggiorna SEMPRE la griglia dei pixel 32×32
      renderPixelGridNN(pixels);

      if (!model || !activationModel) {
        return;
      }

      drawPredictBusy = true;
      const tensor = tf.tensor4d(pixels, [1, IMG_SIZE, IMG_SIZE, 1], "float32");
      try {
        const pred = activationModel.predict(tensor);
        if (!Array.isArray(pred) || pred.length < 4) {
          throw new Error("activationModel non ha restituito 4 output");
        }
        const [h1T, h2T, h3T, outT] = pred;
        const h1Vals = await h1T.data();
        const h2Vals = await h2T.data();
        const h3Vals = await h3T.data();
        const outVals = await outT.data();
        h1T.dispose();
        h2T.dispose();
        h3T.dispose();
        outT.dispose();
        tensor.dispose();

        visActs.input   = inputVec;
        visActs.hidden1 = Array.from(h1Vals);
        visActs.hidden2 = Array.from(h2Vals);
        visActs.hidden3 = Array.from(h3Vals);
        visActs.output  = Array.from(outVals);

        drawNetworkNN(visActs);
        updateDrawOutputPanel(visActs.output);
      } catch (e) {
        console.error("Errore updateFromDrawingNN:", e);
        devLog("Errore updateFromDrawingNN: " + e.message);
        try { tensor.dispose(); } catch {}
      } finally {
        drawPredictBusy = false;
      }
    }

    function setupNNCanvas() {
      nnCanvasEl = document.getElementById("nnCanvas");
      if (!nnCanvasEl) return;
      const rect = nnCanvasEl.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const w = (rect.width || 260) * dpr;
      const h = (rect.height || 260) * dpr;
      nnCanvasEl.width  = w;
      nnCanvasEl.height = h;
      nnCtx = nnCanvasEl.getContext("2d");
      nnCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      computeNNPositions(rect.width || 260, rect.height || 260);
      drawNetworkNN(visActs);
    }

    window.addEventListener("resize", () => {
      setupNNCanvas();
    });

    function computeNNPositions(width, height) {
      const marginX = 50;
      const xIn   = marginX;
      const xH1   = width * 0.30;
      const xH2   = width * 0.50;
      const xH3   = width * 0.70;
      const xOut  = width - marginX;
      nnPositions.input   = makeLayerPositionsNN(VIS_IN,  xIn,  height);
      nnPositions.hidden1 = makeLayerPositionsNN(VIS_H1, xH1, height);
      nnPositions.hidden2 = makeLayerPositionsNN(VIS_H2, xH2, height);
      nnPositions.hidden3 = makeLayerPositionsNN(VIS_H3, xH3, height);
      nnPositions.output  = makeLayerPositionsNN(VIS_OUT, xOut, height);
    }

    function makeLayerPositionsNN(nNodes, x, canvasHeight) {
      const marginY = 30;
      const usableH = Math.max(10, canvasHeight - 2 * marginY);
      const step = nNodes > 1 ? usableH / (nNodes - 1) : 0;
      const arr = [];
      for (let i = 0; i < nNodes; i++) {
        arr.push({ x, y: marginY + i * step });
      }
      return arr;
    }

    function computeNorms(values, isOutput) {
      const n = values ? values.length : 0;
      const norms = new Array(n).fill(0);
      if (!n) return norms;
      let min = Infinity, max = -Infinity;
      if (isOutput) {
        min = 0;
        max = 1;
      } else {
        for (let i = 0; i < n; i++) {
          const v = values[i];
          if (!Number.isFinite(v)) continue;
          if (v < min) min = v;
          if (v > max) max = v;
        }
        if (!Number.isFinite(min)) min = 0;
        if (!Number.isFinite(max)) max = min + 1;
        if (max <= min) max = min + 1;
      }
      const span = max - min;
      for (let i = 0; i < n; i++) {
        let lin;
        if (isOutput) {
          lin = clamp(values[i] ?? 0, 0, 1);
        } else {
          const v = values[i];
          if (!Number.isFinite(v)) lin = 0;
          else lin = clamp((v - min) / span, 0, 1);
        }
        // mappa esponenziale per aumentare il contrasto
        const expo = 1 - Math.exp(-3 * lin);
        norms[i] = clamp(expo, 0, 1);
      }
      return norms;
    }

    function drawNetworkNN(acts) {
      if (!nnCtx || !nnCanvasEl) return;
      const width  = nnCanvasEl.clientWidth  || nnCanvasEl.width;
      const height = nnCanvasEl.clientHeight || nnCanvasEl.height;

      nnCtx.clearRect(0, 0, width, height);
      nnCtx.fillStyle = "#050814";
      nnCtx.fillRect(0, 0, width, height);

      const cx = width / 2;
      const cy = height / 2;
      const grad = nnCtx.createRadialGradient(cx, cy, 10, cx, cy, width * 0.8);
      grad.addColorStop(0, "rgba(79,156,255,0.25)");
      grad.addColorStop(1, "rgba(5,8,20,0)");
      nnCtx.fillStyle = grad;
      nnCtx.fillRect(0, 0, width, height);

      const normsIn  = computeNorms(acts.input,  false);
      const normsH1  = computeNorms(acts.hidden1, false);
      const normsH2  = computeNorms(acts.hidden2, false);
      const normsH3  = computeNorms(acts.hidden3, false);
      const normsOut = computeNorms(acts.output, true);

      // edges per ogni layer della rete effettiva
      drawEdgesNN(nnCtx, nnPositions.input,   nnPositions.hidden1, normsIn);
      drawEdgesNN(nnCtx, nnPositions.hidden1, nnPositions.hidden2, normsH1);
      drawEdgesNN(nnCtx, nnPositions.hidden2, nnPositions.hidden3, normsH2);
      drawEdgesNN(nnCtx, nnPositions.hidden3, nnPositions.output,  normsH3);

      // nodi
      drawNodesNN(nnCtx, nnPositions.input,   acts.input,   normsIn,  null, false, "input (4×4 blocchi)");
      drawNodesNN(nnCtx, nnPositions.hidden1, acts.hidden1, normsH1,  null, false, `hidden1 (${VIS_H1})`);
      drawNodesNN(nnCtx, nnPositions.hidden2, acts.hidden2, normsH2,  null, false, `hidden2 (${VIS_H2})`);
      drawNodesNN(nnCtx, nnPositions.hidden3, acts.hidden3, normsH3,  null, false, `hidden3 (${VIS_H3})`);

      const outLabels = Array.from({ length: VIS_OUT }, (_, i) => String(i));
      drawNodesNN(nnCtx, nnPositions.output, acts.output, normsOut, outLabels, true, "output (cifre)");
    }

    function drawEdgesNN(ctx, srcPos, dstPos, srcNorms) {
      if (!srcPos || !dstPos) return;
      for (let i = 0; i < srcPos.length; i++) {
        const src = srcPos[i];
        const a = srcNorms[i] ?? 0;
        const alpha = 0.03 + 0.75 * Math.pow(a, 1.5);
        ctx.strokeStyle = `rgba(148,163,184,${alpha.toFixed(3)})`;
        ctx.lineWidth = 1;
        for (let j = 0; j < dstPos.length; j++) {
          const dst = dstPos[j];
          ctx.beginPath();
          ctx.moveTo(src.x, src.y);
          ctx.lineTo(dst.x, dst.y);
          ctx.stroke();
        }
      }
    }

    function drawNodesNN(ctx, positions, values, norms, labels, isOutput, layerLabel) {
      if (!positions) return;
      const radius = 8;
      let bestIdx = -1;
      if (isOutput && values && values.length) {
        bestIdx = 0;
        for (let i = 1; i < values.length; i++) {
          if ((values[i] ?? 0) > (values[bestIdx] ?? 0)) bestIdx = i;
        }
      }

      for (let i = 0; i < positions.length; i++) {
        const { x, y } = positions[i];
        const n = norms[i] ?? 0;
        const c = Math.round(clamp(n, 0, 1) * 255);
        const fillColor = `rgb(${c},${c},${c})`;
        const isBest = isOutput && i === bestIdx;

        if (n > 0.02) {
          const glowR = radius + 4 + n * 10;
          const g = ctx.createRadialGradient(x, y, radius * 0.3, x, y, glowR);
          g.addColorStop(0, `rgba(255,255,255,${(0.4 * n).toFixed(3)})`);
          g.addColorStop(1, "rgba(5,8,20,0)");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(x, y, glowR, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.lineWidth = isBest ? 2 : 1;
        ctx.strokeStyle = isBest ? "#ffd166" : "#e5e7eb";
        ctx.stroke();

        if (labels && labels[i] !== undefined) {
          ctx.fillStyle = c > 150 ? "#000000" : "#f9fafb";
          ctx.font = "9px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(labels[i], x, y);
        }
      }

      if (positions.length && layerLabel) {
        const x = positions[0].x;
        let yTop = positions[0].y;
        for (let i = 1; i < positions.length; i++) {
          if (positions[i].y < yTop) yTop = positions[i].y;
        }
        ctx.fillStyle = "#9ca4c7";
        ctx.font = "10px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillText(layerLabel, x, yTop - 6);
      }
    }

    function updateDrawOutputPanel(probs) {
      const container = document.getElementById("draw-output-panel");
      if (!container || !probs) return;
      let maxIdx = 0;
      for (let i = 1; i < probs.length; i++) {
        if (probs[i] > probs[maxIdx]) maxIdx = i;
      }
      let html = "";
      for (let i = 0; i < probs.length; i++) {
        const p = probs[i] || 0;
        const isBest = i === maxIdx;
        const widthPercent = Math.max(2, p * 100);
        html +=
          `<div class="prob-row ${isBest ? "best" : ""}">
            <div class="prob-label">${i}</div>
            <div class="prob-bar-wrap">
              <div class="prob-bar" style="width:${widthPercent.toFixed(1)}%;"></div>
            </div>
            <div class="prob-val">${p.toFixed(3)}</div>
          </div>`;
      }
      container.innerHTML = html;
    }

    /******************************************************************
     * TRAINING SUL DISEGNO UTENTE
     ******************************************************************/
    async function trainOnDrawingExample() {
      if (!model) return;

      const labelInput = document.getElementById("draw-label-input");
      const statusEl   = document.getElementById("draw-train-status");
      if (!labelInput || !statusEl) return;

      const labelStr = labelInput.value.trim();
      const label = Number(labelStr);
      if (!Number.isInteger(label) || label < 0 || label >= NUM_CLASSES) {
        statusEl.textContent = "L'etichetta deve essere un intero tra 0 e 9.";
        statusEl.style.color = "#f87171";
        return;
      }

      const pack = extractFeaturesFromDrawing();
      if (!pack) {
        statusEl.textContent = "Nessun disegno da usare.";
        statusEl.style.color = "#f87171";
        return;
      }
      const { pixels } = pack;

      let sum = 0;
      for (let i = 0; i < pixels.length; i++) sum += pixels[i];
      if (sum <= 0.01) {
        statusEl.textContent = "Il disegno è quasi vuoto, niente da apprendere.";
        statusEl.style.color = "#f97316";
        return;
      }

      const xs = tf.tensor4d(pixels, [1, IMG_SIZE, IMG_SIZE, 1], "float32");
      const ysIdx = tf.tensor1d([label], "int32");
      const ys = tf.oneHot(ysIdx, NUM_CLASSES);
      ysIdx.dispose();

      statusEl.textContent = "Aggiorno il modello locale…";
      statusEl.style.color = "#93c5fd";

      while (trainingBusy) {
        await sleep(30);
      }
      trainingBusy = true;

      const t0 = performance.now();
      try {
        const { shapes, arrays: arraysBefore } = extractWeights();

        const history = await model.fit(xs, ys, {
          epochs: 1,
          batchSize: 1,
          shuffle: false,
          verbose: 0
        });
        const loss = history.history.loss[0];

        const { arrays: arraysAfter } = extractWeights();

        let sumSq = 0;
        let count = 0;
        for (let t = 0; t < arraysBefore.length; t++) {
          const a0 = arraysBefore[t];
          const a1 = arraysAfter[t];
          for (let i = 0; i < a0.length; i++) {
            const d = a1[i] - a0[i];
            sumSq += d * d;
            count++;
          }
        }
        const stepVar = sumSq / Math.max(1, count);
        if (!Number.isFinite(stepVar) || stepVar <= 0) {
          if (localGradVar == null) localGradVar = 1e-4;
        } else {
          if (localGradVar == null) localGradVar = stepVar;
          else localGradVar = (1 - VAR_BETA) * localGradVar + VAR_BETA * stepVar;
        }
        localGradVarCount++;

        localSteps   += 1;
        localSamples += 1;
        lastTrainLoss = loss;

        const batchMs = performance.now() - t0;
        if (avgBatchMs === 0) avgBatchMs = batchMs;
        else avgBatchMs = avgBatchMs * 0.9 + batchMs * 0.1;

        pushChartPoint(localLossChart, loss);

        if (snapshotsColRefGlobal && clientDocRef) {
          const q = quantizeWeights(shapes, arraysAfter);
          const snapshotDoc = {
            clientId,
            createdAt: serverTimestamp(),
            iter: localSteps,
            localSamples,
            localTrainLoss: lastTrainLoss,
            localValLoss: lastValLoss,
            gradVar: localGradVar,
            gradVarCount: localGradVarCount,
            shapes: q.shapes,
            scales: q.scales,
            quantArrays: q.quantArrays
          };
          await addDoc(snapshotsColRefGlobal, snapshotDoc);

          await setDoc(clientDocRef, {
            lastSeen: serverTimestamp(),
            localSteps,
            localSamples,
            localValLoss: lastValLoss,
            gradVar: localGradVar,
            gradVarCount: localGradVarCount
          }, { merge: true });
        }

        updateLocalUI();
        statusEl.textContent =
          `Aggiunto al training (label ${label}, loss ${Number.isFinite(loss) ? loss.toFixed(3) : "n/d"})`;
        statusEl.style.color = "#4ade80";

        devLog(
          `Training da disegno utente: label=${label}, loss=${Number.isFinite(loss) ? loss.toFixed(4) : "NaN"}`
        );

        updateFromDrawingNN();
      } catch (e) {
        console.error("Errore trainOnDrawingExample:", e);
        devLog("Errore trainOnDrawingExample: " + e.message);
        statusEl.textContent = "Errore durante il training.";
        statusEl.style.color = "#f87171";
      } finally {
        xs.dispose();
        ys.dispose();
        trainingBusy = false;
      }
    }

    /******************************************************************
     * PANIC BUTTON
     ******************************************************************/
    async function localPanicReset() {
      if (!confirm("Reset locale: azzera il modello e le statistiche su questo dispositivo. Procedere?")) {
        return;
      }
      devLog("Panic reset richiesto.");
      try {
        localStorage.removeItem(META_STORAGE_KEY);
      } catch {}
      if (activationModel) {
        activationModel.dispose();
        activationModel = null;
      }
      if (model) model.dispose();
      model = buildModel();
      initActivationModel();
      localSteps = 0;
      localSamples = 0;
      lastTrainLoss = null;
      lastValLoss   = null;
      localGradVar  = null;
      localGradVarCount = 0;
      avgBatchMs = 0;
      await saveLocalMeta();
      updateLocalUI();
      document.getElementById("tester-result").textContent =
        "Modello locale resettato. Il training riparte da zero.";
      updateFromDrawingNN();
    }

    /******************************************************************
     * FIREBASE SUBSCRIPTIONS
     ******************************************************************/
    function subscribeClientsAndSnapshots(db, roomId) {
      const clientsRef = collection(db, "rooms", roomId, "clients");
      const snapsRef   = collection(db, "rooms", roomId, "snapshots");

      onSnapshot(clientsRef, (snap) => {
        clientsState.clear();
        const now = Date.now();
        snap.forEach(docSnap => {
          const d = docSnap.data();
          let lastSeen = d.lastSeen && d.lastSeen.toMillis ? d.lastSeen.toMillis() : null;
          const offline = lastSeen && (now - lastSeen > OFFLINE_THRESHOLD_MS);
          if (offline) return;
          clientsState.set(docSnap.id, {
            localSteps: d.localSteps ?? 0,
            localSamples: d.localSamples ?? 0,
            localValLoss: d.localValLoss ?? null,
            gradVar: d.gradVar ?? null,
            gradVarCount: d.gradVarCount ?? 0,
            lastSeen
          });
        });
        updateCombineUI();
        drawMesh();
      });

      const qSnaps = query(snapsRef, orderBy("createdAt", "desc"), limit(20));
      onSnapshot(qSnaps, (snap) => {
        const docs = [];
        snap.forEach(docSnap => {
          docs.push({
            id: docSnap.id,
            data: docSnap.data(),
            localTimestamp: Date.now()
          });
        });
        recentSnapshots = docs;
      });

      return { clientsRef, snapsRef };
    }

    async function bootstrapFromBestPeerIfAny(snapsRef) {
      try {
        const qBoot = query(snapsRef, orderBy("createdAt", "desc"), limit(50));
        const snap = await getDocs(qBoot);
        if (snap.empty) {
          devLog("Bootstrap: nessun snapshot remoto disponibile.");
          return;
        }

        let bestData = null;
        let bestScore = -Infinity;

        snap.forEach(docSnap => {
          const d = docSnap.data();
          if (!d || !d.clientId || d.clientId === clientId) return;

          const valLoss = d.localValLoss;
          const steps   = d.iter || d.localSteps || 0;

          if (valLoss == null || !Number.isFinite(valLoss)) return;

          const score = -valLoss + 1e-4 * steps;
          if (score > bestScore) {
            bestScore = score;
            bestData = d;
          }
        });

        if (!bestData) {
          devLog("Bootstrap: nessun candidato valido trovato.");
          return;
        }

        const { shapes, arrays } = dequantizeSnapshot(bestData);
        applyWeightsToModel(shapes, arrays);

        if (bestData.gradVar != null && Number.isFinite(bestData.gradVar)) {
          localGradVar = bestData.gradVar;
        }
        if (bestData.gradVarCount != null) {
          localGradVarCount = bestData.gradVarCount;
        }

        await saveLocalMeta();
        hasLocalMeta = true;

        let lossStr = "n/d";
        if (typeof bestData.localValLoss === "number" && Number.isFinite(bestData.localValLoss)) {
          lossStr = bestData.localValLoss.toFixed(4);
        }
        devLog(`Bootstrap: modello copiato da client ${bestData.clientId}, valLoss=${lossStr}`);
      } catch (e) {
        console.error("Errore bootstrapFromBestPeerIfAny:", e);
        devLog("Errore bootstrapFromBestPeerIfAny: " + e.message);
      }
    }

    /******************************************************************
     * ATC TRAINING LOOP
     ******************************************************************/
    async function trainingLoop(clientRef, snapshotsColRef) {
      devLog("Training loop ATC avviato.");
      let combineValCounter = 0;

      while (true) {
        if (trainingBusy) {
          await sleep(50);
          continue;
        }
        trainingBusy = true;

        let xs = null, ys = null;
        const t0 = performance.now();
        try {
          // --- ADAPT STEP: ψ_i = w_i - μ ∇J_i(w_i) ---
          const { shapes, arrays: arraysBefore } = extractWeights();
          const batch = await loadBatchFromManifest(trainManifest, TRAIN_BATCH_SIZE);
          xs = batch.xs;
          ys = batch.ys;

          const history = await model.fit(xs, ys, {
            epochs: 1,
            batchSize: TRAIN_BATCH_SIZE,
            shuffle: true,
            verbose: 0
          });
          const t1 = performance.now();

          xs.dispose();
          ys.dispose();
          xs = null; ys = null;

          const loss = history.history.loss[0];
          if (!Number.isFinite(loss)) {
            devLog("Loss NaN/Inf. Resetto modello locale.");
            if (activationModel) {
              activationModel.dispose();
              activationModel = null;
            }
            model.dispose();
            model = buildModel();
            initActivationModel();
            localSteps = 0;
            localSamples = 0;
            lastTrainLoss = null;
            lastValLoss   = null;
            localGradVar  = null;
            localGradVarCount = 0;
            await saveLocalMeta();
            updateLocalUI();
            await sleep(TRAINING_PAUSE_MS);
            throw new Error("Loss NaN/Inf durante trainingLoop");
          }

          localSteps   += 1;
          localSamples += TRAIN_BATCH_SIZE;
          lastTrainLoss = loss;

          const { arrays: arraysAfter } = extractWeights(); // ψ_i

          // Stima varianza update (surrogato grad noise)
          let sumSq = 0;
          let count = 0;
          for (let t = 0; t < arraysBefore.length; t++) {
            const a0 = arraysBefore[t];
            const a1 = arraysAfter[t];
            for (let i = 0; i < a0.length; i++) {
              const d = a1[i] - a0[i];
              sumSq += d*d;
              count++;
            }
          }
          const stepVar = sumSq / Math.max(1, count);
          if (!Number.isFinite(stepVar) || stepVar <= 0) {
            if (localGradVar == null) localGradVar = 1e-4;
          } else {
            if (localGradVar == null) localGradVar = stepVar;
            else localGradVar = (1 - VAR_BETA) * localGradVar + VAR_BETA * stepVar;
          }
          localGradVarCount++;

          const batchMs = t1 - t0;
          if (avgBatchMs === 0) avgBatchMs = batchMs;
          else avgBatchMs = avgBatchMs*0.9 + batchMs*0.1;

          pushChartPoint(localLossChart, loss);
          devLog(`Adapt k=${localSteps}, loss=${loss.toFixed(4)}, stepVar=${stepVar.toExponential(2)}, gradVar=${localGradVar != null ? localGradVar.toExponential(2) : "n/d"}`);

          // Pubblica ψ_i come snapshot per i vicini
          const q = quantizeWeights(shapes, arraysAfter);
          const snapshotDoc = {
            clientId,
            createdAt: serverTimestamp(),
            iter: localSteps,
            localSamples,
            localTrainLoss: lastTrainLoss,
            localValLoss: lastValLoss,
            gradVar: localGradVar,
            gradVarCount: localGradVarCount,
            shapes: q.shapes,
            scales: q.scales,
            quantArrays: q.quantArrays
          };
          await addDoc(snapshotsColRef, snapshotDoc);

          // Aggiorna stato client (per la mesh)
          await setDoc(clientRef, {
            lastSeen: serverTimestamp(),
            localSteps,
            localSamples,
            localValLoss: lastValLoss,
            gradVar: localGradVar,
            gradVarCount: localGradVarCount
          }, { merge: true });

          // --- COMBINE STEP: w_i = Σ a_ij ψ_j ---
          const now = Date.now();
          const byClient = new Map();
          for (const snap of recentSnapshots) {
            const d = snap.data;
            if (!d.clientId) continue;
            const cid = d.clientId;
            if (cid === clientId) continue;
            const ts = d.createdAt && d.createdAt.toMillis
              ? d.createdAt.toMillis()
              : snap.localTimestamp || now;
            const prev = byClient.get(cid);
            if (!prev || ts > prev.ts) {
              byClient.set(cid, { snap, ts });
            }
          }

          const neighborsInfo = [];
          for (const [cid, {snap}] of byClient.entries()) {
            const d = snap.data;
            const { shapes: neighShapes, arrays: neighArrays } = dequantizeSnapshot(d);
            if (JSON.stringify(neighShapes) !== JSON.stringify(shapes)) {
              continue;
            }
            const gVar   = d.gradVar;
            const gCount = d.gradVarCount || 0;
            const valLoss = d.localValLoss;
            neighborsInfo.push({
              clientId: cid,
              arrays: neighArrays,
              gradVar: gVar,
              gradVarCount: gCount,
              valLoss
            });
          }

          const S = [];
          const EPS_GVAR = 1e-12;

          const selfGamma = (localGradVar != null && Number.isFinite(localGradVar) && localGradVar > 0)
            ? localGradVar
            : 1e-4;
          S.push({
            clientId: clientId,
            arrays: arraysAfter,
            gamma: selfGamma,
            isSelf: true
          });

          for (const n of neighborsInfo) {
            let gVar = n.gradVar;
            if (gVar == null || !Number.isFinite(gVar) || gVar <= 0) {
              gVar = selfGamma;
            }
            S.push({
              clientId: n.clientId,
              arrays: n.arrays,
              gamma: gVar,
              isSelf: false
            });
          }

          let combinedArrays = arraysAfter.map(a => a.slice());
          lastEdgeWeights.clear();
          let neighborWeightSum = 0;

          if (S.length > 1) {
            let anyValidGamma = false;
            for (const s of S) {
              if (s.gamma > 0) { anyValidGamma = true; break; }
            }
            let weights = new Map();
            if (!anyValidGamma) {
              const w = 1 / S.length;
              S.forEach(s => weights.set(s.clientId, w));
            } else {
              let sumR = 0;
              for (const s of S) {
                const rj = 1 / (EPS_GVAR + s.gamma);
                sumR += rj;
                weights.set(s.clientId, rj);
              }
              for (const [cid, rj] of weights.entries()) {
                weights.set(cid, rj / sumR);
              }
            }

            combinedArrays = arraysAfter.map(() => null);
            for (let t = 0; t < arraysAfter.length; t++) {
              const len = arraysAfter[t].length;
              combinedArrays[t] = new Float32Array(len);
            }

            for (const s of S) {
              const wj = weights.get(s.clientId);
              if (wj == null) continue;
              for (let t = 0; t < combinedArrays.length; t++) {
                const out = combinedArrays[t];
                const src = s.arrays[t];
                for (let i = 0; i < out.length; i++) {
                  out[i] += wj * src[i];
                }
              }
              if (!s.isSelf) {
                lastEdgeWeights.set(s.clientId, wj);
                neighborWeightSum += wj;
              }
            }

            devLog(
              `Combine k=${localSteps}: nodi S=${S.length}, peso vicini=${neighborWeightSum.toFixed(3)}`
            );
          } else {
            devLog(`Combine k=${localSteps}: solo self (nessun vicino maturo).`);
          }

          sanitizeWeightArrays(combinedArrays);
          applyWeightsToModel(shapes, combinedArrays);
          await saveLocalMeta(combinedArrays, shapes);

          if (neighborsInfo.length > 0 && (localSteps % 5 === 0)) {
            try {
              await gossipAlignIfDivergent(shapes, combinedArrays, neighborsInfo);
            } catch (e) {
              console.error("Errore gossipAlignIfDivergent:", e);
              devLog("Errore gossipAlignIfDivergent: " + e.message);
            }
          }

          lastCombineTime        = Date.now();
          lastCombineNeighbors   = S.length - 1;
          lastCombineNeighborAvg = neighborWeightSum;

          combineValCounter++;
          if (valManifest && valManifest.items && valManifest.items.length &&
              combineValCounter % COMBINE_VAL_EVERY === 0) {
            const vb = await loadBatchFromManifest(valManifest, VAL_BATCH_SIZE);
            const evalRes = await model.evaluate(vb.xs, vb.ys, {
              batchSize: VAL_BATCH_SIZE,
              verbose: 0
            });
            let lossT;
            if (Array.isArray(evalRes)) lossT = evalRes[0];
            else lossT = evalRes;
            const arr = await lossT.data();
            const vLoss = arr[0];
            lossT.dispose();
            vb.xs.dispose();
            vb.ys.dispose();
            if (Number.isFinite(vLoss)) {
              lastCombineValLoss = vLoss;
              pushChartPoint(globalLossChart, vLoss);
              devLog(`Val loss post-combine=${vLoss.toFixed(4)}`);
            }
          }

          updateLocalUI();
          updateCombineUI();
          drawMesh();
          await sleep(TRAINING_PAUSE_MS);
        } catch (e) {
          if (xs) xs.dispose();
          if (ys) ys.dispose();
          console.error("Errore trainingLoop ATC:", e);
          devLog("Errore trainingLoop ATC: " + e.message);
          await sleep(TRAINING_PAUSE_MS);
        } finally {
          trainingBusy = false;
        }
      }
    }

    async function gossipAlignIfDivergent(shapes, localArrays, neighborsInfo) {
      if (!neighborsInfo.length) return;

      const selfVal = lastValLoss;
      let best = null;
      let bestScore = -Infinity;

      let normSelfSq = 0;
      for (let t = 0; t < localArrays.length; t++) {
        const arr = localArrays[t];
        for (let i = 0; i < arr.length; i++) {
          normSelfSq += arr[i] * arr[i];
        }
      }
      const normSelf = Math.sqrt(normSelfSq + 1e-12);

      for (const n of neighborsInfo) {
        const neighArr = n.arrays;
        let normNeighSq = 0;
        for (let t = 0; t < neighArr.length; t++) {
          const arr = neighArr[t];
          for (let i = 0; i < arr.length; i++) {
            normNeighSq += arr[i] * arr[i];
          }
        }
        const normNeigh = Math.sqrt(normNeighSq + 1e-12);

        let distSq = 0;
        for (let t = 0; t < localArrays.length; t++) {
          const a = localArrays[t];
          const b = neighArr[t];
          if (a.length !== b.length) continue;
          for (let i = 0; i < a.length; i++) {
            const d = a[i] - b[i];
            distSq += d * d;
          }
        }
        const dist = Math.sqrt(distSq + 1e-12);
        const normDist = dist / (normSelf + normNeigh);

        let valDiff = null;
        if (selfVal != null && n.valLoss != null &&
            Number.isFinite(selfVal) && Number.isFinite(n.valLoss)) {
          valDiff = Math.abs(selfVal - n.valLoss);
        }

        const DIVERGENCE_THRESHOLD = 0.4;
        const VAL_DIFF_MAX = 0.15;

        const diverging = normDist > DIVERGENCE_THRESHOLD;
        const similarPerf = (valDiff == null) ? true : (valDiff < VAL_DIFF_MAX);

        if (diverging && similarPerf) {
          const gamma = (n.gradVar != null && Number.isFinite(n.gradVar) && n.gradVar > 0)
            ? n.gradVar
            : 1e-4;
          const score = normDist / (1 + (valDiff || 0.0)) / (1e-8 + gamma);
          if (score > bestScore) {
            bestScore = score;
            best = { neighbor: n, normDist, valDiff };
          }
        }
      }

      if (!best) {
        return;
      }

      const n = best.neighbor;
      devLog(
        `[GOSSIP] Divergenza rilevata con ${n.clientId}: dist=${best.normDist.toFixed(3)}, ` +
        `valDiff=${best.valDiff != null ? best.valDiff.toFixed(3) : "n/d"} → eseguo Sinkhorn (gossip)`
      );

      const kernelShape = shapes[IDX_DH_KERNEL];
      const localKernel  = localArrays[IDX_DH_KERNEL];
      const neighKernel  = n.arrays[IDX_DH_KERNEL];

      const localMat = denseHiddenKernelToNeuronMatrix(localKernel, kernelShape);
      const neighMat = denseHiddenKernelToNeuronMatrix(neighKernel, kernelShape);

      const H = Math.min(localMat.length, neighMat.length);
      if (!H) return;

      const C = computeCostMatrix(localMat.slice(0, H), neighMat.slice(0, H));
      const { P } = runSinkhornGossip(C, 0.1, 5);
      const perm = argmaxPermutation(P);

      permuteHiddenInPlace(localArrays, shapes, perm);

      sanitizeWeightArrays(localArrays);
      applyWeightsToModel(shapes, localArrays);
      await saveLocalMeta(localArrays, shapes);

      devLog(
        `[GOSSIP] Allineamento completato con ${n.clientId}: ` +
        `perm[0..4]=${perm.slice(0, Math.min(5, perm.length)).join(",")}`
      );
    }

    /******************************************************************
     * ENTRYPOINT
     ******************************************************************/
    async function start() {
      devLog("Start app.");
      initCharts();
      initTesterUI();
      initBattery();
      resizeMeshCanvas();
      updateLocalUI();
      updateCombineUI();

      const { trainManifest: tm, valManifest: vm } = await loadMnistManifests();
      trainManifest = tm;
      valManifest   = vm;
      populateSampleGallery();

      try {
        await signInAnonymously(auth);
        devLog("Login anonimo Firebase OK.");
      } catch (e) {
        console.error("Errore signInAnonymously:", e);
        devLog("Errore signInAnonymously: " + e.message);
        return;
      }

      onAuthStateChanged(auth, async (user) => {
        if (!user) return;
        currentUser = user;
        clientId = user.uid;
        document.getElementById("client-pill").textContent =
          "Client: " + clientId.slice(0, 6) + "…";
        devLog("Auth: clientId=" + clientId);

        await loadLocalModelOrInit();
        initActivationModel();
        initNNVisualizer();

        document.getElementById("model-pill").textContent = "Modello: pronto";
        document.getElementById("test-btn").disabled = false;
        updateLocalUI();

        const roomRef = doc(db, "rooms", ROOM_ID);
        await setDoc(roomRef, {
          name: "ATC MNIST Demo",
          createdAt: serverTimestamp()
        }, { merge: true });

        const clientRef = doc(db, "rooms", ROOM_ID, "clients", clientId);
        clientDocRef = clientRef;
        await setDoc(clientRef, {
          lastSeen: serverTimestamp(),
          localSteps,
          localSamples,
          localValLoss: lastValLoss,
          gradVar: localGradVar,
          gradVarCount: localGradVarCount
        }, { merge: true });

        setInterval(() => {
          if (!clientId || !clientDocRef) return;
          setDoc(clientDocRef, { lastSeen: serverTimestamp() }, { merge: true });
        }, 30000);

        const { snapsRef } = subscribeClientsAndSnapshots(db, ROOM_ID);
        snapshotsColRefGlobal = snapsRef;

        if (!hasLocalMeta) {
          await bootstrapFromBestPeerIfAny(snapsRef);
          updateLocalUI();
        }

        trainingLoop(clientRef, snapsRef);
      });

      document.getElementById("panic-btn").addEventListener("click", () => {
        localPanicReset().catch(e => console.error("Errore panic:", e));
      });
    }

    start().catch(e => {
      console.error("Errore start():", e);
      devLog("Errore start(): " + e.message);
    });
  </script>
</body>
</html>
