<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>ATC Distributed MNIST Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background-color: #050814;
      color: #f0f4ff;
      --card-bg: #151a2c;
      --accent: #4f9cff;
      --accent-soft: rgba(79, 156, 255, 0.15);
    }
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      padding: 0.8rem 1rem;
      border-bottom: 1px solid #20263a;
    }
    header h1 {
      margin: 0;
      font-size: 1.1rem;
    }
    header p {
      margin: 0.2rem 0 0;
      font-size: 0.75rem;
      color: #9ca4c7;
    }
    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      grid-template-rows: auto auto 1fr;
      gap: 0.8rem;
      padding: 0.8rem;
      box-sizing: border-box;
    }
    section {
      background: var(--card-bg);
      border-radius: 0.75rem;
      padding: 0.7rem 0.9rem;
      box-shadow: 0 0 0 1px #1f2840;
      min-width: 0;
    }
    section h2 {
      margin: 0 0 0.4rem;
      font-size: 0.95rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .pill {
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: var(--accent-soft);
      color: #4f9cff;
    }
    .ghost-btn {
      background: transparent;
      border: 1px solid #ff6b6b;
      color: #ff6b6b;
      border-radius: 999px;
      padding: 0.15rem 0.6rem;
      font-size: 0.7rem;
      cursor: pointer;
      margin-right: 0.4rem;
    }
    .ghost-btn:hover {
      background: rgba(255,107,107,0.15);
    }
    #local-section { grid-column: 1 / 2; grid-row: 1 / 2; }
    #combine-section { grid-column: 2 / 3; grid-row: 1 / 2; }
    #mesh-section { grid-column: 1 / 2; grid-row: 2 / 4; }
    #tester-section { grid-column: 2 / 3; grid-row: 2 / 4; }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.4rem;
      margin-bottom: 0.6rem;
    }
    .stat {
      background: #1a2136;
      border-radius: 0.6rem;
      padding: 0.35rem 0.45rem;
      font-size: 0.8rem;
    }
    .stat .label { color: #9ca4c7; font-size: 0.7rem; }
    .stat .value { font-weight: 600; margin-top: 0.1rem; }
    .stat .sub { font-size: 0.7rem; color: #8891b3; margin-top: 0.1rem; }

    canvas.loss-chart {
      width: 100%;
      height: 120px;
    }

    #meshCanvas {
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #1b2340, #050814);
      border-radius: 0.6rem;
      border: 1px solid #222a42;
      box-sizing: border-box;
      cursor: pointer;
    }
    #node-details {
      font-size: 0.8rem;
      background: #101628;
      border-radius: 0.5rem;
      padding: 0.45rem;
      margin-top: 0.4rem;
    }

    #tester-section input[type="file"] {
      font-size: 0.8rem;
      margin-bottom: 0.4rem;
    }
    #tester-section button {
      background: var(--accent);
      border: none;
      border-radius: 0.5rem;
      padding: 0.35rem 0.7rem;
      color: #0b1020;
      font-size: 0.8rem;
      cursor: pointer;
    }
    #tester-section button:disabled { opacity: 0.6; cursor: default; }
    #tester-result {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      white-space: pre-line;
    }
    .sample-thumb {
      width: 40px;
      height: 40px;
      border-radius: 0.3rem;
      border: 1px solid #303857;
      cursor: pointer;
      image-rendering: pixelated;
      background: #000;
      object-fit: cover;
    }
    .sample-thumb.selected {
      border-color: #4f9cff;
      box-shadow: 0 0 0 2px rgba(79,156,255,0.5);
    }

    #dev-log {
      margin-top: 0.4rem;
      max-height: 160px;
      overflow: auto;
      font-size: 0.7rem;
      background: #101628;
      border-radius: 0.5rem;
      padding: 0.4rem;
      border: 1px solid #232b45;
    }

    footer {
      padding: 0.5rem 0.8rem;
      font-size: 0.7rem;
      color: #7b84a7;
      border-top: 1px solid #20263a;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto auto;
      }
      #local-section, #combine-section, #mesh-section, #tester-section {
        grid-column: 1 / 2;
        grid-row: auto;
      }
      #meshCanvas { height: 260px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>ATC Distributed MNIST Demo</h1>
    <p>
      Ogni nodo esegue <strong>Adapt–Then–Combine</strong> su MNIST PNG:
      SGD locale + fusione pesata dei pesi con i vicini (trust + Sinkhorn).
    </p>
  </header>

  <main>
    <!-- STATO LOCALE -->
    <section id="local-section">
      <h2>
        Nodo locale
        <span>
          <button id="panic-btn" class="ghost-btn">Reset locale</button>
          <span class="pill" id="client-pill">Client: …</span>
        </span>
      </h2>
      <div class="stat-grid">
        <div class="stat">
          <div class="label">Backend TF.js</div>
          <div class="value" id="tf-backend">–</div>
          <div class="sub" id="tf-version">–</div>
        </div>
        <div class="stat">
          <div class="label">Passi di training</div>
          <div class="value" id="local-steps">0</div>
          <div class="sub" id="local-samples">0 samples</div>
        </div>
        <div class="stat">
          <div class="label">Loss locale</div>
          <div class="value" id="local-loss">–</div>
          <div class="sub" id="local-valloss">validation: –</div>
        </div>
        <div class="stat">
          <div class="label">Batch time</div>
          <div class="value" id="batch-ms">–</div>
          <div class="sub" id="throughput">–</div>
        </div>
        <div class="stat">
          <div class="label">Batteria</div>
          <div class="value" id="battery-level">–</div>
          <div class="sub" id="battery-status">API non disponibile</div>
        </div>
        <div class="stat">
          <div class="label">Hidden units</div>
          <div class="value" id="hidden-size">32</div>
          <div class="sub">rete condivisa, stessi pesi per tutti</div>
        </div>
      </div>
      <canvas id="localLossChart" class="loss-chart"></canvas>
    </section>

    <!-- STATO COMBINE / FUSIONE -->
    <section id="combine-section">
      <h2>
        Fusione ATC
        <span class="pill" id="clients-count">Nodi: 0</span>
      </h2>
      <div class="stat-grid">
        <div class="stat">
          <div class="label">Ultima fusione</div>
          <div class="value" id="combine-age">–</div>
          <div class="sub" id="combine-neighbors">–</div>
        </div>
        <div class="stat">
          <div class="label">Trust medio vicini</div>
          <div class="value" id="combine-trust">–</div>
          <div class="sub" id="combine-trust-extra">message test accuracy</div>
        </div>
        <div class="stat">
          <div class="label">Qualità Sinkhorn</div>
          <div class="value" id="combine-sinkhorn">–</div>
          <div class="sub">allineamento neuroni nascosti</div>
        </div>
      </div>
      <canvas id="globalLossChart" class="loss-chart"></canvas>
    </section>

    <!-- MESH -->
    <section id="mesh-section">
      <h2>
        Rete dei nodi
        <span class="pill">clicca per info</span>
      </h2>
      <canvas id="meshCanvas"></canvas>
      <div id="node-details">
        <strong>Dettagli nodo selezionato</strong>
        <div id="node-details-body">Nessun nodo selezionato.</div>
      </div>

      <div id="dev-log">
        <div id="dev-log-body">Developer log…</div>
      </div>
    </section>

    <!-- TESTER -->
    <section id="tester-section">
      <h2>
        Tester modello locale
        <span class="pill" id="model-pill">Modello: inizializzazione…</span>
      </h2>
      <p style="font-size:0.78rem;color:#9ca4c7;">
        Carica una piccola immagine (sarà ridimensionata a 28×28, scala di grigi)
        oppure clicca su cifre dal test set MNIST. La rete che risponde è
        <strong>quella locale</strong>, che incorpora sia training sui tuoi dati
        sia fusioni ATC con i vicini affidabili.
      </p>
      <input type="file" id="test-image-input" accept="image/*" />
      <button id="test-btn" disabled>Testa immagine</button>
      <div id="tester-result">In attesa che il training locale parta…</div>

      <div style="margin-top:0.7rem;">
        <div style="font-size:0.75rem;color:#9ca4c7;margin-bottom:0.2rem;">
          Oppure prova con alcune cifre di esempio (dal test set MNIST):
        </div>
        <div id="sample-images-container" style="display:flex;flex-wrap:wrap;gap:0.3rem;"></div>
      </div>

      <hr style="border-color:#20263a;margin:0.8rem 0;"/>
      <p style="font-size:0.72rem;color:#7b84a7;">
        Architettura:
        <code>conv8 → conv16 → flatten → dense32 → softmax10</code><br/>
        Algoritmo: <strong>Adapt–Then–Combine</strong> con:
        trust (mini-validation su questo nodo), allineamento Sinkhorn
        dei neuroni nascosti e decadimento temporale degli snapshot.
      </p>
    </section>
  </main>

  <footer>
    Prototipo puramente client-side. Sostituisci il <code>firebaseConfig</code> con il tuo
    progetto Firebase e abilita Firestore + auth anonima. Dataset: MNIST PNG, repo
    <code>rasbt/mnist-pngs</code> (MIT).
  </footer>

  <!-- Canvas nascosto per caricare / ridimensionare immagini -->
  <canvas id="imageLoaderCanvas" style="display:none;"></canvas>

  <!-- LIBRERIE -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script type="module">
    /******************************************************************
     * IMPORT FIREBASE MODULAR API
     ******************************************************************/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
    import {
      getFirestore,
      doc,
      setDoc,
      collection,
      addDoc,
      onSnapshot,
      query,
      orderBy,
      limit,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";
    import {
      getAuth,
      signInAnonymously,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

    /******************************************************************
     * CONFIGURAZIONE FIREBASE
     * (sostituisci con le tue chiavi, NON committare quelle reali)
     ******************************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyDUYL3b05b0RoyNMYCy9GZRtDs-4SBb-AI",
      authDomain: "twin-dungeon.firebaseapp.com",
      projectId: "twin-dungeon",
      storageBucket: "twin-dungeon.firebasestorage.app",
      messagingSenderId: "141719069384",
      appId: "1:141719069384:web:8cf21db6eddcadea0d3bfd",
      measurementId: "G-8L8Y6CL8M2"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    /******************************************************************
     * COSTANTI MODELLO / TRAINING
     ******************************************************************/
    const ROOM_ID = "atc-mnist-room";

    const IMG_SIZE = 28;
    const NUM_CHANNELS = 1;
    const NUM_CLASSES = 10;
    const HIDDEN_UNITS = 32;

    const TRAIN_BATCH_SIZE = 16;
    const VAL_BATCH_SIZE = 32;
    const TRAINING_PAUSE_MS = 800;

    const VALIDATION_EVERY_STEPS = 8;
    const SNAPSHOT_EVERY_STEPS   = 16;
    const COMBINE_INTERVAL_MS    = 7000;
    const COMBINE_WARMUP_STEPS   = 64;

    const MAX_TRAIN_ITEMS = 12000;
    const MAX_VAL_ITEMS   = 2000;

    const MNIST_ROOT = "https://raw.githubusercontent.com/rasbt/mnist-pngs/main/";
    const MNIST_TRAIN_CSV = MNIST_ROOT + "train.csv";
    const MNIST_TEST_CSV  = MNIST_ROOT + "test.csv";

    const META_STORAGE_KEY = "atc-mnist-meta-v1";

    const TRUST_VAL_BATCH = 32;
    const TRUST_CACHE_TTL_MS = 10 * 60 * 1000; // 10 minuti

    const OFFLINE_THRESHOLD_MS = 60 * 1000;

    /******************************************************************
     * STATO GLOBALE
     ******************************************************************/
    let currentUser = null;
    let clientId = null;

    let model = null;

    let trainManifest = null;
    let valManifest = null;

    let localSteps = 0;
    let localSamples = 0;
    let lastTrainLoss = null;
    let lastValLoss = null;
    let avgBatchMs = 0;

    let lastCombineTime = null;
    let lastCombineNeighbors = 0;
    let lastCombineTrustMean = null;
    let lastCombineSinkhornMean = null;
    let lastCombineValLoss = null;

    const clientsState = new Map();
    let recentSnapshots = [];

    let batteryInfo = null;

    let localLossChart = null;
    let globalLossChart = null;

    let meshNodesLayout = new Map();

    const trustScores = new Map(); // clientId -> { score, ts }

    const devLogBuffer = [];
    const DEV_LOG_MAX = 200;

    /******************************************************************
     * DEV LOG
     ******************************************************************/
    function devLog(msg) {
      const ts = new Date().toLocaleTimeString();
      const line = `[${ts}] ${msg}`;
      devLogBuffer.unshift(line);
      if (devLogBuffer.length > DEV_LOG_MAX) devLogBuffer.pop();
      const el = document.getElementById("dev-log-body");
      if (el) el.innerHTML = devLogBuffer.join("<br>");
      console.log("[DEV]", msg);
    }

    /******************************************************************
     * UTILITY VARIE
     ******************************************************************/
    function sleep(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    function clamp(v, min, max) {
      return Math.min(Math.max(v, min), max);
    }

    function formatMs(ms) {
      if (ms == null) return "–";
      return ms.toFixed(1) + " ms/batch";
    }

    /******************************************************************
     * MNIST PNG: CARICAMENTO CSV → MANIFEST BILANCIATO
     ******************************************************************/
    async function fetchCsvLines(url, maxLines = null) {
      devLog("Scarico CSV: " + url);
      const resp = await fetch(url);
      if (!resp.ok) throw new Error("Impossibile caricare CSV: " + url);
      const text = await resp.text();
      const all = text.trim().split(/\r?\n/);
      const header = all.shift();
      if (!header.toLowerCase().startsWith("filepath")) {
        console.warn("Header CSV inatteso:", header);
      }
      const lines = maxLines ? all.slice(0, maxLines) : all;
      return lines;
    }

    function parseMnistCsvLines(lines) {
      const items = [];
      for (const line of lines) {
        if (!line) continue;
        const parts = line.split(",");
        if (parts.length < 2) continue;
        const fp = parts[0].trim();
        const lbl = parseInt(parts[1].trim(), 10);
        if (Number.isNaN(lbl)) continue;
        items.push({ url: MNIST_ROOT + fp, label: lbl });
      }
      return items;
    }

    function balancedSampleByLabel(items, maxTotal) {
      const shuffled = items.slice();
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      const perClass = Math.max(1, Math.floor(maxTotal / NUM_CLASSES));
      const counts = new Array(NUM_CLASSES).fill(0);
      const out = [];
      for (const it of shuffled) {
        if (out.length >= maxTotal) break;
        if (it.label < 0 || it.label >= NUM_CLASSES) continue;
        if (counts[it.label] >= perClass) continue;
        counts[it.label]++;
        out.push(it);
      }
      return out;
    }

    async function loadMnistManifests() {
      const [trainLines, testLines] = await Promise.all([
        fetchCsvLines(MNIST_TRAIN_CSV, null),
        fetchCsvLines(MNIST_TEST_CSV,  null)
      ]);
      const trainAll = parseMnistCsvLines(trainLines);
      const valAll   = parseMnistCsvLines(testLines);

      const trainItems = balancedSampleByLabel(trainAll, MAX_TRAIN_ITEMS);
      const valItems   = balancedSampleByLabel(valAll,   MAX_VAL_ITEMS);

      devLog(`MNIST manifest: train=${trainItems.length}, val=${valItems.length}`);

      return {
        trainManifest: { classes: Array.from({length: NUM_CLASSES}, (_,i)=>String(i)), items: trainItems },
        valManifest:   { classes: Array.from({length: NUM_CLASSES}, (_,i)=>String(i)), items: valItems }
      };
    }

    /******************************************************************
     * MODELLO CNN (UNICO MODEL PER NODO)
     ******************************************************************/
    function buildModel() {
      const m = tf.sequential();
      m.add(tf.layers.conv2d({
        inputShape: [IMG_SIZE, IMG_SIZE, NUM_CHANNELS],
        filters: 8,
        kernelSize: 3,
        activation: "relu",
        padding: "same",
        name: "conv1"
      }));
      m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
      m.add(tf.layers.conv2d({
        filters: 16,
        kernelSize: 3,
        activation: "relu",
        padding: "same",
        name: "conv2"
      }));
      m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
      m.add(tf.layers.flatten());
      m.add(tf.layers.dense({
        units: HIDDEN_UNITS,
        activation: "relu",
        name: "dense_hidden"
      }));
      m.add(tf.layers.dense({
        units: NUM_CLASSES,
        activation: "softmax",
        name: "dense_out"
      }));
      m.compile({
        optimizer: tf.train.adam(0.001),
        loss: "categoricalCrossentropy",
        metrics: ["accuracy"]
      });
      return m;
    }

    /******************************************************************
     * PESI: ESTRAZIONE, APPLICAZIONE, QUANTIZZAZIONE
     ******************************************************************/
    function extractLocalWeights() {
      const tensors = model.getWeights(); // NON si fa dispose qui
      const shapes = tensors.map(t => t.shape);
      const arrays = tensors.map(t => Float32Array.from(t.dataSync()));
      return { shapes, arrays };
    }

    function applyWeightsToModel(shapes, arrays) {
      const tensors = shapes.map((shape, idx) =>
        tf.tensor(arrays[idx], shape, "float32")
      );
      model.setWeights(tensors);
      tensors.forEach(t => t.dispose());
    }

    function quantizeWeights(shapes, arrays) {
      const scales = [];
      const quantMaps = {};
      for (let idx = 0; idx < arrays.length; idx++) {
        const arr = arrays[idx];
        let maxAbs = 0;
        for (let i = 0; i < arr.length; i++) {
          const a = Math.abs(arr[i]);
          if (a > maxAbs) maxAbs = a;
        }
        const scale = maxAbs > 0 ? maxAbs / 127.0 : 1e-8;
        const q = new Int8Array(arr.length);
        for (let i = 0; i < arr.length; i++) {
          q[i] = Math.max(-127, Math.min(127, Math.round(arr[i] / scale)));
        }
        scales.push(scale);
        quantMaps[idx] = Array.from(q); // niente array annidate
      }

      const shapesMap = {};
      shapes.forEach((sh, idx) => {
        shapesMap[idx] = sh;
      });

      return { shapes: shapesMap, scales, quantArrays: quantMaps };
    }

    function dequantizeSnapshot(snapData) {
      const shapesMap = snapData.shapes || {};
      const quantMap  = snapData.quantArrays || {};
      const scales    = snapData.scales || [];

      const indices = Object.keys(quantMap)
        .map(k => Number(k))
        .sort((a,b) => a-b);

      const shapes = [];
      const arrays = [];

      for (const idx of indices) {
        const shape = Array.isArray(shapesMap) ? shapesMap[idx] : shapesMap[idx];
        const qArr  = quantMap[idx];
        const scale = scales[idx];
        if (!shape || !qArr || scale == null) continue;
        const fArr = new Float32Array(qArr.length);
        for (let i = 0; i < qArr.length; i++) {
          fArr[i] = qArr[i] * scale;
        }
        shapes.push(shape);
        arrays.push(fArr);
      }
      return { shapes, arrays };
    }

    function sanitizeWeightArrays(arrays) {
      let changed = false;
      for (const arr of arrays) {
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i];
          if (!Number.isFinite(v)) {
            arr[i] = 0;
            changed = true;
          }
        }
      }
      if (changed) devLog("Sanitizzazione pesi combinati: NaN/Inf → 0");
    }

    /******************************************************************
     * SALVATAGGIO LOCALE (LOCALSTORAGE)
     ******************************************************************/
    async function saveLocalMeta() {
      let weightsPayload = null;
      try {
        const { shapes, arrays } = extractLocalWeights();
        weightsPayload = {
          shapes,
          arrays: arrays.map(a => Array.from(a))
        };
      } catch (e) {
        console.warn("Errore estrazione pesi per salvataggio:", e);
        devLog("Errore estrazione pesi per salvataggio: " + e.message);
      }
      const meta = {
        weights: weightsPayload,
        localSteps,
        localSamples,
        lastTrainLoss,
        lastValLoss
      };
      try {
        localStorage.setItem(META_STORAGE_KEY, JSON.stringify(meta));
      } catch (e) {
        console.warn("Errore salvataggio meta localStorage:", e);
        devLog("Errore salvataggio meta localStorage: " + e.message);
      }
    }

    async function loadLocalModelOrInit() {
      model = buildModel();
      try {
        const metaStr = localStorage.getItem(META_STORAGE_KEY);
        if (!metaStr) {
          devLog("Nessun meta locale, modello nuovo.");
          return;
        }
        const meta = JSON.parse(metaStr);
        if (!meta.weights || !meta.weights.shapes || !meta.weights.arrays) {
          devLog("Meta incompleto, uso modello nuovo.");
          return;
        }
        const shapes = meta.weights.shapes;
        const arrays = meta.weights.arrays;
        if (shapes.length !== arrays.length) {
          devLog("Meta pesi incoerente, modello nuovo.");
          return;
        }
        const tensors = shapes.map((shape, idx) =>
          tf.tensor(arrays[idx], shape, "float32")
        );
        model.setWeights(tensors);
        tensors.forEach(t => t.dispose());

        localSteps    = meta.localSteps || 0;
        localSamples  = meta.localSamples || 0;
        lastTrainLoss = meta.lastTrainLoss ?? null;
        lastValLoss   = meta.lastValLoss ?? null;
        devLog(`Meta locale ripristinato: steps=${localSteps}, samples=${localSamples}`);
      } catch (e) {
        console.warn("Errore loadLocalModelOrInit:", e);
        devLog("Errore loadLocalModelOrInit: " + e.message);
      }
    }

    /******************************************************************
     * IMAGE → TENSOR
     ******************************************************************/
    async function loadImageAsTensor(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          const canvas = document.getElementById("imageLoaderCanvas");
          const ctx = canvas.getContext("2d");
          canvas.width = IMG_SIZE;
          canvas.height = IMG_SIZE;
          ctx.drawImage(img, 0, 0, IMG_SIZE, IMG_SIZE);
          let imgTensor = tf.browser.fromPixels(canvas, NUM_CHANNELS);
          imgTensor = tf.tidy(() => imgTensor.toFloat().div(255.0));
          const batched = imgTensor.expandDims(0);
          imgTensor.dispose();
          resolve(batched);
        };
        img.onerror = (e) => reject(e);
        img.src = url;
      });
    }

    async function loadBatchFromManifest(manifest, batchSize) {
      const items = manifest.items;
      if (!items || !items.length) throw new Error("Manifest vuoto");
      const xsList = [];
      const ysList = [];
      for (let i = 0; i < batchSize; i++) {
        const idx = Math.floor(Math.random() * items.length);
        const item = items[idx];
        const x = await loadImageAsTensor(item.url);
        xsList.push(x);
        ysList.push(item.label);
      }
      const xs = tf.concat(xsList, 0);
      xsList.forEach(t => t.dispose());
      const ysIdx = tf.tensor1d(ysList, "int32");
      const ys = tf.oneHot(ysIdx, NUM_CLASSES);
      ysIdx.dispose();
      return { xs, ys };
    }

    /******************************************************************
     * SINKHORN PER ALLINEAMENTO NEURONI NASCOSTI
     ******************************************************************/
    // Indici tensori: 0 conv1/kernel, 1 conv1/bias, 2 conv2/kernel, 3 conv2/bias,
    // 4 dense_hidden/kernel, 5 dense_hidden/bias, 6 dense_out/kernel, 7 dense_out/bias
    const IDX_DH_KERNEL = 4;
    const IDX_DH_BIAS   = 5;
    const IDX_DO_KERNEL = 6;

    function denseHiddenKernelToNeuronMatrix(flatArray, shape) {
      const inDim = shape[0];
      const H = shape[1];
      const mat = [];
      for (let h = 0; h < H; h++) {
        const neuron = [];
        for (let i = 0; i < inDim; i++) {
          const idx = i * H + h;
          neuron.push(flatArray[idx]);
        }
        mat.push(neuron);
      }
      return mat;
    }

    function euclideanDistance(a, b) {
      let sum = 0;
      for (let i = 0; i < a.length; i++) {
        const d = a[i] - b[i];
        sum += d * d;
      }
      return Math.sqrt(sum);
    }

    function computeCostMatrix(localMat, neighMat) {
      const H = Math.min(localMat.length, neighMat.length);
      const C = [];
      for (let i = 0; i < H; i++) {
        const row = [];
        for (let j = 0; j < H; j++) {
          row.push(euclideanDistance(localMat[i], neighMat[j]));
        }
        C.push(row);
      }
      return C;
    }

    function runSinkhorn(costMatrix, baseEpsFactor = 0.25, iterations = 20) {
      const H = costMatrix.length;
      if (!H) return { P: [] };

      let sum = 0, cnt = 0;
      for (let i = 0; i < H; i++) {
        for (let j = 0; j < H; j++) {
          sum += costMatrix[i][j];
          cnt++;
        }
      }
      const meanC = cnt > 0 ? sum / cnt : 1.0;
      const epsilon = Math.max(meanC * baseEpsFactor, 1e-6);

      const P = [];
      for (let i = 0; i < H; i++) {
        const row = [];
        for (let j = 0; j < H; j++) {
          row.push(Math.exp(-costMatrix[i][j] / epsilon));
        }
        P.push(row);
      }

      for (let it = 0; it < iterations; it++) {
        // normalizza righe
        for (let i = 0; i < H; i++) {
          let s = 0;
          for (let j = 0; j < H; j++) s += P[i][j];
          if (s > 0) {
            for (let j = 0; j < H; j++) P[i][j] /= s;
          }
        }
        // normalizza colonne
        for (let j = 0; j < H; j++) {
          let s = 0;
          for (let i = 0; i < H; i++) s += P[i][j];
          if (s > 0) {
            for (let i = 0; i < H; i++) P[i][j] /= s;
          }
        }
      }

      return { P };
    }

    function argmaxPermutation(P) {
      const H = P.length;
      const perm = new Array(H).fill(0);
      const used = new Array(H).fill(false);
      for (let i = 0; i < H; i++) {
        let bestJ = 0;
        let best = -Infinity;
        for (let j = 0; j < H; j++) {
          if (!used[j] && P[i][j] > best) {
            best = P[i][j];
            bestJ = j;
          }
        }
        perm[i] = bestJ;
        used[bestJ] = true;
      }
      return perm;
    }

    function alignNeighborHidden(shapes, arraysLocal, arraysNeigh) {
      const kernelShape = shapes[IDX_DH_KERNEL];
      const localKernel = arraysLocal[IDX_DH_KERNEL];
      const neighKernel = arraysNeigh[IDX_DH_KERNEL];
      const localMat = denseHiddenKernelToNeuronMatrix(localKernel, kernelShape);
      const neighMat = denseHiddenKernelToNeuronMatrix(neighKernel, kernelShape);

      const H = Math.min(localMat.length, neighMat.length);
      if (!H) return { arraysAligned: arraysNeigh, quality: 0 };

      const C = computeCostMatrix(localMat.slice(0, H), neighMat.slice(0, H));
      const { P } = runSinkhorn(C, 0.25, 20);
      const perm = argmaxPermutation(P);

      let diagSum = 0;
      for (let i = 0; i < H; i++) diagSum += P[i][perm[i]];
      const meanDiag = diagSum / H;
      const uniformDiag = 1.0 / H;
      let q = (meanDiag - uniformDiag) / (1 - uniformDiag + 1e-6);
      q = clamp(q, 0, 1);

      devLog(`Sinkhorn: H=${H}, meanDiag=${meanDiag.toFixed(3)}, q=${q.toFixed(3)}`);

      const aligned = arraysNeigh.map(a => a.slice());
      const neighKernelFlat = aligned[IDX_DH_KERNEL];
      const neighBiasFlat   = aligned[IDX_DH_BIAS];
      const neighOutKernel  = aligned[IDX_DO_KERNEL];
      const inDim = kernelShape[0];
      const Hmax = kernelShape[1];

      for (let h = 0; h < H; h++) {
        const srcH = perm[h];
        if (srcH === h) continue;
        for (let i = 0; i < inDim; i++) {
          const idx1 = i * Hmax + h;
          const idx2 = i * Hmax + srcH;
          const tmp = neighKernelFlat[idx1];
          neighKernelFlat[idx1] = neighKernelFlat[idx2];
          neighKernelFlat[idx2] = tmp;
        }
        const tmpb = neighBiasFlat[h];
        neighBiasFlat[h] = neighBiasFlat[srcH];
        neighBiasFlat[srcH] = tmpb;

        const outShape = shapes[IDX_DO_KERNEL]; // [Hmax, NUM_CLASSES]
        const numClasses = outShape[1];
        for (let c = 0; c < numClasses; c++) {
          const idx1 = h * numClasses + c;
          const idx2 = srcH * numClasses + c;
          const tmp2 = neighOutKernel[idx1];
          neighOutKernel[idx1] = neighOutKernel[idx2];
          neighOutKernel[idx2] = tmp2;
        }
      }

      return { arraysAligned: aligned, quality: q };
    }

    /******************************************************************
     * TRUST: MINI-VALIDATION (MESSAGE TEST TASK)
     ******************************************************************/
    async function computeTrustScoreForSnapshot(snap) {
      if (!valManifest || !valManifest.items || !valManifest.items.length) {
        devLog("Trust: valManifest non pronto → trust neutrale=0.5");
        return 0.5;
      }
      const d = snap.data || {};
      const peerId = d.clientId || "unknown";

      devLog(`Trust: valuto snapshot ${snap.id} da client ${peerId}`);

      const { shapes, arrays } = dequantizeSnapshot(d);
      try {
        const m = buildModel();
        const tensors = arrays.map((arr, idx) =>
          tf.tensor(arr, shapes[idx], "float32")
        );
        m.setWeights(tensors);
        tensors.forEach(t => t.dispose());

        const B = Math.min(TRUST_VAL_BATCH, valManifest.items.length);
        const batch = await loadBatchFromManifest(valManifest, B);
        const evalRes = await m.evaluate(batch.xs, batch.ys, {
          batchSize: VAL_BATCH_SIZE,
          verbose: 0
        });
        let lossT, accT;
        if (Array.isArray(evalRes)) {
          lossT = evalRes[0];
          accT  = evalRes[1];
        } else {
          lossT = evalRes;
          accT  = null;
        }

        let acc = null;
        if (accT) {
          const accArr = await accT.data();
          acc = accArr[0];
          accT.dispose();
        }
        const lossArr = await lossT.data();
        const loss = lossArr[0];
        lossT.dispose();

        batch.xs.dispose();
        batch.ys.dispose();
        m.dispose();

        if (acc == null || !Number.isFinite(acc)) {
          devLog(`Trust: acc=null/NaN per snapshot ${snap.id} → trust=0`);
          return 0;
        }

        const trust = clamp((acc - 0.10) / 0.90, 0, 1);
        devLog(`Trust: acc=${(acc*100).toFixed(1)}%, loss=${loss.toFixed(3)} → trust=${trust.toFixed(3)}`);
        return trust;
      } catch (e) {
        console.warn("Errore computeTrustScoreForSnapshot:", e);
        devLog("Trust: errore su snapshot " + snap.id + ": " + e.message);
        return 0;
      }
    }

    async function getTrustScoreForSnapshot(snap) {
      const d = snap.data || {};
      const peerId = d.clientId || "unknown";
      const now = Date.now();
      const existing = trustScores.get(peerId);
      if (existing && now - existing.ts < TRUST_CACHE_TTL_MS) {
        return existing.score;
      }
      const score = await computeTrustScoreForSnapshot(snap);
      trustScores.set(peerId, { score, ts: now });
      return score;
    }

    /******************************************************************
     * TRAINING LOOP (ADAPT) - UNICO MODELLO
     ******************************************************************/
    function pushChartPoint(chart, value) {
      if (!chart || value == null || !Number.isFinite(value)) return;
      chart.data.labels.push("");
      chart.data.datasets[0].data.push(value);
      if (chart.data.labels.length > 60) {
        chart.data.labels.shift();
        chart.data.datasets[0].data.shift();
      }
      chart.update("quiet");
    }

    async function trainingLoop(clientRef, snapshotsColRef) {
      devLog("Training loop avviato.");
      while (true) {
        let xs=null, ys=null;
        const t0 = performance.now();
        try {
          const batch = await loadBatchFromManifest(trainManifest, TRAIN_BATCH_SIZE);
          xs = batch.xs;
          ys = batch.ys;

          const history = await model.fit(xs, ys, {
            epochs: 1,
            batchSize: TRAIN_BATCH_SIZE,
            shuffle: true,
            verbose: 0
          });
          const t1 = performance.now();

          xs.dispose();
          ys.dispose();
          xs = null; ys = null;

          const loss = history.history.loss[0];
          if (!Number.isFinite(loss)) {
            devLog("Loss NaN/Inf. Resetto modello locale.");
            model.dispose();
            model = buildModel();
            localSteps = 0;
            localSamples = 0;
            lastTrainLoss = null;
            lastValLoss = null;
            await saveLocalMeta();
            updateLocalUI();
            await sleep(TRAINING_PAUSE_MS);
            continue;
          }

          localSteps += 1;
          localSamples += TRAIN_BATCH_SIZE;
          lastTrainLoss = loss;

          const batchMs = t1 - t0;
          if (avgBatchMs === 0) avgBatchMs = batchMs;
          else avgBatchMs = avgBatchMs*0.9 + batchMs*0.1;

          pushChartPoint(localLossChart, loss);
          devLog(`Train step=${localSteps}, loss=${loss.toFixed(4)}, samples=${localSamples}`);

          if (localSteps % VALIDATION_EVERY_STEPS === 0) {
            try {
              const vb = await loadBatchFromManifest(valManifest, VAL_BATCH_SIZE);
              const evalRes = await model.evaluate(vb.xs, vb.ys, {
                batchSize: VAL_BATCH_SIZE,
                verbose: 0
              });
              let lossT;
              if (Array.isArray(evalRes)) lossT = evalRes[0];
              else lossT = evalRes;
              const arr = await lossT.data();
              const vLoss = arr[0];
              lossT.dispose();
              vb.xs.dispose();
              vb.ys.dispose();
              if (Number.isFinite(vLoss)) {
                lastValLoss = vLoss;
                devLog(`Val loss=${vLoss.toFixed(4)}`);
              }
            } catch (e) {
              console.warn("Errore validation:", e);
              devLog("Errore validation: " + e.message);
            }
          }

          if (localSteps % SNAPSHOT_EVERY_STEPS === 0) {
            const { shapes, arrays } = extractLocalWeights();
            const q = quantizeWeights(shapes, arrays);
            const snapshotDoc = {
              clientId,
              createdAt: serverTimestamp(),
              localSteps,
              localSamples,
              localValLoss: lastValLoss,
              shapes: q.shapes,
              scales: q.scales,
              quantArrays: q.quantArrays
            };
            await addDoc(snapshotsColRef, snapshotDoc);
            await saveLocalMeta();
            devLog("Snapshot pubblicato.");
          }

          await setDoc(clientRef, {
            lastSeen: serverTimestamp(),
            localSteps,
            localSamples,
            localValLoss: lastValLoss
          }, { merge: true });

          updateLocalUI();
          await sleep(TRAINING_PAUSE_MS);
        } catch (e) {
          if (xs) xs.dispose();
          if (ys) ys.dispose();
          console.error("Errore trainingLoop:", e);
          devLog("Errore trainingLoop: " + e.message);
          await sleep(TRAINING_PAUSE_MS);
        }
      }
    }

    /******************************************************************
     * COMBINE LOOP (THEN-COMBINE): AGGIORNA *MODEL* CON SNAPSHOT VICINI
     ******************************************************************/
    async function combineLoop() {
      devLog("Combine loop ATC avviato.");
      while (true) {
        await sleep(COMBINE_INTERVAL_MS);
        try {
          if (!model || !recentSnapshots.length || localSteps < COMBINE_WARMUP_STEPS) {
            continue;
          }
          const { shapes, arrays: arraysLocal } = extractLocalWeights();
          const combinedArrays = arraysLocal.map(a => a.slice());

          let used = 0;
          let trustAccum = 0;
          let sinkAccum = 0;

          const now = Date.now();
          const candidates = recentSnapshots.filter(
            s => s.data && s.data.clientId !== clientId
          );

          for (const snap of candidates) {
            const d = snap.data;
            const createdAt = d.createdAt && d.createdAt.toMillis ? d.createdAt.toMillis() : snap.localTimestamp || now;
            const ageSec = (now - createdAt) / 1000;
            const timeFactor = Math.exp(-ageSec / 120); // 2 minuti

            if (timeFactor < 0.1) {
              devLog(`Combine: snapshot ${snap.id} troppo vecchio (${ageSec.toFixed(1)}s) → skip.`);
              continue;
            }

            const trust = await getTrustScoreForSnapshot(snap);
            if (trust < 0.2) {
              devLog(`Combine: snapshot ${snap.id} trust basso (${trust.toFixed(3)}) → skip.`);
              continue;
            }

            const neigh = dequantizeSnapshot(d);
            if (JSON.stringify(neigh.shapes) !== JSON.stringify(shapes)) {
              devLog(`Combine: snapshot ${snap.id} shape diversa → skip.`);
              continue;
            }

            const { arraysAligned, quality } = alignNeighborHidden(
              shapes,
              arraysLocal,
              neigh.arrays
            );
            if (!Number.isFinite(quality)) {
              devLog(`Combine: snapshot ${snap.id} quality NaN → skip.`);
              continue;
            }

            const score = trust * quality * timeFactor;
            if (score < 0.15) {
              devLog(`Combine: snapshot ${snap.id} score basso (${score.toFixed(3)}) → skip.`);
              continue;
            }

            const stepAlpha = clamp(0.08 * score, 0.01, 0.10);

            for (let t = 0; t < combinedArrays.length; t++) {
              const base = arraysLocal[t];
              const neighArr = arraysAligned[t];
              const out = combinedArrays[t];
              for (let i = 0; i < out.length; i++) {
                out[i] += stepAlpha * (neighArr[i] - base[i]);
              }
            }

            used += 1;
            trustAccum += trust;
            sinkAccum += quality;
            devLog(
              `Combine step con ${snap.id}: trust=${trust.toFixed(3)}, quality=${quality.toFixed(
                3
              )}, age=${ageSec.toFixed(1)}s, alpha=${stepAlpha.toFixed(3)}`
            );
          }

          if (used === 0) {
            continue;
          }

          sanitizeWeightArrays(combinedArrays);
          applyWeightsToModel(shapes, combinedArrays);
          await saveLocalMeta();

          lastCombineTime = Date.now();
          lastCombineNeighbors = used;
          lastCombineTrustMean = trustAccum / used;
          lastCombineSinkhornMean = sinkAccum / used;

          // Valutazione rapida dopo fusione
          if (valManifest && valManifest.items && valManifest.items.length) {
            const vb = await loadBatchFromManifest(valManifest, VAL_BATCH_SIZE);
            const evalRes = await model.evaluate(vb.xs, vb.ys, {
              batchSize: VAL_BATCH_SIZE,
              verbose: 0
            });
            let lossT;
            if (Array.isArray(evalRes)) lossT = evalRes[0];
            else lossT = evalRes;
            const arr = await lossT.data();
            const vLoss = arr[0];
            lossT.dispose();
            vb.xs.dispose();
            vb.ys.dispose();
            if (Number.isFinite(vLoss)) {
              lastCombineValLoss = vLoss;
              pushChartPoint(globalLossChart, vLoss);
              devLog(`Combine: valLoss dopo fusione=${vLoss.toFixed(4)}`);
            }
          }

          updateCombineUI();
        } catch (e) {
          console.error("Errore combineLoop:", e);
          devLog("Errore combineLoop: " + e.message);
        }
      }
    }

    /******************************************************************
     * FIREBASE: CLIENTS + SNAPSHOTS
     ******************************************************************/
    function subscribeClientsAndSnapshots(db, roomId) {
      const clientsRef = collection(db, "rooms", roomId, "clients");
      const snapsRef   = collection(db, "rooms", roomId, "snapshots");

      onSnapshot(clientsRef, (snap) => {
        clientsState.clear();
        const now = Date.now();
        snap.forEach(docSnap => {
          const d = docSnap.data();
          let lastSeen = d.lastSeen && d.lastSeen.toMillis ? d.lastSeen.toMillis() : null;
          const offline = lastSeen && (now - lastSeen > OFFLINE_THRESHOLD_MS);
          if (offline) return;
          clientsState.set(docSnap.id, {
            localSteps: d.localSteps ?? 0,
            localSamples: d.localSamples ?? 0,
            localValLoss: d.localValLoss ?? null,
            lastSeen
          });
        });
        updateCombineUI();
        drawMesh();
      });

      const qSnaps = query(snapsRef, orderBy("createdAt", "desc"), limit(10));
      onSnapshot(qSnaps, (snap) => {
        const docs = [];
        snap.forEach(docSnap => {
          docs.push({
            id: docSnap.id,
            data: docSnap.data(),
            localTimestamp: Date.now()
          });
        });
        recentSnapshots = docs;
      });

      return { clientsRef, snapsRef };
    }

    /******************************************************************
     * UI: CHARTS, STATO, MESH
     ******************************************************************/
    function initCharts() {
      const ctxL = document.getElementById("localLossChart").getContext("2d");
      localLossChart = new Chart(ctxL, {
        type: "line",
        data: { labels: [], datasets: [{ label: "Loss locale", data: [], tension: 0.2 }] },
        options: {
          responsive: true,
          scales: { x: { display: false }, y: { display: true } },
          plugins: { legend: { display: false } }
        }
      });

      const ctxG = document.getElementById("globalLossChart").getContext("2d");
      globalLossChart = new Chart(ctxG, {
        type: "line",
        data: { labels: [], datasets: [{ label: "Val loss dopo combine", data: [], tension: 0.2 }] },
        options: {
          responsive: true,
          scales: { x: { display: false }, y: { display: true } },
          plugins: { legend: { display: false } }
        }
      });
    }

    function updateLocalUI() {
      document.getElementById("tf-backend").textContent = tf.getBackend() || "–";
      document.getElementById("tf-version").textContent =
        "TF.js " + (tf.version ? tf.version.tfjs : "");

      document.getElementById("local-steps").textContent = localSteps.toString();
      document.getElementById("local-samples").textContent = `${localSamples} samples`;
      document.getElementById("local-loss").textContent =
        lastTrainLoss != null && Number.isFinite(lastTrainLoss)
          ? lastTrainLoss.toFixed(4)
          : "–";
      document.getElementById("local-valloss").textContent =
        lastValLoss != null && Number.isFinite(lastValLoss)
          ? "validation: " + lastValLoss.toFixed(4)
          : "validation: –";

      document.getElementById("batch-ms").textContent = formatMs(avgBatchMs);
      const thr = avgBatchMs > 0 ? (TRAIN_BATCH_SIZE / (avgBatchMs / 1000)).toFixed(1) + " img/s" : "–";
      document.getElementById("throughput").textContent = thr;

      const battLevelEl = document.getElementById("battery-level");
      const battStatusEl = document.getElementById("battery-status");
      if (batteryInfo) {
        const lvl = Math.round(batteryInfo.level * 100);
        battLevelEl.textContent = lvl + " %";
        battStatusEl.textContent = batteryInfo.charging ? "in carica" : "su batteria";
      } else {
        battLevelEl.textContent = "–";
        battStatusEl.textContent = "API non disponibile";
      }

      document.getElementById("hidden-size").textContent = HIDDEN_UNITS.toString();
    }

    function updateCombineUI() {
      document.getElementById("clients-count").textContent =
        "Nodi: " + clientsState.size.toString();

      if (lastCombineTime) {
        const ageSec = Math.round((Date.now() - lastCombineTime) / 1000);
        document.getElementById("combine-age").textContent =
          ageSec + " s fa";
      } else {
        document.getElementById("combine-age").textContent = "–";
      }

      document.getElementById("combine-neighbors").textContent =
        lastCombineNeighbors > 0
          ? `${lastCombineNeighbors} vicini usati`
          : "nessuna fusione recente";

      document.getElementById("combine-trust").textContent =
        lastCombineTrustMean != null
          ? (lastCombineTrustMean * 100).toFixed(1) + " %"
          : "–";

      document.getElementById("combine-sinkhorn").textContent =
        lastCombineSinkhornMean != null
          ? lastCombineSinkhornMean.toFixed(3)
          : "–";
    }

    function resizeMeshCanvas() {
      const canvas = document.getElementById("meshCanvas");
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawMesh();
    }
    window.addEventListener("resize", resizeMeshCanvas);

    function drawMesh() {
      const canvas = document.getElementById("meshCanvas");
      const ctx = canvas.getContext("2d");
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      ctx.clearRect(0, 0, width, height);

      const entries = Array.from(clientsState.entries());
      const n = entries.length;
      if (!n) return;

      const cx = width / 2;
      const cy = height / 2;
      const radius = Math.min(width, height) * 0.35;
      meshNodesLayout.clear();

      for (let i = 0; i < n; i++) {
        const [cid, data] = entries[i];
        const angle = 2 * Math.PI * i / n;
        const x = cx + radius * Math.cos(angle);
        const y = cy + radius * Math.sin(angle);
        const stepsNorm = Math.min(1, (data.localSteps || 0) / 500);
        const r = 9 + 7 * stepsNorm;
        meshNodesLayout.set(cid, { x, y, r });
      }

      ctx.strokeStyle = "rgba(120,150,255,0.15)";
      ctx.lineWidth = 1;
      for (let i = 0; i < n; i++) {
        for (let j = i+1; j < n; j++) {
          const [cid1] = entries[i];
          const [cid2] = entries[j];
          const n1 = meshNodesLayout.get(cid1);
          const n2 = meshNodesLayout.get(cid2);
          ctx.beginPath();
          ctx.moveTo(n1.x, n1.y);
          ctx.lineTo(n2.x, n2.y);
          ctx.stroke();
        }
      }

      for (let i = 0; i < n; i++) {
        const [cid, data] = entries[i];
        const node = meshNodesLayout.get(cid);
        const isSelf = cid === clientId;
        let color = "#4f9cff";
        const vLoss = data.localValLoss;
        if (vLoss != null && Number.isFinite(vLoss)) {
          if (vLoss < 0.4) color = "#57e39f";
          else if (vLoss < 0.9) color = "#ffd166";
          else color = "#ff6b6b";
        }
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.r, 0, 2*Math.PI);
        ctx.fillStyle = isSelf ? "#ffffff" : color;
        ctx.fill();
        ctx.lineWidth = isSelf ? 3 : 1.5;
        ctx.strokeStyle = isSelf ? "#4f9cff" : "#111728";
        ctx.stroke();
      }
    }

    document.getElementById("meshCanvas").addEventListener("click", (evt) => {
      const canvas = document.getElementById("meshCanvas");
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;

      if (!meshNodesLayout.size) return;

      let bestId = null;
      let bestD2 = Infinity;
      for (const [cid, node] of meshNodesLayout.entries()) {
        const dx = x - node.x;
        const dy = y - node.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2) {
          bestD2 = d2;
          bestId = cid;
        }
      }
      if (!bestId) return;
      const node = meshNodesLayout.get(bestId);
      const maxD2 = node.r * node.r * 4;
      if (bestD2 > maxD2 && meshNodesLayout.size > 1) return;
      showNodeDetails(bestId);
    });

    function showNodeDetails(cid) {
      const d = clientsState.get(cid);
      const body = document.getElementById("node-details-body");
      if (!d) {
        body.textContent = "Nessun dato per questo nodo.";
        return;
      }
      const isSelf = cid === clientId;
      const lines = [];
      lines.push(`<div><strong>${isSelf ? "Questo nodo" : "Nodo remoto"}</strong></div>`);
      lines.push(`<div style="word-break:break-all;font-size:0.7rem;">ID: ${cid}</div>`);
      lines.push(`<div>Steps: ${d.localSteps ?? 0}</div>`);
      lines.push(`<div>Samples: ${d.localSamples ?? 0}</div>`);
      lines.push(`<div>Val loss: ${
        d.localValLoss != null && Number.isFinite(d.localValLoss)
          ? d.localValLoss.toFixed(4)
          : "–"
      }</div>`);
      const trustEntry = trustScores.get(cid);
      if (trustEntry && typeof trustEntry.score === "number") {
        lines.push(
          `<div>Trust (locale): ${(trustEntry.score*100).toFixed(1)} %</div>`
        );
      }
      lines.push(`<div>Ultimo visto: ${
        d.lastSeen ? new Date(d.lastSeen).toLocaleTimeString() : "–"
      }</div>`);
      body.innerHTML = lines.join("");
    }

    /******************************************************************
     * BATTERIA
     ******************************************************************/
    function initBattery() {
      if ("getBattery" in navigator) {
        navigator.getBattery().then(b => {
          batteryInfo = b;
          b.addEventListener("levelchange", updateLocalUI);
          b.addEventListener("chargingchange", updateLocalUI);
          updateLocalUI();
        }).catch(()=>{});
      }
    }

    /******************************************************************
     * TESTER: FILE + SAMPLE GALLERY (usa *model* locale)
     ******************************************************************/
    function probsContainNonFinite(arr) {
      for (let i = 0; i < arr.length; i++) {
        if (!Number.isFinite(arr[i])) return true;
      }
      return false;
    }

    async function predictOne(x) {
      const y = model.predict(x);
      const probs = await y.data();
      y.dispose();
      if (probsContainNonFinite(probs)) return null;
      let best = 0;
      for (let i = 1; i < probs.length; i++) {
        if (probs[i] > probs[best]) best = i;
      }
      return {
        probs: Array.from(probs),
        predIdx: best
      };
    }

    function formatSoftmaxLine(pred, classes) {
      if (!pred) return "NaN / modello instabile";
      const probsStr = pred.probs
        .map((p, i) => `${classes[i] ?? i}:${p.toFixed(3)}`)
        .join(", ");
      return `[${probsStr}] → pred: ${classes[pred.predIdx] ?? pred.predIdx}`;
    }

    function initTesterUI() {
      const input = document.getElementById("test-image-input");
      const btn = document.getElementById("test-btn");
      btn.addEventListener("click", async () => {
        const file = input.files && input.files[0];
        if (!file || !model) return;
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = async () => {
            const canvas = document.getElementById("imageLoaderCanvas");
            const ctx = canvas.getContext("2d");
            canvas.width = IMG_SIZE;
            canvas.height = IMG_SIZE;
            ctx.drawImage(img, 0, 0, IMG_SIZE, IMG_SIZE);
            let imgTensor = tf.browser.fromPixels(canvas, NUM_CHANNELS);
            imgTensor = tf.tidy(() => imgTensor.toFloat().div(255.0));
            const x = imgTensor.expandDims(0);
            imgTensor.dispose();

            const pred = await predictOne(x);
            x.dispose();

            const classes = trainManifest?.classes || [];
            const resultEl = document.getElementById("tester-result");
            resultEl.textContent =
              `File caricato\n` + formatSoftmaxLine(pred, classes);
            devLog("Test file: predIdx=" + (pred?.predIdx ?? "n/d"));
          };
          img.onerror = () => {
            document.getElementById("tester-result").textContent =
              "Errore caricamento immagine.";
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      });
    }

    function populateSampleGallery() {
      const container = document.getElementById("sample-images-container");
      if (!container || !valManifest || !valManifest.items || !valManifest.items.length) return;
      container.innerHTML = "";
      const items = valManifest.items;
      const numSamples = Math.min(12, items.length);
      const used = new Set();
      while (used.size < numSamples) {
        const idx = Math.floor(Math.random() * items.length);
        used.add(idx);
      }
      for (const idx of used) {
        const item = items[idx];
        const imgEl = document.createElement("img");
        imgEl.src = item.url;
        imgEl.className = "sample-thumb";
        imgEl.title = "Label reale: " + item.label;
        imgEl.dataset.label = item.label;
        imgEl.dataset.url = item.url;
        imgEl.addEventListener("click", async () => {
          document.querySelectorAll(".sample-thumb.selected")
            .forEach(el => el.classList.remove("selected"));
          imgEl.classList.add("selected");
          try {
            const x = await loadImageAsTensor(item.url);
            const pred = await predictOne(x);
            x.dispose();
            const classes = trainManifest?.classes || [];
            const trueLabel = classes[item.label] ?? String(item.label);
            const resultEl = document.getElementById("tester-result");
            resultEl.textContent =
              `Sample dal dataset (label reale: ${trueLabel})\n` +
              formatSoftmaxLine(pred, classes);
            devLog(
              `Pred sample (true=${trueLabel}): predIdx=${pred?.predIdx ?? "n/d"}`
            );
          } catch (e) {
            console.error("Errore pred sample:", e);
            devLog("Errore pred sample: " + e.message);
          }
        });
        container.appendChild(imgEl);
      }
    }

    /******************************************************************
     * PANIC BUTTON (reset solo locale)
     ******************************************************************/
    async function localPanicReset() {
      if (!confirm("Reset locale: azzera il modello e le statistiche su questo dispositivo. Procedere?")) {
        return;
      }
      devLog("Panic reset richiesto.");
      try {
        localStorage.removeItem(META_STORAGE_KEY);
      } catch {}
      if (model) model.dispose();
      model = buildModel();
      localSteps = 0;
      localSamples = 0;
      lastTrainLoss = null;
      lastValLoss = null;
      avgBatchMs = 0;
      await saveLocalMeta();
      updateLocalUI();
      document.getElementById("tester-result").textContent =
        "Modello locale resettato. Il training riparte da zero.";
    }

    /******************************************************************
     * ENTRYPOINT
     ******************************************************************/
    async function start() {
      devLog("Start app.");
      initCharts();
      initTesterUI();
      initBattery();
      resizeMeshCanvas();
      updateLocalUI();
      updateCombineUI();

      const { trainManifest: tm, valManifest: vm } = await loadMnistManifests();
      trainManifest = tm;
      valManifest   = vm;
      populateSampleGallery();

      try {
        await signInAnonymously(auth);
        devLog("Login anonimo Firebase OK.");
      } catch (e) {
        console.error("Errore signInAnonymously:", e);
        devLog("Errore signInAnonymously: " + e.message);
        return;
      }

      onAuthStateChanged(auth, async (user) => {
        if (!user) return;
        currentUser = user;
        clientId = user.uid;
        document.getElementById("client-pill").textContent =
          "Client: " + clientId.slice(0, 6) + "…";
        devLog("Auth: clientId=" + clientId);

        await loadLocalModelOrInit();
        document.getElementById("model-pill").textContent = "Modello: pronto";
        document.getElementById("test-btn").disabled = false;
        updateLocalUI();

        const roomRef = doc(db, "rooms", ROOM_ID);
        await setDoc(roomRef, {
          name: "ATC MNIST Demo",
          createdAt: serverTimestamp()
        }, { merge: true });

        const clientRef = doc(db, "rooms", ROOM_ID, "clients", clientId);
        await setDoc(clientRef, {
          lastSeen: serverTimestamp(),
          localSteps,
          localSamples,
          localValLoss: lastValLoss
        }, { merge: true });

        setInterval(() => {
          if (!clientId) return;
          setDoc(clientRef, { lastSeen: serverTimestamp() }, { merge: true });
        }, 30000);

        const { snapsRef } = subscribeClientsAndSnapshots(db, ROOM_ID);

        trainingLoop(clientRef, snapsRef);
        combineLoop();
      });

      document.getElementById("panic-btn").addEventListener("click", () => {
        localPanicReset().catch(e => console.error("Errore panic:", e));
      });
    }

    start().catch(e => {
      console.error("Errore start():", e);
      devLog("Errore start(): " + e.message);
    });
  </script>
</body>
</html>
